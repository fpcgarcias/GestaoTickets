import express, { Response } from "express";

import type { Express, Request, NextFunction as NextFnExpress } from "express";

import { createServer, type Server as HttpServer } from "http";

import { WebSocketServer, WebSocket } from 'ws';

import { storage } from "./storage";

import { z } from "zod";

import { insertTicketSchema, insertTicketReplySchema, slaDefinitions, departments as departmentsSchema, userRoleEnum, customers } from "@shared/schema";

import { eq, desc, asc, isNull, sql, and, ne, or, inArray, ilike, not, type SQLWrapper, gte, lte } from "drizzle-orm";

import * as schema from "@shared/schema";

import { users } from "@shared/schema";

import { db } from "./db";

import { notificationService } from "./services/notification-service";

import * as crypto from 'crypto';

import multer from 'multer';

import s3Service from './services/s3-service';

import { emailConfigService, type EmailConfig, type SMTPConfigInput } from './services/email-config-service';

import { emailNotificationService } from './services/email-notification-service';

import dashboardRouter from './routes/dashboard';

import logsRouter from './routes/logs';

import * as aiSuggestionsAPI from './api/ai-suggestions';

import ticketParticipantsRouter from './routes/ticket-participants';

import reportsRouter from './routes/reports';



// üî• FASE 5.2: Importar middlewares de autoriza√ß√£o centralizados

import { 

  authRequired, 

  adminRequired, 

  companyAdminRequired, 

  managerRequired, 

  supervisorRequired, 

  triageRequired, 

  viewerRequired, 

  authorize, 

  companyAccessRequired, 

  ticketAccessRequired, 

  participantManagementRequired, 

  canAddParticipants, 

  canRemoveParticipants,

  departmentAccessRequired,

  canManageUserRole 

} from './middleware/authorization';



// === IMPORTS DE SEGURAN√áA ===
// NOTA: Os imports de rate limiting foram movidos para dentro de registerRoutes()
// para evitar conflitos com trust proxy que √© configurado depois



// === IMPORTS DE M√âTRICAS T√âCNICAS ===

import {

  recordApiError,

  recordApiResponseTime

} from './telemetry/custom-metrics';



// === IMPORTS DE MONITORAMENTO ===

import {

  getSecurityReport,

  getSystemStats,

  healthCheck,

  clearSecurityLogs,

  logSecurityEvent

} from './api/security-monitoring';



// === IMPORTS DE PERFORMANCE ===

import { performanceMiddleware, performanceStatsHandler } from './middleware/performance';



// === IMPORTS DE LOGGING ===

import { logger, logPerformance, logSecurity } from './services/logger';



// Importa√ß√µes para o sistema de IA

import { AiService } from './services/ai-service';

import { 

  getAiConfigurations, 

  createAiConfiguration, 

  updateAiConfiguration, 

  deleteAiConfiguration, 

  testAiConfiguration,

  getAiProviders,

  getAiProvidersAdmin,

  updateAiProvidersAdmin,

  getAiCompanies,

  updateAiCompanyPermission

} from './api/ai-configurations';



// Importar fun√ß√µes de permiss√µes de empresa

import {

  getCompanyPermissions,

  updateCompanyPermissions,

  getAllCompaniesPermissions,

  getAiUsageSettings,

  updateAiUsageSettings

} from './api/company-permissions';



// Rota para configura√ß√µes de uso de IA

const settingsRouter = express.Router();

settingsRouter.get('/ai-usage', authRequired, companyAdminRequired, getAiUsageSettings);

settingsRouter.put('/ai-usage', authRequired, companyAdminRequired, updateAiUsageSettings);





// Importar fun√ß√µes do novo servi√ßo de SLA

import { resolveSLA, getCacheStats, preloadCache, cleanCache } from './api/sla-resolver';



// Importar fun√ß√µes do servi√ßo de configura√ß√µes SLA

import { 

  getSLAConfigurations,

  getSLAConfigurationById,

  createSLAConfiguration,

  updateSLAConfiguration,

  deleteSLAConfiguration,

  bulkCreateSLAConfigurations,

  bulkUpdateSLAConfigurations,

  bulkDeleteSLAConfigurations,

  bulkToggleActiveSLAConfigurations,

  copySLAConfigurations,

  validateSLAConfiguration,

  importSLAConfigurationsCSV

} from './api/sla-configurations';



// Importar API do Dashboard SLA

import { slaApi } from './api/sla-dashboard';



// Schemas Zod para valida√ß√£o de Departamentos (definidos aqui temporariamente)

const insertDepartmentSchemaInternal = z.object({

  name: z.string().min(1, "Nome √© obrigat√≥rio"),

  description: z.string().optional().nullable(),

  company_id: z.number().int().positive().optional().nullable(),

  is_active: z.boolean().optional(),

  sla_mode: z.enum(['type', 'category']).optional(),

  satisfaction_survey_enabled: z.boolean().optional(),

});

const updateDepartmentSchemaInternal = insertDepartmentSchemaInternal.partial();



// Fun√ß√£o auxiliar para salvar e carregar configura√ß√µes

async function saveSystemSetting(key: string, value: string, companyId?: number): Promise<void> {

  // Para contornar a constraint √∫nica, usar uma chave composta quando h√° company_id

  const compositeKey = companyId ? `${key}_company_${companyId}` : key;

  

  const whereCondition = eq(schema.systemSettings.key, compositeKey);



  const [existing] = await db

    .select()

    .from(schema.systemSettings)

    .where(whereCondition);

    

  if (existing) {

    await db

      .update(schema.systemSettings)

      .set({ 

        value: value,

        updated_at: new Date()

      })

      .where(eq(schema.systemSettings.id, existing.id));

  } else {

    await db

      .insert(schema.systemSettings)

      .values({

        key: compositeKey,

        value: value,

        company_id: companyId || null,

        created_at: new Date(),

        updated_at: new Date()

      });

  }

}



async function getSystemSetting(key: string, defaultValue: string = '', companyId?: number): Promise<string> {

  // Para contornar a constraint √∫nica, usar uma chave composta quando h√° company_id

  const compositeKey = companyId ? `${key}_company_${companyId}` : key;

  

  const whereCondition = eq(schema.systemSettings.key, compositeKey);



  const [setting] = await db

    .select()

    .from(schema.systemSettings)

    .where(whereCondition);

    

  return setting ? setting.value : defaultValue;

}



function validateRequest(schemaToValidate: z.ZodType<any, any>) {

  return (req: Request, res: Response, next: NextFnExpress) => {

    try {

      req.body = schemaToValidate.parse(req.body);

      next();

    } catch (error) {

      if (error instanceof z.ZodError) {

        return res.status(400).json({

          message: "Validation error",

          errors: error.errors,

        });

      }

      next(error);

    }

  };

}



// üî• FASE 5.2: Middlewares de autoriza√ß√£o movidos para arquivo centralizado

// Ver: server/middleware/authorization.ts



function fixEmailDomain(email: string, source: string): { email: string, wasFixed: boolean } {

  if (!email || !email.includes('@') || !process.env.AD_EMAIL_DOMAIN) {

    return { email, wasFixed: false };

  }

  

  const parts = email.split('@');

  const userPart = parts[0];

  const domainPart = parts[1];

  

  if (domainPart && 

      ((

        process.env.AD_DOMAIN && domainPart.toLowerCase() === process.env.AD_DOMAIN.toLowerCase()

      ) ||

      domainPart.toLowerCase().includes('local') ||

      domainPart.toLowerCase().includes('internal') ||

      domainPart.toLowerCase().includes('ad') ||

      domainPart.toLowerCase().includes('corp'))

    ) {

    const fixedEmail = `${userPart}@${process.env.AD_EMAIL_DOMAIN}`;

    return { email: fixedEmail, wasFixed: true };

  }

  

  return { email, wasFixed: false };

}



// üî• FASE 5.2: Fun√ß√µes de autoriza√ß√£o movidas para arquivo centralizado

// Ver: server/middleware/authorization.ts



// üî• FASE 5.3: Fun√ß√£o auxiliar para verificar se usu√°rio customer tamb√©m √© official

async function isUserAlsoOfficial(userId: number): Promise<boolean> {

  try {

    const [official] = await db

      .select()

      .from(schema.officials)

      .where(and(

        eq(schema.officials.user_id, userId),

        eq(schema.officials.is_active, true)

      ))

      .limit(1);

    

    return !!official;

  } catch (error) {

    console.error('Erro ao verificar se usu√°rio √© tamb√©m official:', error);

    return false;

  }

}



// Fun√ß√£o auxiliar para verificar se um usu√°rio pode responder a um ticket

async function canUserReplyToTicket(

  userId: number, 

  userRole: string, 

  ticketId: number, 

  userCompanyId?: number

): Promise<{ canReply: boolean; reason?: string }> {

  try {

    // Buscar o ticket

    const ticket = await storage.getTicket(ticketId, userRole, userCompanyId);

    if (!ticket) {

      return { canReply: false, reason: "Ticket n√£o encontrado" };

    }



    // Verificar se o ticket est√° resolvido

    if (ticket.status === 'resolved') {

      return { canReply: false, reason: "N√£o √© poss√≠vel responder a tickets resolvidos" };

    }



    // üî• FASE 4.1: Verificar se o usu√°rio √© participante do ticket

    const isParticipant = await storage.isUserTicketParticipant(ticketId, userId);

    

    // Se √© participante, sempre pode responder

    if (isParticipant) {

      return { canReply: true };

    }



    // Verificar permiss√µes baseadas na role

    if (userRole === 'admin' || userRole === 'support' || userRole === 'manager' || userRole === 'supervisor' || userRole === 'company_admin') {

      return { canReply: true };

    }



    // Para clientes, verificar se √© o criador do ticket

    if (userRole === 'customer') {

      if (ticket.customer_id) {

        const [customer] = await db

          .select()

          .from(customers)

          .where(eq(customers.id, ticket.customer_id));

        

        if (customer?.user_id === userId) {

          return { canReply: true };

        }

      }

      return { canReply: false, reason: "Apenas o criador do ticket pode responder" };

    }



    return { canReply: false, reason: "Permiss√£o insuficiente para responder a este ticket" };

  } catch (error) {

    console.error('Erro ao verificar permiss√µes de resposta:', error);

    return { canReply: false, reason: "Erro interno ao verificar permiss√µes" };

  }

}



export async function registerRoutes(app: Express): Promise<HttpServer> {

  const router = express.Router();

  // === IMPORTS DE SEGURAN√áA (movidos para c√° para evitar conflitos com trust proxy) ===
  const { 
    authLimiter, 
    apiLimiter, 
    uploadLimiter, 
    validateSchema, 
    loginSchema, 
    ticketSchema, 
    sanitizeHtml, 
    securityLogger, 
    validateFileUpload
  } = await import('./middleware/security');

  

  // === APLICAR MIDDLEWARES DE SEGURAN√áA SELETIVAMENTE ===

  // Aplicar apenas em produ√ß√£o e de forma mais suave

  if (process.env.NODE_ENV === 'production') {

    router.use(securityLogger); // Log de atividades suspeitas

    router.use(sanitizeHtml);   // Sanitiza√ß√£o de HTML

    router.use(apiLimiter);     // Rate limiting geral para API

  } else {

    console.log('üîß Middlewares de seguran√ßa DESABILITADOS em desenvolvimento');

  }

  

  // === APLICAR MIDDLEWARE DE PERFORMANCE ===

  router.use(performanceMiddleware); // Monitoramento de performance em todas as rotas

  

  // Nova rota para diagn√≥stico de extra√ß√£o de email do AD (admin)

  router.get("/auth/test-ad-email", async (req: Request, res: Response) => {

    try {

      const username = req.query.username as string;

      

      if (!username) {

        return res.status(400).json({ 

          message: "Nome de usu√°rio √© obrigat√≥rio", 

          usage: "?username=nome.usuario" 

        });

      }

      



      

      const { authenticateAD } = await import('./utils/active-directory');

      

      if (!process.env.AD_URL || !process.env.AD_BASE_DN || !process.env.AD_USERNAME || !process.env.AD_PASSWORD) {

        return res.status(500).json({

          success: false,

          message: "Configura√ß√£o do AD incompleta. Verifique as vari√°veis de ambiente."

        });

      }

      

      const { Client } = await import('ldapts');

      const adConfig = {

        url: process.env.AD_URL!,

        baseDN: process.env.AD_BASE_DN!,

        username: process.env.AD_USERNAME!,

        password: process.env.AD_PASSWORD!

      };

      

      const client = new Client({

        url: adConfig.url,

        timeout: 10000

      });

      

      try {

        // Fazer bind com a conta de servi√ßo

        await client.bind(adConfig.username, adConfig.password);

        

        // Buscar o usu√°rio

        const formattedUsername = username.includes('@') ? username.split('@')[0] : username;

        const searchFilter = `(|(sAMAccountName=${formattedUsername})(userPrincipalName=${username}))`;

        

        const { searchEntries } = await client.search(adConfig.baseDN, {

          scope: 'sub',

          filter: searchFilter,

          attributes: ['sAMAccountName', 'mail', 'displayName', 'userPrincipalName', 'proxyAddresses']

        });

        

        if (!searchEntries || searchEntries.length === 0) {

          return res.status(404).json({ success: false, message: "Usu√°rio n√£o encontrado no AD" });

        }

        

        const userEntry = searchEntries[0];

        res.json({ success: true, user: userEntry });

        

      } catch (err) {

        console.error("[AD Email Test] Erro ao buscar usu√°rio no AD:", err);

        return res.status(500).json({ success: false, message: "Erro ao buscar usu√°rio no AD", error: err });

      } finally {

        try {

          await client.unbind();

        } catch (unbindError) {

          // Ignorar erros de unbind

        }

      }



    } catch (error) {

      console.error("[AD Email Test] Erro inesperado:", error);

      res.status(500).json({ success: false, message: "Erro inesperado no teste de email do AD" });

    }

  });

  

  // Rotas p√∫blicas (sem autentica√ß√£o) - Login, Logout, Registro

  // Estas rotas n√£o precisam de middleware de autentica√ß√£o



  // Rota para registro de novos usu√°rios

  router.post("/register", async (req: Request, res: Response) => {

    try {

      const { email, password, name, role, cnpj } = req.body;

      

      // Usar o email como nome de usu√°rio

      const username = email;

      

      // Verificar se o usu√°rio j√° existe

      const existingUser = await storage.getUserByUsername(username);

      if (existingUser) {

        return res.status(400).json({ message: "Nome de usu√°rio j√° existe" });

      }

      

      const existingEmail = await storage.getUserByEmail(email);

      if (existingEmail) {

        return res.status(400).json({ message: "Email j√° est√° em uso" });

      }

      

      // Buscar empresa pelo CNPJ

      let companyId = null;

      if (cnpj) {

        const [company] = await db

          .select()

          .from(schema.companies)

          .where(eq(schema.companies.cnpj, cnpj))

          .limit(1);

        

        if (company) {

          // Verificar se a empresa est√° ativa

          if (!company.active) {

            return res.status(403).json({ message: "Empresa inativa. Contate o administrador." });

          }

          companyId = company.id;

        } else {

          return res.status(404).json({ message: "Empresa n√£o encontrada com este CNPJ. Entre em contato com o administrador." });

        }

      }

      

      // Criar usu√°rio - por padr√£o, novos usu√°rios ter√£o o papel de 'customer' a menos que especificado diferente

      const userRole = role || 'customer';

      

      // Criptografar a senha fornecida pelo usu√°rio

      const { hashPassword } = await import('./utils/password');

      const hashedPassword = await hashPassword(password);

      

      // Criar o usu√°rio com o companyId

      const user = await storage.createUser({

        username,

        email,

        password: hashedPassword,

        name,

        role: userRole as typeof schema.userRoleEnum.enumValues[number],

        avatar_url: null,

        company_id: companyId

      });

      

      // Criar um registro de cliente vinculado ao usu√°rio

      if (userRole === 'customer' && companyId) {

        await storage.createCustomer({

          name,

          email,

          user_id: user.id,

          company_id: companyId

        });

      }

      

      // Autenticar o usu√°rio rec√©m-registrado

      if (req.session) {

        req.session.userId = user.id;

        // Mapear TODOS os roles v√°lidos para a sess√£o

        const validRoles = ['admin', 'company_admin', 'manager', 'supervisor', 'support', 'triage', 'customer', 'viewer', 'quality', 'integration_bot'];

        if (validRoles.includes(user.role)) {

          req.session.userRole = user.role;

        } else {

          console.warn(`Papel de usu√°rio '${user.role}' n√£o √© v√°lido. Roles v√°lidos: ${validRoles.join(', ')}`);

          // Definir como customer por seguran√ßa

          req.session.userRole = 'customer';

        }

        if (companyId) {

          req.session.companyId = companyId;

        }

      }

      

      // N√£o retornar a senha

      const { password: _, ...userWithoutPassword } = user;

      

      res.status(201).json(userWithoutPassword);

    } catch (error) {

      console.error('Erro ao registrar usu√°rio:', error);

      res.status(500).json({ message: "Falha ao registrar usu√°rio", error: String(error) });

    }

  });



  // Tickets endpoints - Todas as rotas abaixo dessa linha precisam de autentica√ß√£o

  router.get("/tickets", authRequired, async (req: Request, res: Response) => {

    try {

      const conditions: (SQLWrapper | undefined)[] = [];



      const role = req.session.userRole as string; // Cast para string para uso em compara√ß√µes

      const userId = req.session.userId;

      const companyId = req.session.companyId;



      if (!userId) {

        return res.status(401).json({ message: "N√£o autenticado" });

      }



      if (role === 'admin') {

        // Admin v√™ todos os tickets

      } else if (role === 'company_admin') {

        if (companyId) {

          conditions.push(eq(schema.tickets.company_id, companyId));

        } else {

           return res.json([]); // company_admin sem companyId n√£o deve ver tickets

        }

      } else if (role === 'manager') {

        if (companyId) {

          conditions.push(eq(schema.tickets.company_id, companyId));

          

          // Manager pode ver tickets de:

          // 1. Seus pr√≥prios tickets

          // 2. Tickets de todos os atendentes que t√™m ele como manager

          // 3. Tickets n√£o atribu√≠dos dos departamentos dos atendentes sob sua gest√£o

          

          const [managerOfficial] = await db.select().from(schema.officials).where(eq(schema.officials.user_id, userId)).limit(1);

          if (managerOfficial) {

            // Buscar todos os atendentes que t√™m este manager

            const subordinates = await db.select().from(schema.officials).where(eq(schema.officials.manager_id, managerOfficial.id));

            const subordinateIds = subordinates.map(s => s.id);

            

            // Buscar departamentos dos subordinados para tickets n√£o atribu√≠dos

            const allDepartments = new Set<number>();

            for (const subordinate of subordinates) {

              const departments = await db.select().from(schema.officialDepartments).where(eq(schema.officialDepartments.official_id, subordinate.id));

              departments.forEach(dept => allDepartments.add(dept.department_id));

            }

            

            // Buscar seus pr√≥prios departamentos tamb√©m

            const managerDepartments = await db.select().from(schema.officialDepartments).where(eq(schema.officialDepartments.official_id, managerOfficial.id));

            managerDepartments.forEach(dept => allDepartments.add(dept.department_id));

            

            const departmentIds = Array.from(allDepartments);

            

            const ticketConditions = [

              eq(schema.tickets.assigned_to_id, managerOfficial.id), // Seus pr√≥prios tickets

            ];

            

            if (subordinateIds.length > 0) {

              ticketConditions.push(inArray(schema.tickets.assigned_to_id, subordinateIds)); // Tickets dos subordinados

            }

            

            if (departmentIds.length > 0) {

              ticketConditions.push(

                and(

                  isNull(schema.tickets.assigned_to_id), // Tickets n√£o atribu√≠dos

                  inArray(schema.tickets.department_id, departmentIds) // Dos departamentos relevantes

                )

              );

            }

            

            conditions.push(or(...ticketConditions));

          } else {

            return res.json([]); // Usu√°rio manager n√£o √© um atendente

          }

        } else {

            return res.json([]); // manager sem companyId n√£o deve ver tickets

        }

      } else if (role === 'supervisor') {

        if (companyId) {

          conditions.push(eq(schema.tickets.company_id, companyId));

          

          // Supervisor pode ver tickets de:

          // 1. Seus pr√≥prios tickets

          // 2. Tickets dos atendentes que t√™m ele como supervisor

          // 3. Tickets n√£o atribu√≠dos dos departamentos dos atendentes sob sua supervis√£o

          

          const [supervisorOfficial] = await db.select().from(schema.officials).where(eq(schema.officials.user_id, userId)).limit(1);

          if (supervisorOfficial) {

            // Buscar todos os atendentes que t√™m este supervisor

            const subordinates = await db.select().from(schema.officials).where(eq(schema.officials.supervisor_id, supervisorOfficial.id));

            const subordinateIds = subordinates.map(s => s.id);

            

            // Buscar departamentos dos subordinados para tickets n√£o atribu√≠dos

            const allDepartments = new Set<number>();

            for (const subordinate of subordinates) {

              const departments = await db.select().from(schema.officialDepartments).where(eq(schema.officialDepartments.official_id, subordinate.id));

              departments.forEach(dept => allDepartments.add(dept.department_id));

            }

            

            // Buscar seus pr√≥prios departamentos tamb√©m

            const supervisorDepartments = await db.select().from(schema.officialDepartments).where(eq(schema.officialDepartments.official_id, supervisorOfficial.id));

            supervisorDepartments.forEach(dept => allDepartments.add(dept.department_id));

            

            const departmentIds = Array.from(allDepartments);

            

            const ticketConditions = [

              eq(schema.tickets.assigned_to_id, supervisorOfficial.id), // Seus pr√≥prios tickets

            ];

            

            if (subordinateIds.length > 0) {

              ticketConditions.push(inArray(schema.tickets.assigned_to_id, subordinateIds)); // Tickets dos subordinados

            }

            

            if (departmentIds.length > 0) {

              ticketConditions.push(

                and(

                  isNull(schema.tickets.assigned_to_id), // Tickets n√£o atribu√≠dos

                  inArray(schema.tickets.department_id, departmentIds) // Dos departamentos relevantes

                )

              );

            }

            

            conditions.push(or(...ticketConditions));

          } else {

            return res.json([]); // Usu√°rio supervisor n√£o √© um atendente

          }

        } else {

            return res.json([]); // supervisor sem companyId n√£o deve ver tickets

        }

      } else if (role === 'support') {

        if (companyId) {

          conditions.push(eq(schema.tickets.company_id, companyId));

          

          // Support pode ver tickets de:

          // 1. Seus pr√≥prios tickets (atribu√≠dos a ele)

          // 2. Tickets n√£o atribu√≠dos dos seus departamentos

          

          const [official] = await db.select().from(schema.officials).where(eq(schema.officials.user_id, userId)).limit(1);

          if (official) {

            const departments = await db.select().from(schema.officialDepartments).where(eq(schema.officialDepartments.official_id, official.id));

            if (departments.length > 0) {

              const departmentIds = departments.map(d => d.department_id);

              

              if (departmentIds.length > 0) {

                conditions.push(

                  or(

                    eq(schema.tickets.assigned_to_id, official.id),

                    and(

                      isNull(schema.tickets.assigned_to_id),

                      inArray(schema.tickets.department_id, departmentIds)

                    )

                  )

                );

              } else {

                // Se n√£o conseguiu mapear os departamentos, mostrar apenas tickets atribu√≠dos

                conditions.push(eq(schema.tickets.assigned_to_id, official.id));

              }

            } else {

              // Se n√£o tem departamentos, mostrar apenas tickets atribu√≠dos diretamente

              conditions.push(eq(schema.tickets.assigned_to_id, official.id));

            }

          } else {

            return res.json([]); // Usu√°rio support n√£o √© um atendente

          }

        } else {

            return res.json([]); // support sem companyId n√£o deve ver tickets

        }

      } else if (role === 'triage') {

        if (companyId) {

          conditions.push(eq(schema.tickets.company_id, companyId));

          conditions.push(isNull(schema.tickets.assigned_to_id));

        } else {

            return res.json([]); // triage sem companyId n√£o deve ver tickets

        }

      } else if (role === 'customer') {

        const [customer] = await db.select().from(schema.customers).where(eq(schema.customers.user_id, userId)).limit(1);

        if (customer) {

          conditions.push(eq(schema.tickets.customer_id, customer.id));

        } else {

          const [user] = await db.select().from(schema.users).where(eq(schema.users.id, userId)).limit(1);

          if (user && user.email) {

            conditions.push(eq(schema.tickets.customer_email, user.email));

          } else {

             return res.json([]); // Customer sem registro ou email

          }

        }

      } else if (role === 'viewer' || role === 'quality') {

        if (companyId) {

          conditions.push(eq(schema.tickets.company_id, companyId));

        }

         // Se for admin (que tamb√©m √© viewer/quality implicitamente e j√° tratado) ou se n√£o tiver companyId, pode ver todos os globais (se aplic√°vel)

         // Se for viewer/quality SEM companyId e N√ÉO for admin, n√£o deve ver tickets.

         // A verifica√ß√£o de 'admin' j√° √© feita acima, ent√£o se chegou aqui e √© viewer/quality, n√£o √© admin.

         else if (!companyId) { 

            return res.json([]);

         }

      } else {

        return res.status(403).json({ message: "Acesso negado - Papel sem permiss√£o para visualizar tickets" });

      }



      // Enriquecer lista com nomes de departamento/tipo/categoria para exibir nos cards

      let ticketsQuery = db

        .select({

          id: schema.tickets.id,

          ticket_id: schema.tickets.ticket_id,

          title: schema.tickets.title,

          status: schema.tickets.status,

          priority: schema.tickets.priority,

          customer_email: schema.tickets.customer_email,

          created_at: schema.tickets.created_at,

          updated_at: schema.tickets.updated_at,

          resolved_at: schema.tickets.resolved_at,

          sla_breached: schema.tickets.sla_breached,

          assigned_to_id: schema.tickets.assigned_to_id,

          customer_id: schema.tickets.customer_id,

          company_id: schema.tickets.company_id,

          department_id: schema.tickets.department_id,

          incident_type_id: schema.tickets.incident_type_id,

          category_id: schema.tickets.category_id,

          department_name: schema.departments.name,

          incident_type_name: schema.incidentTypes.name,

          category_name: schema.categories.name,

        })

        .from(schema.tickets)

        .leftJoin(schema.departments, eq(schema.tickets.department_id, schema.departments.id))

        .leftJoin(schema.incidentTypes, eq(schema.tickets.incident_type_id, schema.incidentTypes.id))

        .leftJoin(schema.categories, eq(schema.tickets.category_id, schema.categories.id));



      // Filtrar as condi√ß√µes v√°lidas

      const finalConditions = conditions.filter(c => c !== undefined) as SQLWrapper[];

      if (finalConditions.length > 0) {

        ticketsQuery = ticketsQuery.where(and(...finalConditions)) as typeof ticketsQuery;

      }



      const tickets = await ticketsQuery.orderBy(desc(schema.tickets.created_at));

      return res.json(tickets);

    } catch (error) {

      console.error('Erro ao obter tickets:', error);

      res.status(500).json({ message: "Falha ao buscar tickets", error: String(error) });

    }

  });

  

  // Stats and dashboard endpoints

  // Busca tickets com base no papel do usu√°rio com pagina√ß√£o e filtros

  router.get("/tickets/user-role", authRequired, async (req: Request, res: Response) => {

    try {

      // Obter o ID do usu√°rio da sess√£o

      const userId = req.session.userId;

      const userRole = req.session.userRole as string;

      

      if (!userId || !userRole) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }

      

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 20; // 20 por p√°gina para tickets

      

      // Par√¢metros de filtro

      const search = (req.query.search as string) || '';

      const statusFilter = req.query.status as string;

      const priorityFilter = req.query.priority as string;

      const departmentFilter = req.query.department_id as string;

      const assignedToFilter = req.query.assigned_to_id as string;

      const hideResolved = req.query.hide_resolved === 'true';

      const includeOpenOutsidePeriod = req.query.include_open_outside_period === 'true';

      const timeFilter = req.query.time_filter as string;

      const dateFrom = req.query.date_from as string;

      const dateTo = req.query.date_to as string;

      

      // Preparar filtros para o m√©todo paginado

      const filters: any = {};

      

      if (search) {

        filters.search = search;

      }

      

      if (statusFilter && statusFilter !== 'all') {

        filters.status = statusFilter;

      }

      

      if (priorityFilter && priorityFilter !== 'all') {

        filters.priority = priorityFilter;

      }

      

      if (departmentFilter && departmentFilter !== 'all') {

        filters.department_id = parseInt(departmentFilter);

      }

      

      if (assignedToFilter && assignedToFilter !== 'all') {

        if (assignedToFilter === 'unassigned') {

          filters.unassigned = true;

        } else {

          filters.assigned_to_id = parseInt(assignedToFilter);

        }

      }

      

      if (hideResolved) {

        filters.hide_resolved = true;

      }

      if (includeOpenOutsidePeriod) {

        filters.include_open_outside_period = true;

      }

      

      // Processar filtros de data - USAR MESMA L√ìGICA DO DASHBOARD

      const startDate = req.query.start_date as string;

      const endDate = req.query.end_date as string;

      

      if (startDate || endDate) {

        if (startDate) {

          filters.start_date = startDate;

        }

        if (endDate) {

          filters.end_date = endDate;

        }

      } else if (dateFrom || dateTo) {

        if (dateFrom) {

          filters.date_from = dateFrom;

        }

        if (dateTo) {

          filters.date_to = dateTo;

        }

      } else if (timeFilter) {

        filters.time_filter = timeFilter;

      }

      

      // Usar o m√©todo paginado que aplica filtros no SQL

      const result = await storage.getTicketsByUserRolePaginated(userId, userRole, filters, page, limit);

      

      res.json(result);

    } catch (error) {

      console.error('Erro ao buscar tickets por papel do usu√°rio:', error);

      res.status(500).json({ message: "Falha ao buscar tickets para o usu√°rio" });

    }

  });

  

  router.get("/tickets/stats", authRequired, async (req: Request, res: Response) => {

    try {

      // Obter o ID do usu√°rio da sess√£o

      const userId = req.session.userId;

      const userRole = req.session.userRole as string;

      

      if (!userId || !userRole) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }

      

      // Obter filtros se fornecidos

      const officialId = req.query.official_id ? parseInt(req.query.official_id as string) : undefined;

      const startDate = req.query.start_date ? new Date(req.query.start_date as string) : undefined;

      const endDate = req.query.end_date ? new Date(req.query.end_date as string) : undefined;

      

      // Obter estat√≠sticas de tickets filtradas pelo papel do usu√°rio, atendente e per√≠odo

      const stats = await storage.getTicketStatsByUserRole(userId, userRole, officialId, startDate, endDate);

      res.json(stats);

    } catch (error) {

      console.error('Erro ao buscar estat√≠sticas de tickets:', error);

      res.status(500).json({ message: "Falha ao buscar estat√≠sticas de tickets" });

    }

  });



  router.get("/tickets/recent", authRequired, async (req: Request, res: Response) => {

    try {

      // Obter o ID do usu√°rio da sess√£o

      const userId = req.session.userId;

      const userRole = req.session.userRole as string;

      

      if (!userId || !userRole) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }

      

      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;

      const officialId = req.query.official_id ? parseInt(req.query.official_id as string) : undefined;

      const startDate = req.query.start_date ? new Date(req.query.start_date as string) : undefined;

      const endDate = req.query.end_date ? new Date(req.query.end_date as string) : undefined;

      

      // Obter tickets recentes filtrados pelo papel do usu√°rio, atendente e per√≠odo

      const tickets = await storage.getRecentTicketsByUserRole(userId, userRole, limit, officialId, startDate, endDate);

      res.json(tickets);

    } catch (error) {

      console.error('Erro ao buscar tickets recentes:', error);

      res.status(500).json({ message: "Falha ao buscar tickets recentes" });

    }

  });



  router.get("/tickets/average-first-response-time", authRequired, async (req: Request, res: Response) => {

    try {

      // Obter o ID do usu√°rio da sess√£o

      const userId = req.session.userId;

      const userRole = req.session.userRole as string;

      

      if (!userId || !userRole) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }

      

      const officialId = req.query.official_id ? parseInt(req.query.official_id as string) : undefined;

      const startDate = req.query.start_date ? new Date(req.query.start_date as string) : undefined;

      const endDate = req.query.end_date ? new Date(req.query.end_date as string) : undefined;

      

      // Obter tempo m√©dio de primeira resposta filtrado pelo papel do usu√°rio, atendente e per√≠odo

      const averageTime = await storage.getAverageFirstResponseTimeByUserRole(userId, userRole, officialId, startDate, endDate);

      res.json({ averageTime });

    } catch (error) {

      console.error('Erro ao buscar tempo m√©dio de primeira resposta:', error);

      res.status(500).json({ message: "Falha ao buscar tempo m√©dio de primeira resposta" });

    }

  });



  router.get("/tickets/average-resolution-time", authRequired, async (req: Request, res: Response) => {

    try {

      // Obter o ID do usu√°rio da sess√£o

      const userId = req.session.userId;

      const userRole = req.session.userRole as string;

      

      if (!userId || !userRole) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }

      

      const officialId = req.query.official_id ? parseInt(req.query.official_id as string) : undefined;

      const startDate = req.query.start_date ? new Date(req.query.start_date as string) : undefined;

      const endDate = req.query.end_date ? new Date(req.query.end_date as string) : undefined;

      

      // Obter tempo m√©dio de resolu√ß√£o filtrado pelo papel do usu√°rio, atendente e per√≠odo

      const averageTime = await storage.getAverageResolutionTimeByUserRole(userId, userRole, officialId, startDate, endDate);

      res.json({ averageTime });

    } catch (error) {

      console.error('Erro ao buscar tempo m√©dio de resolu√ß√£o:', error);

      res.status(500).json({ message: "Falha ao buscar tempo m√©dio de resolu√ß√£o" });

    }

  });



  // Individual ticket by ID

  router.get("/tickets/:id", authRequired, async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      // Passar informa√ß√µes da sess√£o para controle de empresa

      const userRole = req.session?.userRole as string;

      const userCompanyId = req.session?.companyId;



      const ticket = await storage.getTicket(id, userRole, userCompanyId);

      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      res.json(ticket);

    } catch (error) {

      res.status(500).json({ message: "Falha ao buscar ticket" });

    }

  });



  // Buscar replies de um ticket espec√≠fico

  router.get("/tickets/:id/replies", authRequired, async (req: Request, res: Response) => {

    try {

      const ticketId = parseInt(req.params.id);

      if (isNaN(ticketId)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      // ‚úÖ VERIFICAR ACESSO COM CONTROLE DE EMPRESA

      const userRole = req.session?.userRole as string;

      const userCompanyId = req.session?.companyId;

      

      const ticket = await storage.getTicket(ticketId, userRole, userCompanyId);

      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // Buscar replies do ticket

      const replies = await db

        .select({

          id: schema.ticketReplies.id,

          ticket_id: schema.ticketReplies.ticket_id,

          user_id: schema.ticketReplies.user_id,

          message: schema.ticketReplies.message,

          created_at: schema.ticketReplies.created_at,

          is_internal: schema.ticketReplies.is_internal,

          user: {

            id: schema.users.id,

            name: schema.users.name,

            role: schema.users.role,

            avatar_url: schema.users.avatar_url,

          }

        })

        .from(schema.ticketReplies)

        .leftJoin(schema.users, eq(schema.ticketReplies.user_id, schema.users.id))

        .where(eq(schema.ticketReplies.ticket_id, ticketId))

        .orderBy(desc(schema.ticketReplies.created_at)); // Mais recentes primeiro



      res.json(replies);

    } catch (error) {

      console.error('Erro ao buscar replies do ticket:', error);

      res.status(500).json({ message: "Erro ao buscar respostas do ticket" });

    }

  });



  // Buscar hist√≥rico de status de um ticket espec√≠fico

  router.get("/tickets/:id/status-history", authRequired, async (req: Request, res: Response) => {

    try {

      const ticketId = parseInt(req.params.id);

      if (isNaN(ticketId)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      // ‚úÖ VERIFICAR ACESSO COM CONTROLE DE EMPRESA

      const userRole = req.session?.userRole as string;

      const userCompanyId = req.session?.companyId;

      

      const ticket = await storage.getTicket(ticketId, userRole, userCompanyId);

      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // Buscar hist√≥rico de status do ticket (incluindo mudan√ßas de prioridade)

      const statusHistory = await db

        .select({

          id: schema.ticketStatusHistory.id,

          ticket_id: schema.ticketStatusHistory.ticket_id,

          old_status: schema.ticketStatusHistory.old_status,

          new_status: schema.ticketStatusHistory.new_status,

          change_type: schema.ticketStatusHistory.change_type,

          old_priority: schema.ticketStatusHistory.old_priority,

          new_priority: schema.ticketStatusHistory.new_priority,

          old_assigned_to_id: schema.ticketStatusHistory.old_assigned_to_id,

          new_assigned_to_id: schema.ticketStatusHistory.new_assigned_to_id,

          old_department_id: schema.ticketStatusHistory.old_department_id,

          new_department_id: schema.ticketStatusHistory.new_department_id,

          old_incident_type_id: schema.ticketStatusHistory.old_incident_type_id,

          new_incident_type_id: schema.ticketStatusHistory.new_incident_type_id,

          old_category_id: schema.ticketStatusHistory.old_category_id,

          new_category_id: schema.ticketStatusHistory.new_category_id,

          changed_by_id: schema.ticketStatusHistory.changed_by_id,

          created_at: schema.ticketStatusHistory.created_at,

          user: {

            id: schema.users.id,

            name: schema.users.name,

            role: schema.users.role,

            avatar_url: schema.users.avatar_url,

          }

        })

        .from(schema.ticketStatusHistory)

        .leftJoin(schema.users, eq(schema.ticketStatusHistory.changed_by_id, schema.users.id))

        .where(eq(schema.ticketStatusHistory.ticket_id, ticketId))

        .orderBy(desc(schema.ticketStatusHistory.created_at)); // Mais recentes primeiro



      // Enriquecer com nomes dos atendentes em eventos de transfer√™ncia

      const assignmentIds = new Set<number>();

      for (const item of statusHistory) {

        // Normalizar: se tiver colunas de departamento preenchidas, for√ßar change_type

        if ((item as any).old_department_id != null || (item as any).new_department_id != null) {

          (item as any).change_type = 'department';

        }

        if (item.change_type === 'assignment') {

          if (item.old_assigned_to_id) assignmentIds.add(item.old_assigned_to_id);

          if (item.new_assigned_to_id) assignmentIds.add(item.new_assigned_to_id);

        }

      }



      if (assignmentIds.size > 0) {

        const idsArray = Array.from(assignmentIds);

        const officialsRows = await db

          .select({ id: schema.officials.id, name: schema.officials.name, email: schema.officials.email })

          .from(schema.officials)

          .where(inArray(schema.officials.id, idsArray));

        const idToOfficial: Record<number, { id: number; name: string | null; email: string | null }> = {};

        for (const off of officialsRows) {

          idToOfficial[off.id] = off;

        }



        for (const item of statusHistory as any[]) {

          if (item.change_type === 'assignment') {

            item.old_assigned_official = item.old_assigned_to_id ? idToOfficial[item.old_assigned_to_id] || null : null;

            item.new_assigned_official = item.new_assigned_to_id ? idToOfficial[item.new_assigned_to_id] || null : null;

          }

        }

      }



      // Enriquecer nomes de departamento/tipo/categoria para eventos de transfer√™ncia

      const deptIds = new Set<number>();

      const typeIds = new Set<number>();

      const catIds = new Set<number>();

      for (const item of statusHistory as any[]) {

        if ((item.old_department_id ?? null) !== null) deptIds.add(item.old_department_id);

        if ((item.new_department_id ?? null) !== null) deptIds.add(item.new_department_id);

        if ((item.old_incident_type_id ?? null) !== null) typeIds.add(item.old_incident_type_id);

        if ((item.new_incident_type_id ?? null) !== null) typeIds.add(item.new_incident_type_id);

        if ((item.old_category_id ?? null) !== null) catIds.add(item.old_category_id);

        if ((item.new_category_id ?? null) !== null) catIds.add(item.new_category_id);

      }



      const idToDeptName: Record<number, string> = {};

      const idToTypeName: Record<number, string> = {};

      const idToCatName: Record<number, string> = {};



      if (deptIds.size > 0) {

        const rows = await db

          .select({ id: schema.departments.id, name: schema.departments.name })

          .from(schema.departments)

          .where(inArray(schema.departments.id, Array.from(deptIds)));

        for (const r of rows) idToDeptName[r.id] = r.name as unknown as string;

      }

      if (typeIds.size > 0) {

        const rows = await db

          .select({ id: schema.incidentTypes.id, name: schema.incidentTypes.name })

          .from(schema.incidentTypes)

          .where(inArray(schema.incidentTypes.id, Array.from(typeIds)));

        for (const r of rows) idToTypeName[r.id] = r.name as unknown as string;

      }

      if (catIds.size > 0) {

        const rows = await db

          .select({ id: schema.categories.id, name: schema.categories.name })

          .from(schema.categories)

          .where(inArray(schema.categories.id, Array.from(catIds)));

        for (const r of rows) idToCatName[r.id] = r.name as unknown as string;

      }



      for (const item of statusHistory as any[]) {

        if ((item.old_department_id ?? item.new_department_id) !== undefined) {

          item.old_department_name = item.old_department_id ? idToDeptName[item.old_department_id] || null : null;

          item.new_department_name = item.new_department_id ? idToDeptName[item.new_department_id] || null : null;

          item.old_incident_type_name = item.old_incident_type_id ? idToTypeName[item.old_incident_type_id] || null : null;

          item.new_incident_type_name = item.new_incident_type_id ? idToTypeName[item.new_incident_type_id] || null : null;

          item.old_category_name = item.old_category_id ? idToCatName[item.old_category_id] || null : null;

          item.new_category_name = item.new_category_id ? idToCatName[item.new_category_id] || null : null;

        }

      }



      res.json(statusHistory);

    } catch (error) {

      console.error('Erro ao buscar hist√≥rico de status do ticket:', error);

      res.status(500).json({ message: "Erro ao buscar hist√≥rico de status do ticket" });

    }

  });



  // Rota para buscar hist√≥rico de an√°lise de IA de um ticket

  router.get("/tickets/:id/ai-analysis-history", authRequired, async (req: Request, res: Response) => {

    try {

      const ticketId = parseInt(req.params.id);

      const userRole = req.session?.userRole;

      const userCompanyId = req.session?.companyId;



      if (isNaN(ticketId)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      // Buscar ticket para verificar permiss√µes

      const ticket = await storage.getTicket(ticketId, userRole, userCompanyId);

      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // Buscar hist√≥rico de an√°lise de IA

      const aiHistory = await db

        .select({

          id: schema.aiAnalysisHistory.id,

          suggested_priority: schema.aiAnalysisHistory.suggested_priority,

          ai_justification: schema.aiAnalysisHistory.ai_justification,

          provider: schema.aiAnalysisHistory.provider,

          model: schema.aiAnalysisHistory.model,

          processing_time_ms: schema.aiAnalysisHistory.processing_time_ms,

          status: schema.aiAnalysisHistory.status,

          created_at: schema.aiAnalysisHistory.created_at,

          config_name: schema.aiConfigurations.name,

          analysis_type: schema.aiAnalysisHistory.analysis_type,

        })

        .from(schema.aiAnalysisHistory)

        .leftJoin(schema.aiConfigurations, eq(schema.aiAnalysisHistory.ai_configuration_id, schema.aiConfigurations.id))

        .where(eq(schema.aiAnalysisHistory.ticket_id, ticketId))

        .orderBy(desc(schema.aiAnalysisHistory.created_at));



      res.json(aiHistory);

    } catch (error) {

      console.error('Erro ao buscar hist√≥rico de an√°lise de IA:', error);

      res.status(500).json({ message: "Falha ao buscar hist√≥rico de an√°lise de IA", error: String(error) });

    }

  });



  // Rota para auditoria de an√°lises de IA (com filtros)

  router.get("/ai-analysis-audit", authRequired, async (req: Request, res: Response) => {

    try {

      const userRole = req.session?.userRole;

      const userCompanyId = req.session?.companyId;



      // Apenas admin e company_admin podem acessar auditoria

      if (userRole !== 'admin' && userRole !== 'company_admin') {

        return res.status(403).json({ message: "Acesso negado. Apenas administradores podem acessar a auditoria." });

      }



      const {

        page = '1',

        limit = '50',

        analysis_type,

        status,

        provider,

        start_date,

        end_date,

        ticket_id,

        company_id

      } = req.query;



      const pageNum = parseInt(page as string) || 1;

      const limitNum = parseInt(limit as string) || 50;

      const offset = (pageNum - 1) * limitNum;



      // Construir condi√ß√µes de filtro

      const conditions = [];



      // Filtro por empresa (admin pode ver todas, company_admin apenas sua empresa)

      if (userRole === 'admin' && company_id) {

        conditions.push(eq(schema.aiAnalysisHistory.company_id, parseInt(company_id as string)));

      } else if (userRole === 'company_admin') {

        conditions.push(eq(schema.aiAnalysisHistory.company_id, userCompanyId!));

      }



      // Filtros opcionais

      if (analysis_type) {

        conditions.push(eq(schema.aiAnalysisHistory.analysis_type, analysis_type as string));

      }

      if (status && ['success', 'error', 'timeout', 'fallback'].includes(status as string)) {

        conditions.push(eq(schema.aiAnalysisHistory.status, status as 'success' | 'error' | 'timeout' | 'fallback'));

      }

      if (provider && ['openai', 'google', 'anthropic'].includes(provider as string)) {

        conditions.push(eq(schema.aiAnalysisHistory.provider, provider as 'openai' | 'google' | 'anthropic'));

      }

      if (ticket_id) {

        conditions.push(eq(schema.aiAnalysisHistory.ticket_id, parseInt(ticket_id as string)));

      }

      if (start_date) {

        conditions.push(gte(schema.aiAnalysisHistory.created_at, new Date(start_date as string)));

      }

      if (end_date) {

        conditions.push(lte(schema.aiAnalysisHistory.created_at, new Date(end_date as string)));

      }



      // Buscar total de registros

      const totalQuery = await db

        .select({ count: sql<number>`count(*)` })

        .from(schema.aiAnalysisHistory)

        .where(conditions.length > 0 ? and(...conditions) : undefined);



      const total = totalQuery[0]?.count || 0;



      // Buscar dados paginados

      const aiHistory = await db

        .select({

          id: schema.aiAnalysisHistory.id,

          ticket_id: schema.aiAnalysisHistory.ticket_id,

          suggested_priority: schema.aiAnalysisHistory.suggested_priority,

          ai_justification: schema.aiAnalysisHistory.ai_justification,

          provider: schema.aiAnalysisHistory.provider,

          model: schema.aiAnalysisHistory.model,

          processing_time_ms: schema.aiAnalysisHistory.processing_time_ms,

          status: schema.aiAnalysisHistory.status,

          created_at: schema.aiAnalysisHistory.created_at,

          analysis_type: schema.aiAnalysisHistory.analysis_type,

          config_name: schema.aiConfigurations.name,

          ticket_title: schema.tickets.title,

          company_name: schema.companies.name,

        })

        .from(schema.aiAnalysisHistory)

        .leftJoin(schema.aiConfigurations, eq(schema.aiAnalysisHistory.ai_configuration_id, schema.aiConfigurations.id))

        .leftJoin(schema.tickets, eq(schema.aiAnalysisHistory.ticket_id, schema.tickets.id))

        .leftJoin(schema.companies, eq(schema.aiAnalysisHistory.company_id, schema.companies.id))

        .where(conditions.length > 0 ? and(...conditions) : undefined)

        .orderBy(desc(schema.aiAnalysisHistory.created_at))

        .limit(limitNum)

        .offset(offset);



      res.json({

        data: aiHistory,

        pagination: {

          page: pageNum,

          limit: limitNum,

          total,

          totalPages: Math.ceil(total / limitNum),

          hasNext: pageNum * limitNum < total,

          hasPrev: pageNum > 1,

        }

      });

    } catch (error) {

      console.error('Erro ao buscar auditoria de an√°lises de IA:', error);

      res.status(500).json({ message: "Falha ao buscar auditoria de an√°lises de IA", error: String(error) });

    }

  });

  

  // Rota para atualizar parcialmente um ticket (ex: atribuir atendente)

  router.patch("/tickets/:id", authRequired, async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      // ‚úÖ VERIFICAR ACESSO COM CONTROLE DE EMPRESA

      const userRole = req.session?.userRole as string;

      const userCompanyId = req.session?.companyId;

      

      const existingTicket = await storage.getTicket(id, userRole, userCompanyId);

      if (!existingTicket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // üö´ BLOQUEAR CUSTOMER DE ALTERAR ATENDENTE (EXCETO SE FOR TAMB√âM OFFICIAL)

      const { assigned_to_id } = req.body;

      

      if (userRole === 'customer' && assigned_to_id !== undefined) {

        // üî• FASE 5.3: Verificar se o customer tamb√©m √© official (atendente)

        const isAlsoOfficial = await isUserAlsoOfficial(req.session?.userId!);

        

        if (!isAlsoOfficial) {

          return res.status(403).json({ 

            message: "Opera√ß√£o n√£o permitida", 

            details: "Clientes n√£o podem alterar o atendente do ticket." 

          });

        }

        

        console.log(`[PERMISS√ÉO] ‚úÖ Usu√°rio ${req.session?.userId} √© customer MAS tamb√©m √© official - opera√ß√£o permitida`);

      }



      const updateData: { assigned_to_id?: number | null } = {};



      // Se o ticket estiver resolvido e estamos tentando mudar o atendente, rejeitar

      if (existingTicket.status === 'resolved' && assigned_to_id !== undefined && assigned_to_id !== existingTicket.assigned_to_id) {

        return res.status(403).json({ 

          message: "Opera√ß√£o n√£o permitida", 

          details: "N√£o √© poss√≠vel alterar o atendente de um ticket resolvido." 

        });

      }



      // Validar assignedToId se fornecido

      if (assigned_to_id !== undefined) {

        if (assigned_to_id === null || typeof assigned_to_id === 'number') {

          // üî• VALIDA√á√ÉO CR√çTICA: Verificar se o atendente √© da MESMA EMPRESA do ticket!

          if (assigned_to_id !== null && typeof assigned_to_id === 'number') {

            // üî• CORRE√á√ÉO: Buscar dados do official que ser√° atribu√≠do

            const [assignedOfficial] = await db

              .select()

              .from(schema.officials)

              .where(and(eq(schema.officials.id, assigned_to_id), eq(schema.officials.is_active, true)))

              .limit(1);



            if (!assignedOfficial) {

              return res.status(400).json({ 

                message: "Atendente atribu√≠do n√£o encontrado ou inativo",

                details: `Official ID ${assigned_to_id} n√£o existe ou est√° inativo.`

              });

            }



            // üî• VALIDA√á√ÉO DE EMPRESA: Ticket e atendente devem ser da mesma empresa!

            if (existingTicket.company_id && assignedOfficial.company_id && existingTicket.company_id !== assignedOfficial.company_id) {

              console.error(`[üö® SEGURAN√áA] ‚ùå VIOLA√á√ÉO: Tentativa de atribuir ticket da empresa ${existingTicket.company_id} para atendente da empresa ${assignedOfficial.company_id}!`);

              console.error(`[üö® SEGURAN√áA] ‚ùå Ticket: ${existingTicket.ticket_id} (${existingTicket.title})`);

              console.error(`[üö® SEGURAN√áA] ‚ùå Atendente: ${assignedOfficial.name} (${assignedOfficial.email})`);

              

              return res.status(403).json({ 

                message: "Opera√ß√£o n√£o permitida",

                details: `N√£o √© poss√≠vel atribuir um ticket da empresa ${existingTicket.company_id} para um atendente da empresa ${assignedOfficial.company_id}.`

              });

            }



            // üî• VALIDA√á√ÉO ADICIONAL: Se ticket tem empresa, atendente deve ter empresa

            if (existingTicket.company_id && !assignedOfficial.company_id) {

              console.error(`[üö® SEGURAN√áA] ‚ùå VIOLA√á√ÉO: Atendente sem empresa para ticket com empresa!`);

              console.error(`[üö® SEGURAN√áA] ‚ùå Ticket empresa: ${existingTicket.company_id}, Atendente empresa: ${assignedOfficial.company_id}`);

              

              return res.status(403).json({ 

                message: "Opera√ß√£o n√£o permitida",

                details: `N√£o √© poss√≠vel atribuir um ticket da empresa ${existingTicket.company_id} para um atendente sem empresa.`

              });

            }



            console.log(`[‚úÖ SEGURAN√áA] Valida√ß√£o de empresa: OK - Ticket e atendente s√£o da mesma empresa`);

          }

          

          updateData.assigned_to_id = assigned_to_id;

        } else {

          return res.status(400).json({ message: "assigned_to_id inv√°lido" });

        }

      }



      if (Object.keys(updateData).length === 0) {

        return res.status(400).json({ message: "Nenhum dado v√°lido para atualizar" });

      }



      const previousAssignedToId = existingTicket.assigned_to_id || null;

      const ticket = await storage.updateTicket(id, updateData);

      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }

      

      // Notificar sobre a atualiza√ß√£o de atribui√ß√£o

      notificationService.sendNotificationToAll({

        type: 'ticket_updated',

        ticketId: ticket.id,

        title: `Atribui√ß√£o Atualizada: ${ticket.title}`,

        message: `O ticket ${ticket.ticket_id} foi atribu√≠do/desatribu√≠do.`,

        timestamp: new Date()

      });

      

      // Registrar hist√≥rico de transfer√™ncia se atribui√ß√£o mudou

      if (updateData.assigned_to_id !== undefined && previousAssignedToId !== updateData.assigned_to_id) {

        try {

          await db.insert(schema.ticketStatusHistory).values({

            ticket_id: ticket.id,

            change_type: 'assignment',

            old_assigned_to_id: previousAssignedToId,

            new_assigned_to_id: updateData.assigned_to_id ?? null,

            changed_by_id: req.session?.userId,

            created_at: new Date()

          });

        } catch (historyErr) {

          console.error('Erro ao registrar hist√≥rico de transfer√™ncia:', historyErr);

        }

      }



      // üìß ENVIAR EMAIL PARA MUDAN√áA DE ATRIBUI√á√ÉO

      if (updateData.assigned_to_id && previousAssignedToId !== updateData.assigned_to_id) {

        // üî• OTIMIZA√á√ÉO CR√çTICA: Envio de e-mail fire-and-forget (n√£o bloqueia a resposta)

        const emailStartTime = Date.now();

        console.log(`üìß [EMAIL BACKGROUND] ========================================`);

        console.log(`üìß [EMAIL BACKGROUND] üë§ INICIANDO - Ticket Atribu√≠do (PATCH)`);

        console.log(`üìß [EMAIL BACKGROUND] Ticket ID: ${ticket.id}`);

        console.log(`üìß [EMAIL BACKGROUND] Atribu√≠do para: ${updateData.assigned_to_id}`);

        console.log(`üìß [EMAIL BACKGROUND] Timestamp: ${new Date().toLocaleString('pt-BR')}`);

        console.log(`üìß [EMAIL BACKGROUND] ========================================`);

        

        // Fire-and-forget: n√£o aguarda o envio dos e-mails

        emailNotificationService.notifyTicketAssigned(ticket.id, updateData.assigned_to_id).then(() => {

          const emailDuration = Date.now() - emailStartTime;

          console.log(`üìß [EMAIL BACKGROUND] ========================================`);

          console.log(`üìß [EMAIL BACKGROUND] ‚úÖ CONCLU√çDO - Ticket Atribu√≠do (PATCH) em ${emailDuration}ms`);

          console.log(`üìß [EMAIL BACKGROUND] Ticket ID: ${ticket.id} - Todos os e-mails processados`);

          console.log(`üìß [EMAIL BACKGROUND] ========================================`);

        }).catch((emailError) => {

          const emailDuration = Date.now() - emailStartTime;

          console.error(`üìß [EMAIL BACKGROUND] ========================================`);

          console.error(`üìß [EMAIL BACKGROUND] ‚ùå ERRO - Ticket Atribu√≠do (PATCH) ap√≥s ${emailDuration}ms`);

          console.error(`üìß [EMAIL BACKGROUND] Ticket ID: ${ticket.id} - Erro:`, emailError.message);

          console.error(`üìß [EMAIL BACKGROUND] Stack:`, emailError.stack);

          console.error(`üìß [EMAIL BACKGROUND] ========================================`);

        });

      }



      res.json(ticket);

    } catch (error) {

      console.error('Erro ao atualizar ticket (patch):', error);

      res.status(500).json({ message: "Falha ao atualizar ticket", error: String(error) });

    }

  });



  // Rota para atualizar completamente um ticket (incluindo status)

  router.put("/tickets/:id", authRequired, async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      // ‚úÖ VERIFICAR ACESSO COM CONTROLE DE EMPRESA

      const userRole = req.session?.userRole as string;

      const userCompanyId = req.session?.companyId;

      

      const existingTicket = await storage.getTicket(id, userRole, userCompanyId);

      if (!existingTicket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      const { 

        title, 

        description, 

        status, 

        priority, 

        assigned_to_id, 

        department_id,

        customer_email,

        customer_id,

        type,

        incident_type_id,

        category_id

      } = req.body;



      const updateData: any = {};



      // Validar e adicionar campos que podem ser atualizados

      if (title !== undefined) updateData.title = title;

      if (description !== undefined) updateData.description = description;

      if (priority !== undefined) updateData.priority = priority;

      if (assigned_to_id !== undefined) updateData.assigned_to_id = assigned_to_id;

      if (department_id !== undefined) updateData.department_id = department_id;

      if (customer_email !== undefined) updateData.customer_email = customer_email;

      if (customer_id !== undefined) updateData.customer_id = customer_id;

      if (type !== undefined) updateData.type = type;

      if (incident_type_id !== undefined) updateData.incident_type_id = incident_type_id;

      if (category_id !== undefined) updateData.category_id = category_id;



      // üî• VALIDA√á√ÉO ESPECIAL PARA MUDAN√áA DE STATUS

      let statusChanged = false;

      let oldStatus = existingTicket.status;

      

      if (status !== undefined && status !== existingTicket.status) {

        // Validar se o usu√°rio tem permiss√£o para mudar o status

        if (userRole === 'customer' && status !== 'waiting_customer') {

          return res.status(403).json({ 

            message: "Opera√ß√£o n√£o permitida", 

            details: "Clientes s√≥ podem alterar o status para 'Aguardando Cliente'." 

          });

        }

        // üî• VALIDA√á√ÉO: Se est√° tentando alterar de 'novo' para outro status, deve ter atendente vinculado

        if (existingTicket.status === 'new' && !assigned_to_id && !existingTicket.assigned_to_id) {

          return res.status(400).json({ 

            message: "N√£o √© poss√≠vel alterar status", 

            details: "√â necess√°rio atribuir um atendente ao ticket antes de alterar o status de 'Novo'." 

          });

        }



        updateData.status = status;

        statusChanged = true;



        // Adicionar campos espec√≠ficos baseados no novo status

        if (status === 'resolved' && existingTicket.status !== 'resolved') {

          updateData.resolved_at = new Date();

        }

        if (status === 'ongoing' && !existingTicket.first_response_at) {

          updateData.first_response_at = new Date();

        }

        if (status === 'reopened') {

          updateData.reopened_at = new Date();

        }

      }



      if (Object.keys(updateData).length === 0) {

        return res.status(400).json({ message: "Nenhum dado v√°lido para atualizar" });

      }



      // üîé Valida√ß√£o: quando alterar dept/type/categoria, garantir regra de obrigatoriedade

      try {

        const effectiveDepartmentId = department_id ?? existingTicket.department_id;

        const effectiveIncidentTypeId = incident_type_id ?? existingTicket.incident_type_id;

        const effectiveCategoryId = category_id ?? existingTicket.category_id;



        if (effectiveDepartmentId && effectiveIncidentTypeId) {

          const [dept] = await db

            .select({ sla_mode: schema.departments.sla_mode })

            .from(schema.departments)

            .where(eq(schema.departments.id, effectiveDepartmentId))

            .limit(1);

          const isCategoryMode = dept?.sla_mode === 'category';

          if (isCategoryMode) {

            const activeCategories = await db

              .select({ id: schema.categories.id })

              .from(schema.categories)

              .where(and(

                eq(schema.categories.incident_type_id, effectiveIncidentTypeId),

                eq(schema.categories.is_active, true)

              ))

              .limit(1);

            const hasActiveCategories = activeCategories.length > 0;

            if (hasActiveCategories && !effectiveCategoryId) {

              return res.status(400).json({

                error: 'Categoria obrigat√≥ria',

                message: 'Sele√ß√£o de categoria obrigat√≥ria para o Departamento. Selecione uma categoria para o tipo de chamado informado.'

              });

            }

          }

        }

      } catch (validationError) {

        console.error('[Tickets] Erro ao validar categoria obrigat√≥ria (PUT):', validationError);

        return res.status(500).json({ error: 'Erro ao validar categoria obrigat√≥ria' });

      }



      // Atualizar o ticket

      const ticket = await storage.updateTicket(id, updateData);

      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // üî• ENVIAR NOTIFICA√á√ïES DE EMAIL PARA MUDAN√áA DE STATUS

      if (statusChanged) {

        try {

          // Enviar notifica√ß√£o de email para mudan√ßa de status

          emailNotificationService.notifyStatusChanged(

            ticket.id,

            String(oldStatus || ''),

            String(status || ''),

            req.session?.userId

          ).catch((emailError) => {

            console.error(`[üìß EMAIL] ‚ùå Erro ao enviar notifica√ß√£o de mudan√ßa de status:`, emailError);

          });



          // üî• ESCALA√á√ÉO AUTOM√ÅTICA QUANDO STATUS MUDA PARA "escalated"

          if (status === 'escalated') {

            try {

              emailNotificationService.notifyTicketEscalated(

                ticket.id,

                req.session?.userId,

                `Ticket escalado manualmente por ${req.session?.adUsername || 'usu√°rio'}`

              ).catch((escalationError) => {

                console.error(`[üìß EMAIL] ‚ùå Erro ao enviar notifica√ß√£o de escala√ß√£o:`, escalationError);

              });

            } catch (escalationError) {

              console.error('Erro ao enviar notifica√ß√£o de escala√ß√£o:', escalationError);

            }

          }

        } catch (notificationError) {

          console.error('Erro ao enviar notifica√ß√£o de mudan√ßa de status:', notificationError);

        }

      }



      // üî• ENVIAR NOTIFICA√á√ÉO DE EMAIL PARA MUDAN√áA DE ATRIBUI√á√ÉO

      if (assigned_to_id !== undefined && existingTicket.assigned_to_id !== assigned_to_id) {

        try {

          emailNotificationService.notifyTicketAssigned(ticket.id, assigned_to_id).catch((emailError) => {

            console.error(`[üìß EMAIL] ‚ùå Erro ao enviar notifica√ß√£o de atribui√ß√£o:`, emailError);

          });

        } catch (notificationError) {

          console.error('Erro ao enviar notifica√ß√£o de atribui√ß√£o:', notificationError);

        }

      }



      res.json(ticket);

    } catch (error) {

      console.error('Erro ao atualizar ticket (put):', error);

      res.status(500).json({ message: "Falha ao atualizar ticket", error: String(error) });

    }

  });



  // Transferir ticket entre departamentos (mesma empresa) com op√ß√£o de tipo e categoria

  router.post("/tickets/:id/transfer", authRequired, async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      const userRole = req.session?.userRole as string;

      const userId = req.session?.userId as number | undefined;

      const sessionCompanyId = req.session?.companyId as number | undefined;



      if (userRole === 'customer') {

        return res.status(403).json({ message: "Clientes n√£o podem transferir chamados" });

      }



      // Carregar ticket respeitando multiempresa

      const existingTicket = await storage.getTicket(id, userRole, sessionCompanyId);

      if (!existingTicket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      const { department_id, incident_type_id, category_id } = req.body as {

        department_id?: number;

        incident_type_id?: number;

        category_id?: number | null;

      };



      if (!department_id || !incident_type_id) {

        return res.status(400).json({ message: "department_id e incident_type_id s√£o obrigat√≥rios" });

      }



      // Validar departamento (mesma empresa do ticket)

      const [targetDept] = await db

        .select({ id: schema.departments.id, company_id: schema.departments.company_id, sla_mode: schema.departments.sla_mode })

        .from(schema.departments)

        .where(eq(schema.departments.id, department_id))

        .limit(1);



      if (!targetDept) {

        return res.status(404).json({ message: "Departamento destino n√£o encontrado" });

      }

      if (existingTicket.company_id && targetDept.company_id && existingTicket.company_id !== targetDept.company_id) {

        return res.status(403).json({ message: "Transfer√™ncia para outra empresa n√£o √© permitida" });

      }

      if (sessionCompanyId && targetDept.company_id && sessionCompanyId !== targetDept.company_id && userRole !== 'admin') {

        return res.status(403).json({ message: "Departamento n√£o pertence √† sua empresa" });

      }



      // Validar tipo de incidente pertence ao departamento e empresa

      const [targetType] = await db

        .select({ id: schema.incidentTypes.id, department_id: schema.incidentTypes.department_id, company_id: schema.incidentTypes.company_id })

        .from(schema.incidentTypes)

        .where(and(

          eq(schema.incidentTypes.id, incident_type_id),

          eq(schema.incidentTypes.department_id, department_id)

        ))

        .limit(1);

      if (!targetType) {

        return res.status(400).json({ message: "Tipo de chamado inv√°lido para o departamento informado" });

      }

      if (existingTicket.company_id && targetType.company_id && existingTicket.company_id !== targetType.company_id) {

        return res.status(403).json({ message: "Tipo de chamado pertence a outra empresa" });

      }



      // Validar categoria quando necess√°rio

      let effectiveCategoryId: number | null | undefined = category_id ?? null;

      if (targetDept.sla_mode === 'category') {

        // Se houver categorias ativas para o tipo, exigir sele√ß√£o

        const activeCats = await db

          .select({ id: schema.categories.id, company_id: schema.categories.company_id })

          .from(schema.categories)

          .where(and(

            eq(schema.categories.incident_type_id, incident_type_id),

            eq(schema.categories.is_active, true)

          ))

          .limit(1);



        const hasActiveCats = activeCats.length > 0;

        if (hasActiveCats && !effectiveCategoryId) {

          return res.status(400).json({ message: "Categoria √© obrigat√≥ria para este departamento" });

        }

        if (effectiveCategoryId) {

          const [cat] = await db

            .select({ id: schema.categories.id, incident_type_id: schema.categories.incident_type_id, company_id: schema.categories.company_id })

            .from(schema.categories)

            .where(eq(schema.categories.id, effectiveCategoryId))

            .limit(1);

          if (!cat || cat.incident_type_id !== incident_type_id) {

            return res.status(400).json({ message: "Categoria n√£o pertence ao tipo de chamado selecionado" });

          }

          if (existingTicket.company_id && cat.company_id && existingTicket.company_id !== cat.company_id) {

            return res.status(403).json({ message: "Categoria pertence a outra empresa" });

          }

        }

      } else {

        // Modos por tipo: permitir category_id opcional, mas se enviado valida

        if (effectiveCategoryId) {

          const [cat] = await db

            .select({ id: schema.categories.id, incident_type_id: schema.categories.incident_type_id, company_id: schema.categories.company_id })

            .from(schema.categories)

            .where(eq(schema.categories.id, effectiveCategoryId))

            .limit(1);

          if (!cat || cat.incident_type_id !== incident_type_id) {

            return res.status(400).json({ message: "Categoria n√£o pertence ao tipo de chamado selecionado" });

          }

          if (existingTicket.company_id && cat.company_id && existingTicket.company_id !== cat.company_id) {

            return res.status(403).json({ message: "Categoria pertence a outra empresa" });

          }

        }

      }



      // Preparar atualiza√ß√£o do ticket (manter prioridade/SLA e status intactos)

      const updateData: any = {

        department_id,

        incident_type_id,

        category_id: effectiveCategoryId ?? null,

        updated_at: new Date(),

      };



      // Se houver atendente vinculado, desvincular e registrar hist√≥rico de assignment

      const hadAssigned = existingTicket.assigned_to_id !== null && existingTicket.assigned_to_id !== undefined;

      if (hadAssigned) {

        updateData.assigned_to_id = null;

      }



      // Executar atualiza√ß√£o

      const updated = await storage.updateTicket(id, updateData);

      if (!updated) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // Registrar hist√≥rico da transfer√™ncia de departamento

      try {

        await db.insert(schema.ticketStatusHistory).values({

          ticket_id: id,

          change_type: 'department',

          old_department_id: existingTicket.department_id ?? null,

          new_department_id: department_id,

          old_incident_type_id: existingTicket.incident_type_id ?? null,

          new_incident_type_id: incident_type_id,

          old_category_id: existingTicket.category_id ?? null,

          new_category_id: effectiveCategoryId ?? null,

          changed_by_id: userId,

          created_at: new Date(),

        });

      } catch (histErr) {

        console.error('[Hist√≥rico] Erro ao registrar transfer√™ncia de departamento:', histErr);

      }



      // Registrar hist√≥rico de desvincula√ß√£o (assignment) se aplic√°vel

      if (hadAssigned) {

        try {

          await db.insert(schema.ticketStatusHistory).values({

            ticket_id: id,

            change_type: 'assignment',

            old_assigned_to_id: existingTicket.assigned_to_id,

            new_assigned_to_id: null,

            changed_by_id: userId,

            created_at: new Date(),

          });

        } catch (histErr) {

          console.error('[Hist√≥rico] Erro ao registrar desvincula√ß√£o de atendente:', histErr);

        }

      }



      return res.json(updated);

    } catch (error) {

      console.error('Erro ao transferir ticket:', error);

      return res.status(500).json({ message: 'Falha ao transferir ticket', error: String(error) });

    }

  });

  

  // Ticket creation and responses

  router.post("/tickets", authRequired, validateRequest(insertTicketSchema), async (req: Request, res: Response) => {

    try {

      // Validar os dados recebidos

      const ticketData = insertTicketSchema.parse(req.body);

      

      // ‚úÖ BUSCAR O CUSTOMER_ID E COMPANY_ID BASEADO NO EMAIL FORNECIDO

      let customerId: number | null = null;

      let companyId: number | null = null;

      

      if (ticketData.customer_email) {

        const existingCustomer = await storage.getCustomerByEmail(ticketData.customer_email);

        if (existingCustomer) {

          customerId = existingCustomer.id;

          companyId = existingCustomer.company_id; // ‚úÖ USAR O COMPANY_ID DO CLIENTE

        }

              }

        

      // üîé Valida√ß√£o: categoria obrigat√≥ria por modo do departamento

      try {

        if (ticketData.department_id && ticketData.incident_type_id) {

          const [dept] = await db

            .select({ sla_mode: schema.departments.sla_mode })

            .from(schema.departments)

            .where(eq(schema.departments.id, ticketData.department_id))

            .limit(1);

          const isCategoryMode = dept?.sla_mode === 'category';



          if (isCategoryMode) {

            // Verificar se existem categorias ativas para o tipo selecionado

            const activeCategories = await db

              .select({ id: schema.categories.id })

              .from(schema.categories)

              .where(and(

                eq(schema.categories.incident_type_id, ticketData.incident_type_id),

                eq(schema.categories.is_active, true)

              ))

              .limit(1);



            const hasActiveCategories = activeCategories.length > 0;

            if (hasActiveCategories && !ticketData.category_id) {

              return res.status(400).json({

                error: 'Categoria obrigat√≥ria',

                message: 'Este departamento usa SLA por categoria. Selecione uma categoria para o tipo de chamado informado.'

              });

            }

          }

        }

      } catch (validationError) {

        console.error('[Tickets] Erro ao validar requisito de categoria:', validationError);

        return res.status(500).json({ error: 'Erro ao validar categoria obrigat√≥ria' });

      }



      // ü§ñ AN√ÅLISE DE PRIORIDADE COM IA ANTES DE SALVAR O TICKET

        let finalPriority = ticketData.priority || null;

        

        // ‚úÖ CRIAR O TICKET PRIMEIRO (com prioridade padr√£o)

        const ticket = await storage.createTicket({

          ...ticketData,

          priority: finalPriority, // Prioridade inicial (ser√° atualizada pela IA se necess√°rio)

          customer_id: customerId || undefined,

          company_id: companyId || undefined // ‚úÖ USAR O COMPANY_ID DO CLIENTE

        });



        // üîç OBTER A PRIORIDADE REAL QUE FOI SALVA NO TICKET

        let originalPriority = ticket.priority || null;



        // ‚úÖ ADICIONAR PARTICIPANTES SE FORNECIDOS

        if (ticketData.participants && Array.isArray(ticketData.participants) && ticketData.participants.length > 0) {

          try {

            const userId = req.session?.userId;

            if (!userId) {

              throw new Error('Usu√°rio n√£o identificado para adicionar participantes');

            }

            

            // Adicionar cada participante individualmente

            for (const participantId of ticketData.participants) {

              try {

                await storage.addTicketParticipant(ticket.id, participantId, userId);

                

                // üî• FASE 4.2: Enviar notifica√ß√£o WebSocket de participante adicionado

                try {

                  await notificationService.notifyParticipantAdded(ticket.id, participantId, userId);

                } catch (notificationError) {

                  console.error('Erro ao enviar notifica√ß√£o WebSocket de participante adicionado:', notificationError);

                  // N√£o falhar a opera√ß√£o por erro de notifica√ß√£o

                }



                // üî• NOVO: Enviar notifica√ß√£o de participante adicionado

                try {

                  await emailNotificationService.notifyTicketParticipantAdded(ticket.id, participantId, userId);

                } catch (notificationError) {

                  console.error('Erro ao enviar notifica√ß√£o de participante adicionado:', notificationError);

                  // N√£o falhar a opera√ß√£o por erro de notifica√ß√£o

                }

              } catch (error) {

                console.error(`[Participantes] Erro ao adicionar participante ${participantId}:`, error);

                // Continuar com os pr√≥ximos participantes mesmo se um falhar

              }

            }

            console.log(`[Participantes] ${ticketData.participants.length} participante(s) adicionado(s) ao ticket ${ticket.id}`);

          } catch (participantError) {

            console.error('[Participantes] Erro ao adicionar participantes:', participantError);

            // Erro na adi√ß√£o de participantes n√£o impede a cria√ß√£o do ticket

          }

        }



        // ü§ñ AN√ÅLISE DE PRIORIDADE COM IA AP√ìS CRIAR O TICKET (salva hist√≥rico automaticamente)

        let aiAnalyzed = false;

        let finalPriorityId: number | null = null;

      

      if (companyId && ticketData.title && ticketData.description && ticket.department_id) {

        try {

          const aiService = new AiService();

          const aiResult = await aiService.analyzeTicketPriority(

            {

              title: ticketData.title, 

              description: ticketData.description, 

              companyId: companyId,

              ticketId: ticket.id

            },

            db

          );

          

          if (aiResult && !aiResult.usedFallback) {

            finalPriority = aiResult.priority;

            aiAnalyzed = true;

            

            console.log(`[AI] IA retornou prioridade: ${finalPriority}`);

            

            // üîç BUSCAR ID CORRETO DA PRIORIDADE NO BANCO

            const [priorityData] = await db

              .select({ id: schema.departmentPriorities.id, name: schema.departmentPriorities.name })

              .from(schema.departmentPriorities)

              .where(

                and(

                  eq(schema.departmentPriorities.company_id, companyId),

                  eq(schema.departmentPriorities.department_id, ticket.department_id),

                  eq(schema.departmentPriorities.name, finalPriority),

                  eq(schema.departmentPriorities.is_active, true)

                )

              )

              .limit(1);



            if (priorityData) {

              finalPriorityId = priorityData.id;

              finalPriority = priorityData.name; // Usar o nome exato do banco

              console.log(`[AI] Prioridade vinculada: ${finalPriority} (ID: ${finalPriorityId})`);

            } else {

              // Tentar busca case-insensitive

              const allPriorities = await db

                .select({ id: schema.departmentPriorities.id, name: schema.departmentPriorities.name })

                .from(schema.departmentPriorities)

                .where(

                  and(

                    eq(schema.departmentPriorities.company_id, companyId),

                    eq(schema.departmentPriorities.department_id, ticket.department_id),

                    eq(schema.departmentPriorities.is_active, true)

                  )

                );



              const foundPriority = allPriorities.find(p => 

                p.name.toLowerCase() === finalPriority.toLowerCase()

              );



              if (foundPriority) {

                finalPriorityId = foundPriority.id;

                finalPriority = foundPriority.name;

                console.log(`[AI] Prioridade vinculada (case-insensitive): ${finalPriority} (ID: ${finalPriorityId})`);

              } else {

                console.warn(`[AI] ATEN√á√ÉO: Prioridade "${finalPriority}" n√£o encontrada no banco! Ticket ficar√° sem prioridade espec√≠fica.`);

                finalPriority = 'Prioridade n√£o encontrada';

                finalPriorityId = null;

              }

            }

            

            // üîÑ ATUALIZAR PRIORIDADE DO TICKET SE A IA SUGERIU DIFERENTE

            // Comparar prioridades case-insensitive

            const normalizeForComparison = (priority: string | null) => {

              return priority ? priority.toLowerCase() : '';

            };

            

            const normalizedOriginal = normalizeForComparison(originalPriority);

            const normalizedFinal = normalizeForComparison(finalPriority);

            



            

            if (normalizedFinal !== normalizedOriginal && finalPriorityId && finalPriority) {

              console.log(`[AI] Atualizando ticket: ${originalPriority} ‚Üí ${finalPriority} (ID: ${finalPriorityId})`);

              

              await db

                .update(schema.tickets)

                .set({ 

                  priority: finalPriority as any // SALVAR EXATAMENTE como a IA retornou

                })

                .where(eq(schema.tickets.id, ticket.id));

                

              // ü§ñ REGISTRAR MUDAN√áA NO HIST√ìRICO DE STATUS

              // Buscar ou criar usu√°rio bot para IA

              let botUser = await db

                .select()

                .from(schema.users)

                .where(eq(schema.users.role, 'integration_bot'))

                .limit(1);



              let botUserId: number;

              

              if (botUser.length === 0) {

                // Criar usu√°rio bot se n√£o existir

                const [createdBot] = await db

                  .insert(schema.users)

                  .values({

                    username: 'ai_robot',

                    email: 'ai@system.internal',

                    name: 'Robo IA',

                    role: 'integration_bot',

                    password: 'AiBot123!@#', // Senha que atende aos crit√©rios de seguran√ßa

                    active: true,

                    company_id: null, // Bot global

                    created_at: new Date(),

                    updated_at: new Date()

                  })

                  .returning();

                

                botUserId = createdBot.id;

              } else {

                botUserId = botUser[0].id;

              }



              // Registrar mudan√ßa de prioridade no hist√≥rico

              await db

                .insert(schema.ticketStatusHistory)

                .values({

                  ticket_id: ticket.id,

                  change_type: 'priority',

                  old_priority: normalizedOriginal as any,

                  new_priority: normalizedFinal as any,

                  changed_by_id: botUserId,

                  created_at: new Date()

                });

                

              // Atualizar prioridade final para resposta

              finalPriority = normalizedFinal;

            } else if (normalizedFinal === normalizedOriginal && finalPriority) {

              console.log(`[AI] Prioridade n√£o alterada: ${originalPriority} (mesma prioridade sugerida pela IA)`);

            } else if (!finalPriorityId) {

              console.warn(`[AI] Ticket ${ticket.id} n√£o ter√° prioridade vinculada pois '${finalPriority}' n√£o existe no banco`);

            }

          }

        } catch (aiError) {

          console.error('[AI] Erro na an√°lise de prioridade:', aiError);

          // Falha na IA n√£o impede a cria√ß√£o do ticket

        }

      }



      logger.info('Ticket criado com sucesso', {

        ticketId: ticket.id,

        customerId,

        companyId,

        email: ticketData.customer_email,

        priority: finalPriority,

        aiAnalyzed,

        operation: 'create_ticket'

      });



      // Responder com o ticket criado

      res.status(201).json(ticket);

      

      // Enviar notifica√ß√£o via WebSocket (excluindo participantes que ser√£o notificados separadamente)

      const participantIds = ticketData.participants && Array.isArray(ticketData.participants) ? ticketData.participants : [];

      // @ts-ignore

      notificationService.sendNotificationToAll({

        type: 'new_ticket',

        title: 'Novo Ticket Criado',

        message: `Novo ticket ${ticket.ticket_id}: ${ticketData.title}`,

        ticketId: ticket.id,

        ticketCode: ticket.ticket_id,

        priority: finalPriority,

        timestamp: new Date()

      }, participantIds); // Excluir participantes da notifica√ß√£o geral

      

      // üìß ENVIAR EMAIL DE CONFIRMA√á√ÉO PARA O CLIENTE

      try {

        if (customerId && ticketData.customer_email) {

          // Buscar dados completos do cliente

          const customer = await storage.getCustomer(customerId);

          

          if (customer) {

            // üî• OTIMIZA√á√ÉO CR√çTICA: Envio de e-mail fire-and-forget (n√£o bloqueia a resposta)

            emailNotificationService.sendEmailNotification(

              'new_ticket', 

              customer.email, 

              {

                ticket: {

                  id: ticket.id,

                  ticket_id: ticket.ticket_id,

                  title: ticket.title,

                  description: ticket.description,

                  priority: finalPriority,

                  status: ticket.status,

                  created_at: ticket.created_at

                },

                customer: {

                  name: customer.name,

                  email: customer.email,

                  company: customer.company

                },

                system: {

                  base_url: process.env.BASE_URL || 'http://localhost:5000',

                  company_name: 'Sistema de Tickets',

                  support_email: 'suporte@sistema.com'

                }

              },

              companyId || undefined

            ).catch((emailError) => {

              console.error('[Email] Erro ao enviar confirma√ß√£o para o cliente:', emailError);

            });

            



          }

        }

      } catch (emailError) {

        console.error('[Email] Erro ao enviar confirma√ß√£o para o cliente:', emailError);

      }

      

      // üìß ENVIAR EMAIL PARA ADMINS E SUPPORT (fire-and-forget)

      const emailStartTime = Date.now();

      console.log(`üìß [EMAIL BACKGROUND] ========================================`);

      console.log(`üìß [EMAIL BACKGROUND] üé´ INICIANDO - Novo Ticket`);

      console.log(`üìß [EMAIL BACKGROUND] Ticket: #${ticket.ticket_id} (ID: ${ticket.id})`);

      console.log(`üìß [EMAIL BACKGROUND] Company ID: ${ticket.company_id}`);

      console.log(`üìß [EMAIL BACKGROUND] Customer Email: ${ticket.customer_email}`);

      console.log(`üìß [EMAIL BACKGROUND] Timestamp: ${new Date().toLocaleString('pt-BR')}`);

      console.log(`üìß [EMAIL BACKGROUND] ========================================`);

      

      // Fire-and-forget: n√£o aguarda o envio dos e-mails

      emailNotificationService.notifyNewTicket(ticket.id).then(() => {

        const emailDuration = Date.now() - emailStartTime;

        console.log(`üìß [EMAIL BACKGROUND] ========================================`);

        console.log(`üìß [EMAIL BACKGROUND] ‚úÖ CONCLU√çDO - Novo Ticket em ${emailDuration}ms`);

        console.log(`üìß [EMAIL BACKGROUND] Ticket: #${ticket.ticket_id} - Todos os e-mails processados`);

        console.log(`üìß [EMAIL BACKGROUND] ========================================`);

      }).catch((emailError) => {

        const emailDuration = Date.now() - emailStartTime;

        console.error(`üìß [EMAIL BACKGROUND] ========================================`);

        console.error(`üìß [EMAIL BACKGROUND] ‚ùå ERRO - Novo Ticket ap√≥s ${emailDuration}ms`);

        console.error(`üìß [EMAIL BACKGROUND] Ticket: #${ticket.ticket_id} - Erro:`, emailError.message);

        console.error(`üìß [EMAIL BACKGROUND] Stack:`, emailError.stack);

        console.error(`üìß [EMAIL BACKGROUND] ========================================`);

      });

      

    } catch (error) {

      if (error instanceof z.ZodError) {

        return res.status(400).json({ 

          message: "Dados inv√°lidos", 

          errors: error.errors 

        });

      }

      

      console.error(error);

      res.status(500).json({ message: "Erro ao criar ticket" });

    }

  });

  

    // Rota para criar respostas de tickets com an√°lise de IA

  router.post("/ticket-replies", authRequired, validateRequest(insertTicketReplySchema), async (req: Request, res: Response) => {

    try {

      // Importar a fun√ß√£o correta que cont√©m a an√°lise de IA

      const { POST: ticketRepliesHandler } = await import('./api/ticket-replies');

      return await ticketRepliesHandler(req, res);

    } catch (error) {

      console.error('Erro ao processar resposta de ticket:', error);

      return res.status(500).json({ error: "Erro interno do servidor" });

    }

  });

  

  // Customer endpoints with pagination

  router.get("/customers", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50; // 50 por p√°gina por padr√£o

      const search = (req.query.search as string) || '';

      const includeInactive = req.query.includeInactive === 'true';

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session?.companyId;

      

      // Buscar todos os clientes

      const allCustomers = await storage.getCustomers();

      

      // Aplicar filtros de empresa

      let customers = allCustomers;

      

      if (userRole === 'admin') {

        // Admin pode filtrar por empresa espec√≠fica ou ver todas

        if (filterCompanyId) {

          customers = allCustomers.filter(customer => customer.company_id === filterCompanyId);

        }

        // Se filterCompanyId for null, mostra todos

      } else {

        // Usu√°rios n√£o-admin sempre veem apenas sua empresa

        customers = allCustomers.filter(customer => customer.company_id === sessionCompanyId);

      }

      

      // Enriquecer clientes com nome da empresa e status do usu√°rio, sem sobrescrever o campo company original

      const enrichedCustomers = customers.map(customer => ({

        ...customer,

        company_display: (customer as any).company_name || customer.company || '-', // campo auxiliar para exibi√ß√£o

        active: typeof (customer as any).user_active === 'boolean' ? (customer as any).user_active : true

      }));

      

      // Filtrar os clientes inativos se necess√°rio

      let filteredCustomers = includeInactive 

        ? enrichedCustomers 

        : enrichedCustomers.filter(customer => customer.active);

      

      // Aplicar filtro de busca se fornecido

      if (search) {

        const searchLower = search.toLowerCase();

        filteredCustomers = filteredCustomers.filter(customer => 

          customer.name.toLowerCase().includes(searchLower) ||

          customer.email.toLowerCase().includes(searchLower) ||

          (customer.company_display && customer.company_display.toLowerCase().includes(searchLower))

        );

      }

      

      // Ordena√ß√£o j√° √© feita no banco de dados via DatabaseStorage.getCustomers()

      

      // Calcular pagina√ß√£o

      const total = filteredCustomers.length;

      const totalPages = Math.ceil(total / limit);

      const offset = (page - 1) * limit;

      const paginatedCustomers = filteredCustomers.slice(offset, offset + limit);

      

      res.json({

        data: paginatedCustomers,

        pagination: {

          page,

          limit,

          total,

          totalPages,

          hasNext: page < totalPages,

          hasPrev: page > 1

        }

      });

    } catch (error) {

      console.error('Erro ao buscar clientes:', error);

      res.status(500).json({ message: "Falha ao buscar clientes" });

    }

  });



  // Endpoint espec√≠fico para buscar clientes no formul√°rio de tickets

  router.get("/customers/search", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const search = (req.query.q as string) || '';

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;



      // Buscar todos os clientes

      const allCustomers = await storage.getCustomers();

      

      // Filtrar por empresa se necess√°rio

      let customers = allCustomers;

      

      if (userRole === 'admin') {

        // Admin pode especificar empresa ou ver TODOS se n√£o especificar

        const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

        if (filterCompanyId) {

          customers = allCustomers.filter(customer => customer.company_id === filterCompanyId);

        }

        // Admin sem filtro de empresa = ver todos

      } else {

        // Usu√°rios n√£o-admin veem apenas sua empresa

        if (sessionCompanyId) {

          customers = allCustomers.filter(customer => customer.company_id === sessionCompanyId);

        } else {

          customers = [];

        }

      }



      // Filtrar apenas clientes ativos

      customers = customers.filter(customer => (customer as any).active);



      // Aplicar busca se fornecida

      if (search) {

        const searchLower = search.toLowerCase();

        customers = customers.filter(customer =>

          customer.name.toLowerCase().includes(searchLower) ||

          customer.email.toLowerCase().includes(searchLower) ||

          (customer.company && customer.company.toLowerCase().includes(searchLower))

        );

        // Limitar apenas quando h√° busca espec√≠fica

        customers = customers.slice(0, 50);

      }



      // Se n√£o h√° busca, retornar todos os clientes (filtro ser√° feito no frontend)

      const limitedCustomers = customers;



      // Enriquecer dados dos clientes

      const enrichedCustomers = await Promise.all(

        limitedCustomers.map(async (customer) => {

          let userData = null;

          if (customer.user_id) {

            try {

              userData = await storage.getUser(customer.user_id);

            } catch (userError) {

              // Silenciar warning para produ√ß√£o

            }

          }



          return {

            ...customer,

            active: userData ? userData.active : true,

            user: userData ? {

              id: userData.id,

              username: userData.username,

              role: userData.role,

              active: userData.active

            } : null

          };

        })

      );



      res.json(enrichedCustomers);

    } catch (error) {

      console.error('Erro ao buscar clientes:', error);

      res.status(500).json({ message: "Falha ao buscar clientes" });

    }

  });

  

  router.post("/customers", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const { email, name, company_id, linkExistingUser } = req.body;

      

      // Garantir que linkExistingUser seja boolean

      const shouldLinkUser = Boolean(linkExistingUser);

      console.log('Cliente - linkExistingUser recebido:', linkExistingUser, 'convertido para:', shouldLinkUser);

      

      // Verificar se j√° existe cliente com este email

      const existingCustomer = await storage.getCustomerByEmail(email);

      if (existingCustomer) {

        return res.status(400).json({ message: "Email j√° cadastrado para outro cliente" });

      }

      

      const existingUser = await storage.getUserByEmail(email);

      

      if (existingUser && !shouldLinkUser) {

        // Se o usu√°rio existe mas n√£o foi solicitado para vincular, retornar erro com op√ß√£o

        console.log(`Cliente - Usu√°rio com email '${email}' j√° existe. Sugerindo vincula√ß√£o.`);

        

        const responseData = { 

          message: "Usu√°rio j√° existe",

          suggestion: "link_existing",

          existingUser: {

            id: existingUser.id,

            name: existingUser.name,

            email: existingUser.email,

            username: existingUser.username

          }

        };

        

        console.log('Cliente - Resposta 409 sendo enviada:', JSON.stringify(responseData, null, 2));

        return res.status(409).json(responseData);

      }

      

      if (existingUser && shouldLinkUser) {

        console.log(`Cliente - Vinculando usu√°rio existente (ID: ${existingUser.id}, role: ${existingUser.role}) como cliente`);

        

        // Atualizar o role do usu√°rio para 'customer' ao vincular como cliente

        const updatedUser = await storage.updateUser(existingUser.id, { 

          role: 'customer'

        });

        if (updatedUser) {

          existingUser.role = 'customer';

          console.log(`Cliente - Role do usu√°rio atualizado para 'customer'`);

        }

      } else if (!existingUser && shouldLinkUser) {

        // Se solicitou vincular mas o usu√°rio n√£o existe, retornar erro

        return res.status(404).json({ message: "Usu√°rio n√£o encontrado para vincula√ß√£o" });

      }

      

      // Determinar company_id efetivo

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session?.companyId;

      

      let effectiveCompanyId: number | null = null;

      

      if (userRole === 'admin') {

        // Admin pode especificar qualquer company_id

        effectiveCompanyId = company_id || null;

      } else {

        // Usu√°rios n√£o-admin usam sua pr√≥pria empresa

        effectiveCompanyId = sessionCompanyId || null;

        if (company_id && company_id !== sessionCompanyId) {

          console.warn(`Usu√°rio ${userRole} tentou especificar company_id ${company_id}, mas ser√° usado o da sess√£o: ${sessionCompanyId}`);

        }

      }

      

      let user;

      let tempPassword = '';

      

      if (!existingUser) {

        // Usar o e-mail completo como nome de usu√°rio

        const username = email;

        

        // Gerar senha tempor√°ria segura

        const { generateSecurePassword, hashPassword } = await import('./utils/password');

        tempPassword = generateSecurePassword();

        

        // Criptografar senha

        const hashedPassword = await hashPassword(tempPassword);

        

        // Criar usu√°rio primeiro com company_id

        user = await storage.createUser({

          username,

          email,

          password: hashedPassword,

          name,

          role: 'customer' as typeof schema.userRoleEnum.enumValues[number],

          company_id: effectiveCompanyId,

          must_change_password: req.body.must_change_password || false,

        });

      } else {

        // Usar usu√°rio existente

        user = existingUser;

        console.log(`Cliente - Usando usu√°rio existente ID: ${user.id}`);

        

        // Atualizar company_id se necess√°rio e se for admin

        if (userRole === 'admin' && effectiveCompanyId !== user.company_id) {

          console.log(`Cliente - Atualizando company_id do usu√°rio de ${user.company_id} para ${effectiveCompanyId}`);

          const updatedUser = await storage.updateUser(user.id, { company_id: effectiveCompanyId });

          if (updatedUser) {

            user = updatedUser;

          }

        }

      }

      

      // Criar cliente associado ao usu√°rio com company_id

      const customer = await storage.createCustomer({

        ...req.body,

        user_id: user.id,

        company_id: effectiveCompanyId,

      });

      

      // Notificar sobre novo cliente registrado

      try {

        await emailNotificationService.notifyNewCustomerRegistered(customer.id);

      } catch (notificationError) {

        console.error('Erro ao enviar notifica√ß√£o de novo cliente:', notificationError);

        // N√£o falhar a cria√ß√£o do cliente por causa da notifica√ß√£o

      }

      

      // Retornar o cliente com informa√ß√µes de acesso (apenas para novos usu√°rios)

      if (!existingUser) {

        res.status(201).json({

          ...customer,

          accessInfo: {

            username: user.username,

            temporaryPassword: tempPassword,

            message: "Uma senha tempor√°ria foi gerada. Por favor, informe ao cliente para alter√°-la no primeiro acesso."

          }

        });

      } else {

        // Para usu√°rios vinculados, n√£o retornar senha

        res.status(201).json({

          ...customer,

          message: "Cliente vinculado com sucesso ao usu√°rio existente."

        });

      }

    } catch (error) {

      console.error('Erro ao criar cliente:', error);

      res.status(500).json({ message: "Falha ao criar cliente", error: String(error) });

    }

  });

  

  router.patch("/customers/:id", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de cliente inv√°lido" });

      }



      const { password, ...customerData } = req.body;



      // Se uma senha foi fornecida, criptograf√°-la antes de salvar

      if (password) {

        // Verificar se o cliente tem um usu√°rio associado

        const customer = await storage.getCustomer(id);

        if (!customer) {

          return res.status(404).json({ message: "Cliente n√£o encontrado" });

        }

        

        if (customer.user_id) {

          // Criptografar a nova senha

          const { hashPassword } = await import('./utils/password');

          const hashedPassword = await hashPassword(password);

          

          // Atualizar a senha do usu√°rio associado

          await storage.updateUser(customer.user_id, { 

            password: hashedPassword,

            must_change_password: req.body.must_change_password || false

          });



          // Encerrar sess√µes do usu√°rio ap√≥s alterar a senha via cliente

          try {

            await db.execute(sql`

              DELETE FROM user_sessions

              WHERE (sess->>'userId')::int = ${customer.user_id}

            `);

          } catch (sessionError) {

            console.error('Erro ao encerrar sess√µes do usu√°rio (cliente) ap√≥s alterar senha:', sessionError);

          }

        }

      }



      const customer = await storage.updateCustomer(id, customerData);

      if (!customer) {

        return res.status(404).json({ message: "Cliente n√£o encontrado" });

      }



      res.json(customer);

    } catch (error) {

      console.error('Erro ao atualizar cliente:', error);

      res.status(500).json({ message: "Falha ao atualizar cliente", error: String(error) });

    }

  });

  

  router.delete("/customers/:id", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de cliente inv√°lido" });

      }



      // Buscar cliente para verificar se h√° um usu√°rio associado

      const customer = await storage.getCustomer(id);

      if (!customer) {

        return res.status(404).json({ message: "Cliente n√£o encontrado" });

      }

      

      // Armazenar o user_id para inativa√ß√£o/ativa√ß√£o posterior

      const userId = customer.user_id;



      if (userId) {

        // Buscar o usu√°rio para verificar seu status atual

        const user = await storage.getUser(userId);

        

        if (!user) {

          return res.status(404).json({ message: "Usu√°rio do cliente n√£o encontrado" });

        }

        

        // Se o usu√°rio estiver ativo, inativamos; se estiver inativo, ativamos

        if (user.active) {

          // Inativar o usu√°rio

          const inactivatedUser = await storage.inactivateUser(userId);

          if (!inactivatedUser) {

            return res.status(404).json({ message: "Usu√°rio do cliente n√£o encontrado" });

          }

          res.json({ 

            success: true, 

            message: "Cliente inativado com sucesso",

            inactive: true,

            active: false

          });

        } else {

          // Ativar o usu√°rio

          const activatedUser = await storage.activateUser(userId);

          if (!activatedUser) {

            return res.status(404).json({ message: "Usu√°rio do cliente n√£o encontrado" });

          }

          res.json({ 

            success: true, 

            message: "Cliente ativado com sucesso",

            inactive: false,

            active: true

          });

        }

      } else {

        // Se n√£o h√° usu√°rio associado, remover o cliente

        const success = await storage.deleteCustomer(id);

        if (!success) {

          return res.status(404).json({ message: "Cliente n√£o encontrado" });

        }

        res.json({ success: true, message: "Cliente removido com sucesso" });

      }

    } catch (error) {

      console.error('Erro ao ativar/inativar cliente:', error);

      res.status(500).json({ message: "Falha ao ativar/inativar cliente", error: String(error) });

    }

  });



  // Bulk import endpoint for customers - processar na mem√≥ria

  const csvUpload = multer({ 

    storage: multer.memoryStorage(), // Processar na mem√≥ria

    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit

    fileFilter: (req, file, cb) => {

      const allowedTypes = ['text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'];

      if (allowedTypes.includes(file.mimetype) || file.originalname.endsWith('.csv')) {

        cb(null, true);

      } else {

        cb(new Error('Tipo de arquivo n√£o suportado. Use CSV ou Excel.'));

      }

    }

  });



  router.post("/customers/bulk-import", authRequired, adminRequired, csvUpload.single('file'), async (req: Request, res: Response) => {

    try {

      if (!req.file) {

        return res.status(400).json({ message: "Nenhum arquivo foi enviado" });

      }



      const companyId = parseInt(req.body.company_id);

      if (!companyId || isNaN(companyId)) {

        return res.status(400).json({ message: "ID da empresa √© obrigat√≥rio" });

      }



      // Processar arquivo da mem√≥ria

      const fileContent = req.file.buffer.toString('utf-8');

      

      // Parse CSV content

      const lines = fileContent.split('\n').filter(line => line.trim());

      if (lines.length < 2) {

        return res.status(400).json({ message: "Arquivo deve conter pelo menos uma linha de dados al√©m do cabe√ßalho" });

      }



      const headers = lines[0].split(';').map(h => h.trim());

      const dataLines = lines.slice(1);

      

      // Validate required headers

      const requiredHeaders = ['email', 'name'];

      const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));

      if (missingHeaders.length > 0) {

        return res.status(400).json({ 

          message: `Cabe√ßalhos obrigat√≥rios n√£o encontrados: ${missingHeaders.join(', ')}` 

        });

      }



      const results = {

        success: 0,

        errors: [] as Array<{ row: number; email: string; error: string }>,

        skipped: 0, // Usu√°rios que j√° existem

        total: dataLines.length

      };



      const { generateSecurePassword, hashPassword } = await import('./utils/password');



      // Process each line

      for (let i = 0; i < dataLines.length; i++) {

        const line = dataLines[i];

        const values = line.split(';').map(v => v.trim());

        

        try {

          // Create data object from headers and values

          const userData: any = {};

          headers.forEach((header, index) => {

            userData[header] = values[index] || '';

          });



          // Validate required fields

          if (!userData.email || !userData.name) {

            results.errors.push({

              row: i + 2, // +2 porque come√ßamos na linha 2 (header = linha 1)

              email: userData.email || 'N/A',

              error: 'Email e nome s√£o obrigat√≥rios'

            });

            continue;

          }



          // Check if email already exists - SE EXISTIR, IGNORA (n√£o √© erro)

          const existingCustomer = await storage.getCustomerByEmail(userData.email);

          if (existingCustomer) {

            results.skipped++;

            continue; // Simplesmente ignora, n√£o conta como erro

          }



          const existingUser = await storage.getUserByEmail(userData.email);

          if (existingUser) {

            results.skipped++;

            continue; // Simplesmente ignora, n√£o conta como erro

          }



          // Use email as username if not provided

          const username = userData.username || userData.email;

          

          // Use provided password or generate one

          const password = userData.password || generateSecurePassword();

          const hashedPassword = await hashPassword(password);



          // Create user

          const user = await storage.createUser({

            username,

            email: userData.email,

            password: hashedPassword,

            name: userData.name,

            role: 'customer' as typeof schema.userRoleEnum.enumValues[number],

            company_id: companyId,

            active: userData.active !== 'false', // Default to true unless explicitly false

            ad_user: userData.ad_user === 'true', // Default to false unless explicitly true

          });



          // Create customer

          await storage.createCustomer({

            name: userData.name,

            email: userData.email,

            phone: userData.phone || '',

            company: '', // Will be filled by company relationship

            user_id: user.id,

            company_id: companyId,

          });



          results.success++;

        } catch (error) {

          results.errors.push({

            row: i + 2,

            email: values[headers.indexOf('email')] || 'N/A',

            error: error instanceof Error ? error.message : 'Erro desconhecido'

          });

        }

      }



      res.json(results);

    } catch (error) {

      console.error('Erro na importa√ß√£o em lote:', error);

      res.status(500).json({ message: "Erro interno do servidor", error: String(error) });

    }

  });



  // Official endpoints with pagination

  router.get("/officials", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50; // 50 por p√°gina para atendentes

      const search = (req.query.search as string) || '';

      const includeInactive = req.query.includeInactive === 'true';

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const filterDepartmentId = req.query.department_id ? parseInt(req.query.department_id as string) : null;

      

      const userRole = req.session?.userRole as string;

      const userId = req.session?.userId;

      const sessionCompanyId = req.session?.companyId;

      

      const allOfficials = await storage.getOfficials();

      

      let officials = allOfficials;

      

      // APLICAR FILTROS DE EMPRESA

      if (userRole === 'admin') {

        // ADMIN: pode filtrar por empresa espec√≠fica ou ver todos

        if (filterCompanyId) {

          officials = allOfficials.filter(official => official.company_id === filterCompanyId);

        }

        // Se filterCompanyId for null, mostra todos

        officials = includeInactive ? officials : officials.filter(official => official.is_active);

        

      } else if (userRole === 'company_admin') {

        // COMPANY_ADMIN: V√ä TODOS OS ATENDENTES DA SUA EMPRESA (ignora filterCompanyId)

        officials = allOfficials.filter(official => {

          const sameCompany = official.company_id === sessionCompanyId;

          const isActive = includeInactive || official.is_active;

          return sameCompany && isActive;

        });

      } else if (userRole === 'manager') {

        // MANAGER: V√ä APENAS ATENDENTES DOS SEUS DEPARTAMENTOS

        if (!sessionCompanyId || !userId) {

          officials = [];

        } else {

          // Buscar o official do manager

          const currentOfficial = allOfficials.find(o => o.user_id === userId);

          

          if (!currentOfficial) {

            officials = [];

          } else {

            // Buscar departamentos do manager

            const managerDepartments = await db

              .select({ department_id: schema.officialDepartments.department_id })

              .from(schema.officialDepartments)

              .where(eq(schema.officialDepartments.official_id, currentOfficial.id));

            

            if (managerDepartments.length === 0) {

              officials = [];

            } else {

              const departmentIds = managerDepartments.map(d => d.department_id).filter(id => id !== null);

              

              // Buscar todos os atendentes desses departamentos

              const departmentOfficials = await db

                .select({ official_id: schema.officialDepartments.official_id })

                .from(schema.officialDepartments)

                .where(inArray(schema.officialDepartments.department_id, departmentIds));

              

              const allowedOfficialIds = departmentOfficials.map(o => o.official_id);

              

              // Filtrar atendentes pelos departamentos permitidos

              officials = allOfficials.filter(official => {

                const sameCompany = official.company_id === sessionCompanyId;

                const isActive = includeInactive || official.is_active;

                const isAllowed = allowedOfficialIds.includes(official.id);

                

                return sameCompany && isActive && isAllowed;

              });

            }

          }

        }

      } else if (userRole === 'supervisor') {

        // SUPERVISOR: se enxerga + subordinados (quando tiver)

        if (!sessionCompanyId || !userId) {

          officials = [];

        } else {

          const currentOfficial = allOfficials.find(o => o.user_id === userId);

          

          if (!currentOfficial) {

            officials = [];

          } else {

            // Incluir o pr√≥prio supervisor

            let allowedOfficialIds = [currentOfficial.id];

            

            // Incluir subordinados diretos

            const subordinates = allOfficials.filter(o => o.supervisor_id === currentOfficial.id);

            allowedOfficialIds.push(...subordinates.map(s => s.id));

            

            // Filtrar pelos IDs permitidos

            officials = allOfficials.filter(official => {

              const sameCompany = official.company_id === sessionCompanyId;

              const isActive = includeInactive || official.is_active;

              const isAllowed = allowedOfficialIds.includes(official.id);

              

              return sameCompany && isActive && isAllowed;

            });

          }

        }

      } else if (userRole === 'support') {

        // SUPPORT: S√ì SE ENXERGA

        if (!sessionCompanyId || !userId) {

          officials = [];

        } else {

          const currentOfficial = allOfficials.find(o => o.user_id === userId);

          

          if (currentOfficial) {

            const isActive = includeInactive || currentOfficial.is_active;

            officials = isActive ? [currentOfficial] : [];

          } else {

            officials = [];

          }

        }

      } else {

        // TODAS AS OUTRAS ROLES: N√ÉO VEEM O DROPDOWN (ignora filterCompanyId)

        officials = [];

      }

      

      // APLICAR FILTRO DE DEPARTAMENTO SE FORNECIDO

      if (filterDepartmentId) {

        // Buscar todos os atendentes que pertencem ao departamento especificado

        const officialIds = await db.select({ official_id: schema.officialDepartments.official_id })

          .from(schema.officialDepartments)

          .where(eq(schema.officialDepartments.department_id, filterDepartmentId));

        

        const allowedOfficialIds = officialIds.map(o => o.official_id);

        

        // Filtrar apenas os atendentes que pertencem ao departamento

        officials = officials.filter(official => allowedOfficialIds.includes(official.id));

      }

      

      // Aplicar filtro de busca se fornecido

      if (search) {

        const searchLower = search.toLowerCase();

        officials = officials.filter(official => 

          official.name.toLowerCase().includes(searchLower) ||

          official.email.toLowerCase().includes(searchLower)

        );

      }

      

      // Calcular pagina√ß√£o

      const total = officials.length;

      const totalPages = Math.ceil(total / limit);

      const offset = (page - 1) * limit;

      const paginatedOfficials = officials.slice(offset, offset + limit);

      

      res.json({

        data: paginatedOfficials,

        pagination: {

          page,

          limit,

          total,

          totalPages,

          hasNext: page < totalPages,

          hasPrev: page > 1

        }

      });

    } catch (error) {

      console.error('Erro ao buscar atendentes:', error);

      res.status(500).json({ message: "Falha ao buscar atendentes", error: String(error) });

    }

  });

  

  router.post("/officials", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      // console.log(`Iniciando cria√ß√£o de atendente com dados:`, JSON.stringify(req.body, null, 2)); // REMOVIDO - dados sens√≠veis

      const { departments, company_id, ...officialData } = req.body;

      

      // Verificar se h√° departamentos selecionados

      if (!departments || !Array.isArray(departments) || departments.length === 0) {

        return res.status(400).json({ 

          message: "Pelo menos um departamento deve ser selecionado para o atendente" 

        });

      }

      

      // Verificar se o usu√°rio existe

      if (officialData.userId) {

        const user = await storage.getUser(officialData.userId);

        if (!user) {

          console.log(`ERRO: Usu√°rio com ID ${officialData.userId} n√£o encontrado`);

          return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });

        }

        console.log(`Usu√°rio encontrado: ${user.name} (${user.email})`);

      }

      

      // Para compatibilidade com a tabela f√≠sica, usar o primeiro departamento como principal

      let departmentValue = departments[0];

      if (typeof departmentValue === 'object' && departmentValue !== null && 'department' in departmentValue) {

        departmentValue = departmentValue.department;

      }

      

      // Determinar company_id efetivo

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session?.companyId;

      

      let effectiveCompanyId: number | null = null;

      

      if (userRole === 'admin') {

        // Admin pode especificar qualquer company_id

        effectiveCompanyId = company_id || null;

      } else {

        // Usu√°rios n√£o-admin usam sua pr√≥pria empresa

        effectiveCompanyId = sessionCompanyId || null;

        if (company_id && company_id !== sessionCompanyId) {

          console.warn(`Usu√°rio ${userRole} tentou especificar company_id ${company_id}, mas ser√° usado o da sess√£o: ${sessionCompanyId}`);

        }

      }

      

      // Criar atendente primeiro

      const dataWithDepartment = {

        ...officialData,

        department: departmentValue, // Adicionar campo department para compatibilidade

        company_id: effectiveCompanyId, // Aplicar company_id para todos os usu√°rios n√£o-admin

      };

      

      console.log(`Criando atendente com dados:`, JSON.stringify(dataWithDepartment, null, 2));

      const official = await storage.createOfficial(dataWithDepartment);

      console.log(`Atendente criado com sucesso: ID=${official.id}`);

      

      // Se foram enviados departamentos, adicionar os departamentos do atendente

      if (departments && Array.isArray(departments) && departments.length > 0) {

        console.log(`Adicionando ${departments.length} departamentos ao atendente`);

        // Adicionar departamentos

        for (const dep of departments) {

          // Resolver por ID (preferencial), depois por nome dentro da mesma empresa

          let resolvedDeptId: number | null = null;

          let depNameForLog = String(dep);

          try {

            if (typeof dep === 'object' && dep !== null) {

              if ('id' in dep && dep.id) {

                resolvedDeptId = Number(dep.id);

              } else if ('department_id' in dep && dep.department_id) {

                resolvedDeptId = Number(dep.department_id);

              } else if ('department' in dep && dep.department) {

                depNameForLog = String(dep.department);

              }

            } else if (typeof dep === 'string') {

              // pode ser um ID em string

              const asNum = Number(dep);

              if (!Number.isNaN(asNum)) {

                resolvedDeptId = asNum;

              } else {

                depNameForLog = dep;

              }

            } else if (typeof dep === 'number') {

              resolvedDeptId = dep;

            }



            let deptRecord: { id: number } | undefined;

            if (resolvedDeptId !== null) {

              const [rec] = await db

                .select({ id: schema.departments.id })

                .from(schema.departments)

                .where(

                  and(

                    eq(schema.departments.id, resolvedDeptId),

                    dataWithDepartment.company_id ? eq(schema.departments.company_id, dataWithDepartment.company_id) : isNull(schema.departments.company_id)

                  )

                );

              deptRecord = rec;

            }



            if (!deptRecord && depNameForLog) {

              const [recByName] = await db

                .select({ id: schema.departments.id })

                .from(schema.departments)

                .where(

                  and(

                    ilike(schema.departments.name, depNameForLog),

                    dataWithDepartment.company_id ? eq(schema.departments.company_id, dataWithDepartment.company_id) : isNull(schema.departments.company_id)

                  )

                );

              deptRecord = recByName;

            }



            if (deptRecord) {

              await storage.addOfficialDepartment({

                official_id: official.id,

                department_id: deptRecord.id

              });

            } else {

              console.warn(`Departamento n√£o encontrado (empresa=${dataWithDepartment.company_id}): entrada='${JSON.stringify(dep)}'`);

            }

          } catch (e) {

            console.error('Erro ao resolver departamento:', e);

          }

        }

        

        // Buscar os departamentos reais do banco para retornar nomes corretos

        const officialDepts = await storage.getOfficialDepartments(official.id);

        const departmentIds = officialDepts.map(od => od.department_id);

        let departmentNames: string[] = [];

        if (departmentIds.length > 0) {

          const depts = await db

            .select({ id: schema.departments.id, name: schema.departments.name })

            .from(schema.departments)

            .where(inArray(schema.departments.id, departmentIds));

          const deptMap = new Map(depts.map(d => [d.id, d.name]));

          departmentNames = departmentIds.map(id => deptMap.get(id) || `Dept-${id}`);

        }

        

        // Anexar nomes de departamentos ao resultado

        official.departments = departmentNames;

      }

      

      console.log(`Retornando atendente criado: ID=${official.id}`);

      res.status(201).json(official);

    } catch (error) {

      console.error('Erro ao criar atendente:', error);

      

      // Se o erro ocorreu depois da cria√ß√£o do usu√°rio, verificamos se temos um userId

      // para dar uma resposta mais √∫til

      if (req.body.userId) {

        console.log(`ERRO: Falha ao criar atendente para usu√°rio ${req.body.userId}. `+

                   `Considere excluir o usu√°rio para evitar inconsist√™ncias.`);

      }

      

      res.status(500).json({ 

        message: "Falha ao criar atendente", 

        error: String(error),

        userId: req.body.userId || null, // Retornar o ID do usu√°rio para poss√≠vel limpeza

        suggestion: "O usu√°rio pode ter sido criado mas o atendente n√£o. Considere excluir o usu√°rio e tentar novamente."

      });

    }

  });

  

  router.patch("/officials/:id", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de atendente inv√°lido" });

      }



      const { departments, password, department, user, company_id, ...officialData } = req.body;

      

      // Verificar se temos pelo menos um departamento

      if (!departments || !Array.isArray(departments) || departments.length === 0) {

        if (!department) { // Se nem department foi fornecido

          return res.status(400).json({ message: "Pelo menos um departamento deve ser selecionado" });

        }

      }

      

      // Verificar permiss√µes para alterar company_id

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session?.companyId;

      

      let effectiveCompanyId: number | null = null;

      

      if (userRole === 'admin') {

        // Admin pode especificar qualquer company_id

        effectiveCompanyId = company_id !== undefined ? company_id : null;

      } else {

        // Usu√°rios n√£o-admin n√£o podem alterar company_id, usar o da sess√£o

        effectiveCompanyId = sessionCompanyId || null;

        if (company_id !== undefined && company_id !== sessionCompanyId) {

          console.warn(`Usu√°rio ${userRole} tentou alterar company_id para ${company_id}, mas ser√° ignorado. Usando company_id da sess√£o: ${sessionCompanyId}`);

        }

      }

      

      // Preparar o objeto de atualiza√ß√£o, incluindo department para compatibilidade

      let departmentValue = 'technical'; // Fallback para um departamento padr√£o

      

      // Se department foi fornecido diretamente, use-o

      if (department) {

        departmentValue = department;

      }

      // Caso contr√°rio, use o primeiro departamento do array se dispon√≠vel

      else if (Array.isArray(departments) && departments.length > 0) {

        if (typeof departments[0] === 'object' && departments[0] !== null && 'department' in departments[0]) {

          departmentValue = departments[0].department;

        } else {

          departmentValue = departments[0];

        }

      }

      

      const updateData = {

        ...officialData,

        department: departmentValue, // Adicionar department para compatibilidade com a tabela f√≠sica

        company_id: effectiveCompanyId, // Incluir company_id

      };

      

      // Buscar o atendente para obter o userId associado

      const official = await storage.getOfficial(id);

      if (!official) {

        return res.status(404).json({ message: "Atendente n√£o encontrado" });

      }

      

      // Se recebemos dados do usu√°rio e o atendente tem um usu√°rio associado, atualiz√°-lo

      if (user && official.user_id) {

        

        // Preparar os dados de atualiza√ß√£o do usu√°rio

        const userUpdateData: any = {};

        

        

        // Se o username for fornecido, atualiz√°-lo

        if (user.username) {

          userUpdateData.username = user.username;

        }

        

        // Se o email for fornecido, atualiz√°-lo

        if (user.email) {

          userUpdateData.email = user.email;

        }

        

        // Se o nome for fornecido, atualiz√°-lo

        if (user.name) {

          userUpdateData.name = user.name;

        }

        

        // Incluir company_id no usu√°rio tamb√©m

        userUpdateData.company_id = effectiveCompanyId;

        

        // Se a senha for fornecida no objeto user, usar ela

        if (user.password) {

          // Criptografar a nova senha

          const { hashPassword } = await import('./utils/password');

          userUpdateData.password = await hashPassword(user.password);

        }

        // Ou se foi fornecida diretamente no objeto principal

        else if (password) {

          // Criptografar a nova senha

          const { hashPassword } = await import('./utils/password');

          userUpdateData.password = await hashPassword(password);

        }

        

        // Se temos dados para atualizar, realizar a atualiza√ß√£o

        if (Object.keys(userUpdateData).length > 0) {

          const updated = await storage.updateUser(official.user_id, userUpdateData);

          // Se a senha foi alterada, encerrar as sess√µes do usu√°rio

          if (userUpdateData.password) {

            try {

              await db.execute(sql`

                DELETE FROM user_sessions

                WHERE (sess->>'userId')::int = ${official.user_id}

              `);

            } catch (sessionError) {

              console.error('Erro ao encerrar sess√µes do usu√°rio (atendente) ap√≥s alterar senha:', sessionError);

            }

          }

        }

      }

      // Se apenas a senha foi fornecida diretamente, atualizar apenas ela

      else if (password && official.user_id) {

        // Criptografar a nova senha

        const { hashPassword } = await import('./utils/password');

        const hashedPassword = await hashPassword(password);

        

        // Atualizar a senha do usu√°rio associado, incluindo company_id

        await storage.updateUser(official.user_id, { 

          password: hashedPassword,

          company_id: effectiveCompanyId

        });

        // Encerrar sess√µes do usu√°rio ap√≥s alterar a senha via atendente

        try {

          await db.execute(sql`

            DELETE FROM user_sessions

            WHERE (sess->>'userId')::int = ${official.user_id}

          `);

        } catch (sessionError) {

          console.error('Erro ao encerrar sess√µes do usu√°rio (atendente) ap√≥s alterar senha:', sessionError);

        }

      }

      // Se n√£o h√° senha mas h√° company_id para atualizar no usu√°rio

      else if (official.user_id && effectiveCompanyId !== undefined) {

        await storage.updateUser(official.user_id, { 

          company_id: effectiveCompanyId

        });

      }

      

      // Atualizar dados b√°sicos do atendente

      const updatedOfficial = await storage.updateOfficial(id, updateData);

      if (!updatedOfficial) {

        return res.status(404).json({ message: "Atendente n√£o encontrado" });

      }

      

      // Se foram enviados departamentos, atualizar os departamentos do atendente

      if (departments && Array.isArray(departments)) {

        // Remover departamentos existentes

        const existingDepartments = await storage.getOfficialDepartments(id);

        for (const dept of existingDepartments) {

          // Remover diretamente por ID para evitar ambiguidade de nome

          await db

            .delete(schema.officialDepartments)

            .where(and(

              eq(schema.officialDepartments.official_id, id),

              eq(schema.officialDepartments.department_id, dept.department_id)

            ));

        }

        

        // Adicionar novos departamentos

        for (const dep of departments) {

          let resolvedDeptId: number | null = null;

          let depNameForLog = String(dep);

          try {

            if (typeof dep === 'object' && dep !== null) {

              if ('id' in dep && dep.id) {

                resolvedDeptId = Number(dep.id);

              } else if ('department_id' in dep && dep.department_id) {

                resolvedDeptId = Number(dep.department_id);

              } else if ('department' in dep && dep.department) {

                depNameForLog = String(dep.department);

              }

            } else if (typeof dep === 'string') {

              const asNum = Number(dep);

              if (!Number.isNaN(asNum)) {

                resolvedDeptId = asNum;

              } else {

                depNameForLog = dep;

              }

            } else if (typeof dep === 'number') {

              resolvedDeptId = dep;

            }



            let deptRecord: { id: number } | undefined;

            if (resolvedDeptId !== null) {

              const [rec] = await db

                .select({ id: schema.departments.id })

                .from(schema.departments)

                .where(

                  and(

                    eq(schema.departments.id, resolvedDeptId),

                    effectiveCompanyId ? eq(schema.departments.company_id, effectiveCompanyId) : isNull(schema.departments.company_id)

                  )

                );

              deptRecord = rec;

            }



            if (!deptRecord && depNameForLog) {

              const [recByName] = await db

                .select({ id: schema.departments.id })

                .from(schema.departments)

                .where(

                  and(

                    ilike(schema.departments.name, depNameForLog),

                    effectiveCompanyId ? eq(schema.departments.company_id, effectiveCompanyId) : isNull(schema.departments.company_id)

                  )

                );

              deptRecord = recByName;

            }



            if (deptRecord) {

              await storage.addOfficialDepartment({

                official_id: id,

                department_id: deptRecord.id

              });

            } else {

              console.warn(`Departamento n√£o encontrado (empresa=${effectiveCompanyId}): entrada='${JSON.stringify(dep)}'`);

            }

          } catch (e) {

            console.error('Erro ao resolver departamento (PATCH):', e);

          }

        }

        

        // Buscar os departamentos reais do banco para retornar nomes corretos

        const officialDepts = await storage.getOfficialDepartments(id);

        const departmentIds = officialDepts.map(od => od.department_id);

        let departmentNames: string[] = [];

        if (departmentIds.length > 0) {

          const depts = await db

            .select({ id: schema.departments.id, name: schema.departments.name })

            .from(schema.departments)

            .where(inArray(schema.departments.id, departmentIds));

          const deptMap = new Map(depts.map(d => [d.id, d.name]));

          departmentNames = departmentIds.map(id => deptMap.get(id) || `Dept-${id}`);

        }

        

        // Anexar nomes de departamentos ao resultado

        updatedOfficial.departments = departmentNames;

      }



      // Buscar o usu√°rio atualizado para incluir na resposta

      if (updatedOfficial.user_id) { // Corrigido para user_id

        const userData = await storage.getUser(updatedOfficial.user_id); // Corrigido para user_id

        if (userData) {

          // Remover a senha do usu√°rio antes de enviar

          // const { password: _, ...userWithoutPassword } = userData; // Linha original comentada

          // updatedOfficial.user = userWithoutPassword; // Linha problem√°tica removida

        }

      }



      res.json(updatedOfficial);

    } catch (error) {

      console.error('Erro ao atualizar atendente:', error);

      res.status(500).json({ message: "Falha ao atualizar atendente", error: String(error) });

    }

  });

  

  // Rota para alternar status (ativar/inativar) de um atendente

  router.patch("/officials/:id/toggle-active", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de atendente inv√°lido" });

      }



      // Buscar atendente para verificar o status atual e o userId

      const official = await storage.getOfficial(id);

      if (!official) {

        return res.status(404).json({ message: "Atendente n√£o encontrado" });

      }

      

      const userId = official.user_id; // Corrigido para user_id

      const currentActiveStatus = official.is_active; // Corrigido para is_active

      

      let updatedOfficial;

      if (currentActiveStatus) {

        // Se est√° ativo, inativar

        updatedOfficial = await storage.inactivateOfficial(id); // Removido ?

        

        // Tamb√©m inativar o usu√°rio associado, se existir

        if (userId) {

          await storage.inactivateUser(userId); // Removido ?

        }

        

        res.json({ 

          success: true, 

          message: "Atendente inativado com sucesso",

          isActive: false

        });

      } else {

        // Se est√° inativo, ativar

        updatedOfficial = await storage.activateOfficial(id); // Removido ?

        

        // Tamb√©m ativar o usu√°rio associado, se existir

        if (userId) {

          await storage.activateUser(userId); // Removido ?

        }

        

        res.json({ 

          success: true, 

          message: "Atendente ativado com sucesso",

          isActive: true 

        });

      }

    } catch (error) {

      console.error('Erro ao alternar status do atendente:', error);

      res.status(500).json({ message: "Falha ao alternar status do atendente", error: String(error) });

    }

  });

  

  router.delete("/officials/:id", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de atendente inv√°lido" });

      }



      // Buscar atendente para verificar se h√° um usu√°rio associado

      const official = await storage.getOfficial(id);

      if (!official) {

        return res.status(404).json({ message: "Atendente n√£o encontrado" });

      }

      

      // Armazenar o userId para inativa√ß√£o posterior

      const userId = official.user_id; // Corrigido para user_id



      // Duas op√ß√µes:

      // 1. Se quisermos manter o atendente na base para refer√™ncia hist√≥rica, podemos inativar

      //    apenas o usu√°rio associado, impedindo o login

      // 2. Se quisermos remover completamente o atendente, fazemos como est√° comentado abaixo

      

      // Op√ß√£o 1: Inativar apenas o usu√°rio (manter atendente para refer√™ncia hist√≥rica)

      if (userId) {

        const inactivatedUser = await storage.inactivateUser(userId); // Removido ?

        if (!inactivatedUser) {

          return res.status(404).json({ message: "Usu√°rio do atendente n√£o encontrado" });

        }

        

        // Tamb√©m inativar o atendente na tabela de atendentes para consist√™ncia

        await storage.updateOfficial(id, { is_active: false }); // Corrigido para is_active

        

        res.json({ 

          success: true, 

          message: "Atendente inativado com sucesso",

          inactive: true

        });

      } else {

        // Se n√£o h√° usu√°rio associado, remover o atendente

        const success = await storage.deleteOfficial(id);

        if (!success) {

          return res.status(404).json({ message: "Atendente n√£o encontrado" });

        }

        res.json({ success: true, message: "Atendente removido com sucesso" });

      }



      /* 

      // Op√ß√£o 2: Excluir o atendente da base (remover completamente)

      // Excluir o atendente primeiro

      const success = await storage.deleteOfficial(id);

      if (!success) {

        return res.status(404).json({ message: "Atendente n√£o encontrado" });

      }



      // Ap√≥s excluir o atendente com sucesso, excluir o usu√°rio associado, se houver

      if (userId) {

        await storage.deleteUser(userId);

      }



      res.json({ success: true });

      */

    } catch (error) {

      console.error('Erro ao excluir/inativar atendente:', error);

      res.status(500).json({ message: "Falha ao excluir/inativar atendente", error: String(error) });

    }

  });

  // Autentica√ß√£o

  router.post("/auth/login", authLimiter, validateSchema(loginSchema), async (req: Request, res: Response) => {

    try {

      const { username, password } = req.body;

      

      if (!username || !password) {

        return res.status(400).json({ message: "Usu√°rio e senha s√£o obrigat√≥rios" });

      }



      // Buscar o usu√°rio pelo username

      const user = await storage.getUserByUsername(username);

      

      if (!user) {

        return res.status(401).json({ message: "Credenciais inv√°lidas" });

      }

      

      // Verificar se o usu√°rio est√° ativo

      if (user.active === false) {

        return res.status(401).json({ message: "Conta inativa. Contate o administrador." });

      }

      

      // Verificar a senha - voltar para o import din√¢mico que funcionava antes

      const { verifyPassword } = await import('./utils/password');

      const passwordValid = await verifyPassword(password, user.password);

      

      if (!passwordValid) {

        return res.status(401).json({ message: "Credenciais inv√°lidas" });

      }

      

      // Verificar se o usu√°rio deve trocar a senha no pr√≥ximo login

      if (user.must_change_password) {

        return res.status(200).json({ 

          must_change_password: true,

          user_id: user.id,

          message: "Voc√™ deve alterar sua senha antes de continuar"

        });

      }

      

      // Buscar a empresa do usu√°rio, se n√£o for admin

      let company = null;

      if (user.company_id) {

        const [companyData] = await db

          .select()

          .from(schema.companies)

          .where(eq(schema.companies.id, user.company_id))

          .limit(1);

          

        if (companyData) {

          // Verificar se a empresa est√° ativa

          if (!companyData.active) {

            return res.status(403).json({ message: "Empresa inativa. Contate o administrador." });

          }

          

          company = companyData;

        }

      }

      

      // Se for admin sem empresa definida, permitir acesso sem restri√ß√£o de empresa

      if (user.role === 'admin' && !company) {

        // Salvar na sess√£o que este admin tem acesso global

        req.session.userId = user.id;

        req.session.userRole = user.role;

        

        // Retornar o usu√°rio sem empresa

        return res.json(user);

      }

      

      // Para usu√°rios n√£o-admin, √© obrigat√≥rio ter uma empresa

      if (!company && user.role !== 'admin') {

        return res.status(403).json({ 

          message: "Usu√°rio n√£o possui empresa associada. Contate o administrador." 

        });

      }

      

      // Salvar informa√ß√µes na sess√£o

      req.session.userId = user.id;

      // Mapear TODOS os roles v√°lidos para a sess√£o

      const validRoles = ['admin', 'company_admin', 'manager', 'supervisor', 'support', 'triage', 'customer', 'viewer', 'quality', 'integration_bot'];

      if (validRoles.includes(user.role)) {

        req.session.userRole = user.role;

      } else {

        console.warn(`Papel de usu√°rio '${user.role}' n√£o √© v√°lido. Roles v√°lidos: ${validRoles.join(', ')}`);

        // Definir como customer por seguran√ßa

        req.session.userRole = 'customer';

      }



      if (company) {

        req.session.companyId = company.id;

      }

      

      // Adicionar a informa√ß√£o da empresa ao objeto do usu√°rio para retornar ao cliente

      if (company) {

        // üéØ BUSCAR O NOME DA EMPRESA DAS CONFIGURA√á√ïES DO SISTEMA - SEM FALLBACK!

        const configuredCompanyName = await getSystemSetting('companyName', 'Ticket Wise', company.id);

        console.log('‚úÖ [LOGIN] Nome da empresa das configura√ß√µes:', configuredCompanyName);

        

        return res.json({

          ...user,

          company: {

            id: company.id,

            name: configuredCompanyName, // üéØ SEMPRE DAS CONFIGURA√á√ïES

            email: company.email,

            domain: company.domain || '',

            cnpj: company.cnpj || '',

            phone: company.phone || '',

            ai_permission: company.ai_permission

          }

        });

      } else {

        return res.json(user);

      }

    } catch (error) {

      console.error('Erro no login:', error);

      res.status(500).json({ message: "Erro no login" });

    }

  });



  router.post("/auth/logout", (req: Request, res: Response) => {

    // Destruir a sess√£o para fazer logout

    if (req.session) {

      req.session.destroy(() => {

        res.json({ success: true });

      });

    } else {

      res.json({ success: true });

    }

  });



  // Endpoint para for√ßar troca de senha no primeiro login

  router.post("/auth/change-forced-password", async (req: Request, res: Response) => {

    try {

      const { user_id, old_password, new_password } = req.body;

      

      if (!user_id || !old_password || !new_password) {

        return res.status(400).json({ 

          message: "ID do usu√°rio, senha atual e nova senha s√£o obrigat√≥rios" 

        });

      }

      

      // Buscar o usu√°rio

      const user = await storage.getUser(user_id);

      if (!user) {

        return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });

      }

      

      // Verificar se o usu√°rio realmente deve trocar a senha

      if (!user.must_change_password) {

        return res.status(400).json({ 

          message: "Este usu√°rio n√£o precisa trocar a senha" 

        });

      }

      

      // Verificar a senha atual

      const { verifyPassword, hashPassword } = await import('./utils/password');

      const passwordValid = await verifyPassword(old_password, user.password);

      

      if (!passwordValid) {

        return res.status(401).json({ message: "Senha atual incorreta" });

      }

      

      // Verificar se a nova senha n√£o √© a padr√£o

      const DEFAULT_PASSWORD = "123Mudar@!";

      if (new_password === DEFAULT_PASSWORD) {

        return res.status(400).json({ 

          message: "Voc√™ n√£o pode usar a senha padr√£o. Escolha uma senha diferente." 

        });

      }

      

      // Validar crit√©rios da nova senha (pode usar a mesma valida√ß√£o do registro)

      if (new_password.length < 8) {

        return res.status(400).json({ 

          message: "A nova senha deve ter pelo menos 8 caracteres" 

        });

      }

      

      // Criptografar a nova senha

      const hashedNewPassword = await hashPassword(new_password);

      

      // Atualizar a senha e remover a flag de must_change_password

      await db

        .update(schema.users)

        .set({ 

          password: hashedNewPassword,

          must_change_password: false,

          updated_at: new Date()

        })

        .where(eq(schema.users.id, user_id));

      

      // Encerrar todas as sess√µes do usu√°rio ap√≥s a troca de senha

      try {

        await db.execute(sql`

          DELETE FROM user_sessions

          WHERE (sess->>'userId')::int = ${user_id}

        `);

      } catch (sessionError) {

        console.error('Erro ao encerrar sess√µes do usu√°rio ap√≥s troca de senha:', sessionError);

        // N√£o falhar a opera√ß√£o principal por causa disso

      }

      

      // Retornar sucesso

      res.json({ 

        success: true, 

        message: "Senha alterada com sucesso" 

      });

      

    } catch (error) {

      console.error('Erro ao alterar senha for√ßada:', error);

      res.status(500).json({ message: "Erro interno do servidor" });

    }

  });



  // Endpoint para marcar usu√°rios como "deve trocar senha" (para importa√ß√£o em lote)

  router.post("/auth/mark-users-must-change-password", adminRequired, async (req: Request, res: Response) => {

    try {

      const { user_ids } = req.body;

      

      if (!user_ids || !Array.isArray(user_ids) || user_ids.length === 0) {

        return res.status(400).json({ 

          message: "Lista de IDs de usu√°rios √© obrigat√≥ria" 

        });

      }

      

      // Atualizar todos os usu√°rios especificados

      const result = await db

        .update(schema.users)

        .set({ 

          must_change_password: true,

          updated_at: new Date()

        })

        .where(sql`${schema.users.id} IN (${sql.join(user_ids.map((id: number) => sql`${id}`), sql`, `)})`)

        .returning({ id: schema.users.id, username: schema.users.username });

      

      res.json({ 

        success: true, 

        message: `${result.length} usu√°rios marcados para trocar senha`,

        updated_users: result

      });

      

    } catch (error) {

      console.error('Erro ao marcar usu√°rios para trocar senha:', error);

      res.status(500).json({ message: "Erro interno do servidor" });

    }

  });

  

  // Rota para testar a conex√£o com o Active Directory (apenas admin)

  router.get("/auth/test-ad", adminRequired, async (req: Request, res: Response) => {

    try {

      const { testADConnection } = await import('./utils/active-directory');

      const result = await testADConnection();

      res.json(result);

    } catch (error) {

      console.error('Erro ao testar conex√£o AD:', error);

      res.status(500).json({ 

        success: false, 

        message: 'Erro ao testar conex√£o com AD',

        error: error instanceof Error ? error.message : String(error)

      });

    }

  });

  

  // Rota para testar a conex√£o com o Active Directory (acesso p√∫blico para depura√ß√£o)

  router.get("/auth/test-ad-public", async (req: Request, res: Response) => {

    try {

      console.log('[AD Debug] Iniciando teste de conex√£o AD (rota p√∫blica)');

      const { testADConnection } = await import('./utils/active-directory');

      const result = await testADConnection();

      console.log('[AD Debug] Resultado do teste:', result);

      res.json(result);

    } catch (error) {

      console.error('[AD Debug] Erro ao testar conex√£o AD:', error);

      res.status(500).json({ 

        success: false, 

        message: 'Erro ao testar conex√£o com AD',

        error: error instanceof Error ? error.message : String(error)

      });

    }

  });

  

  // Rota para testar a autentica√ß√£o de um usu√°rio espec√≠fico com o AD

  router.post("/auth/test-ad-user", async (req: Request, res: Response) => {

    try {

      const { username, password } = req.body;

      

      if (!username || !password) {

        return res.status(400).json({ message: "Usu√°rio e senha s√£o obrigat√≥rios" });

      }

      

      console.log(`[AD Debug] Testando autentica√ß√£o do usu√°rio '${username}' com o AD`);

      const { authenticateAD } = await import('./utils/active-directory');

      

      // Tenta autenticar com AD

      const adUser = await authenticateAD(username, password);

      

      if (!adUser) {

        return res.status(401).json({ 

          success: false,

          message: "Credenciais inv√°lidas no Active Directory" 

        });

      }

      

      // Autentica√ß√£o bem-sucedida, retornar dados do usu√°rio (sem informa√ß√µes sens√≠veis)

      res.json({

        success: true,

        message: "Autentica√ß√£o bem-sucedida com o Active Directory",

        user: {

          username: adUser.username,

          name: adUser.name,

          email: adUser.email,

          attributes: Object.keys(adUser.adData || {})

        }

      });

    } catch (error) {

      console.error('[AD Debug] Erro ao testar autentica√ß√£o de usu√°rio:', error);

      res.status(500).json({ 

        success: false, 

        message: 'Erro ao testar autentica√ß√£o de usu√°rio com AD',

        error: error instanceof Error ? error.message : String(error)

      });

    }

  });



  // Endpoint para criar usu√°rios

  router.post("/users", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { username, email, password, name, role, avatarUrl, company_id } = req.body;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session?.companyId;

      

      console.log(`Tentando criar usu√°rio: ${name}, email: ${email}, username: ${username}, role: ${role}`);

      

      // VALIDA√á√ÉO CR√çTICA DE SEGURAN√áA: Apenas usu√°rios admin podem criar outros admin

      if (role === 'admin' && userRole !== 'admin') {

        console.log(`TENTATIVA DE ESCALA√á√ÉO DE PRIVIL√âGIOS: Usu√°rio com role '${userRole}' tentou criar usu√°rio admin`);

        return res.status(403).json({ 

          message: "Acesso negado: Apenas administradores globais podem criar outros administradores" 

        });

      }

      

      const existingUser = await storage.getUserByUsername(username);

      if (existingUser) {

        console.log(`Erro: Nome de usu√°rio '${username}' j√° existe`);

        return res.status(400).json({ message: "Nome de usu√°rio j√° existe" });

      }

      

      const existingEmail = await storage.getUserByEmail(email);

      if (existingEmail) {

        console.log(`Erro: Email '${email}' j√° est√° em uso`);

        return res.status(400).json({ message: "Email j√° est√° em uso" });

      }

      

      // Determinar company_id baseado no role do usu√°rio logado

      let finalCompanyId: number | undefined;

      if (userRole === 'admin') {

        // Admin pode especificar qualquer empresa ou deixar sem empresa

        finalCompanyId = company_id || undefined;

      } else {

        // Outros roles s√≥ podem criar usu√°rios para sua pr√≥pria empresa

        finalCompanyId = sessionCompanyId;

      }

      

      const { hashPassword } = await import('./utils/password');

      const hashedPassword = await hashPassword(password);

      

      const user = await storage.createUser({

        username,

        email,

        password: hashedPassword,

        name,

        role: role as typeof schema.userRoleEnum.enumValues[number],

        avatar_url: avatarUrl,

        company_id: finalCompanyId,

        active: true 

      });

      

      // Notificar sobre novo usu√°rio criado

      try {

        await emailNotificationService.notifyNewUserCreated(user.id, req.session?.userId);

      } catch (notificationError) {

        console.error('Erro ao enviar notifica√ß√£o de novo usu√°rio:', notificationError);

        // N√£o falhar a cria√ß√£o do usu√°rio por causa da notifica√ß√£o

      }

      

      const { password: _, ...userWithoutPassword } = user;

      

      res.status(201).json(userWithoutPassword);

    } catch (error) {

      console.error('Erro ao criar usu√°rio:', error);

      res.status(500).json({ message: "Falha ao criar usu√°rio", error: String(error) });

    }

  });

  

  // Endpoint para criar usu√°rio de suporte e atendente em uma √∫nica transa√ß√£o at√¥mica

  router.post("/support-users", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    // Importar e chamar o endpoint de cria√ß√£o integrada

    const { hashPassword } = await import('./utils/password');

    const { createSupportUserEndpoint } = await import('./endpoints/create-support-user');

    await createSupportUserEndpoint(req, res, storage, hashPassword);

  });

  

  // Endpoint para atualizar informa√ß√µes do usu√°rio

  router.patch("/users/:id", authorize(['admin', 'company_admin', 'manager', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de usu√°rio inv√°lido" });

      }

      

      const { name, email, username, password, role } = req.body;

      const userRole = req.session?.userRole as string;

      

      // Verificar se o usu√°rio existe

      const existingUser = await storage.getUser(id);

      if (!existingUser) {

        return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });

      }

      

      // VALIDA√á√ÉO DE HIERARQUIA: Verificar se o usu√°rio pode alterar o role

      if (role && !canManageUserRole(userRole, role)) {

        console.log(`TENTATIVA DE ESCALA√á√ÉO DE PRIVIL√âGIOS: Usu√°rio com role '${userRole}' tentou alterar usu√°rio ${id} para '${role}'`);

        return res.status(403).json({ 

          message: `Acesso negado: Seu n√≠vel de permiss√£o (${userRole}) n√£o permite definir o role '${role}'` 

        });

      }

      

      // Se estamos alterando o nome de usu√°rio, verificar se j√° existe

      if (username && username !== existingUser.username) {

        const userWithUsername = await storage.getUserByUsername(username);

        if (userWithUsername && userWithUsername.id !== id) {

          return res.status(400).json({ message: "Nome de usu√°rio j√° est√° em uso" });

        }

      }

      

      // Se estamos alterando o email, verificar se j√° existe

      if (email && email !== existingUser.email) {

        const userWithEmail = await storage.getUserByEmail(email);

        if (userWithEmail && userWithEmail.id !== id) {

          return res.status(400).json({ message: "Email j√° est√° em uso" });

        }

      }

      

      // Se uma senha foi fornecida, criptograf√°-la

      let hashedPassword;

      if (password) {

        const { hashPassword } = await import('./utils/password');

        hashedPassword = await hashPassword(password);

      }

      

      // Preparar dados de atualiza√ß√£o

      const updateData: any = {};

      if (name) updateData.name = name;

      if (email) updateData.email = email;

      if (username) updateData.username = username;

      if (role) updateData.role = role;

      if (hashedPassword) updateData.password = hashedPassword;

      updateData.updated_at = new Date();

      

      // Atualizar usu√°rio

      const updatedUser = await storage.updateUser(id, updateData);

      

      // Se a senha foi atualizada, encerrar sess√µes desse usu√°rio

      if (updateData.password) {

        try {

          await db.execute(sql`

            DELETE FROM user_sessions

            WHERE (sess->>'userId')::int = ${id}

          `);

        } catch (sessionError) {

          console.error('Erro ao encerrar sess√µes do usu√°rio (usu√°rios) ap√≥s alterar senha:', sessionError);

        }

      }

      if (!updatedUser) {

        return res.status(500).json({ message: "Falha ao atualizar usu√°rio" });

      }

      

      // N√£o retornar a senha

      const { password: _, ...userWithoutPassword } = updatedUser;

      

      res.json(userWithoutPassword);

    } catch (error) {

      console.error('Erro ao atualizar usu√°rio:', error);

      res.status(500).json({ message: "Falha ao atualizar usu√°rio", error: String(error) });

    }

  });



  // Endpoint para gerenciar status de ativa√ß√£o de usu√°rios

  router.patch("/users/:id/toggle-active", authorize(['admin', 'company_admin', 'manager', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ message: "ID de usu√°rio inv√°lido" });

      }

      

      // Buscar usu√°rio atual para verificar seu status atual

      const user = await storage.getUser(id);

      if (!user) {

        return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });

      }

      

      // Impedir inativa√ß√£o da pr√≥pria conta do administrador logado

      if (user.id === req.session?.userId && user.active !== false) {

        return res.status(403).json({ 

          message: "N√£o √© poss√≠vel inativar sua pr√≥pria conta de administrador",

          type: "self-deactivation"

        });

      }

      

      // Alternar o status active do usu√°rio

      let updatedUser;

      if (user.active === false) {

        updatedUser = await storage.activateUser(id);

      } else {

        updatedUser = await storage.inactivateUser(id);

      }

      

      if (!updatedUser) {

        return res.status(500).json({ message: "Falha ao atualizar status do usu√°rio" });

      }

      

      // N√£o retornar a senha

      const { password: _, ...userWithoutPassword } = updatedUser;

      

      res.json({

        user: userWithoutPassword,

        message: updatedUser.active ? "Usu√°rio ativado com sucesso" : "Usu√°rio inativado com sucesso"

      });

    } catch (error) {

      console.error('Erro ao alternar status do usu√°rio:', error);

      res.status(500).json({ message: "Falha ao alternar status do usu√°rio", error: String(error) });

    }

  });



  // Endpoint para listar todos os usu√°rios com pagina√ß√£o (todos os atendentes)

  router.get("/users", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor', 'support']), async (req: Request, res: Response) => {

    try {

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50; // 50 por p√°gina por padr√£o

      const search = (req.query.search as string) || '';

      const includeInactive = req.query.includeInactive === 'true';

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session?.companyId;

      

      // Buscar usu√°rios

      const allUsers = includeInactive ? 

        await storage.getAllUsers() : 

        await storage.getActiveUsers();

      

      // Aplicar filtros de empresa

      let filteredUsers = allUsers;

      

      if (userRole === 'admin') {

        // Admin pode filtrar por empresa espec√≠fica ou ver todos

        if (filterCompanyId) {

          filteredUsers = allUsers.filter(user => user.company_id === filterCompanyId);

        }

        // Se filterCompanyId for null, mostra todos

      } else {

        // Usu√°rios n√£o-admin sempre veem apenas sua empresa

        filteredUsers = allUsers.filter(user => user.company_id === sessionCompanyId);

      }

      

      // Aplicar filtro de busca se fornecido

      if (search) {

        const searchLower = search.toLowerCase();

        filteredUsers = filteredUsers.filter(user => 

          user.name.toLowerCase().includes(searchLower) ||

          user.email.toLowerCase().includes(searchLower) ||

          user.username.toLowerCase().includes(searchLower) ||

          user.role.toLowerCase().includes(searchLower)

        );

      }

      

      // Ordena√ß√£o j√° √© feita no banco de dados via DatabaseStorage.getActiveUsers()/getAllUsers()

      

      // N√£o retornar as senhas

      const usersWithoutPasswords = filteredUsers.map(user => {

        const { password, ...userWithoutPassword } = user;

        return userWithoutPassword;

      });

      

      // Calcular pagina√ß√£o

      const total = usersWithoutPasswords.length;

      const totalPages = Math.ceil(total / limit);

      const offset = (page - 1) * limit;

      const paginatedUsers = usersWithoutPasswords.slice(offset, offset + limit);

      

      res.json({

        data: paginatedUsers,

        pagination: {

          page,

          limit,

          total,

          totalPages,

          hasNext: page < totalPages,

          hasPrev: page > 1

        }

      });

    } catch (error) {

      console.error('Erro ao listar usu√°rios:', error);

      res.status(500).json({ message: "Falha ao listar usu√°rios", error: String(error) });

    }

  });

  

  // Endpoint para obter o usu√°rio atual (quando autenticado)

  router.get("/auth/me", authRequired, async (req: Request, res: Response) => {

    try {

      // Verificamos a sess√£o/autentica√ß√£o

      if (!req.session || !req.session.userId) {

        return res.status(401).json({ message: "N√£o autenticado" });

      }

      

      // Buscar o usu√°rio pelo ID da sess√£o

      const user = await storage.getUser(req.session.userId);

      

      if (!user) {

        return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });

      }

      

      // Verificar se o usu√°rio est√° ativo

      if (!user.active) {

        return res.status(403).json({ message: "Usu√°rio inativo" });

      }

      

      // Se o usu√°rio tem uma empresa associada, buscar os dados da empresa

      if (req.session.companyId) {

        const companyData = await storage.getCompany(req.session.companyId);

        

        if (companyData) {

          // üéØ BUSCAR O NOME DA EMPRESA DAS CONFIGURA√á√ïES DO SISTEMA - SEM FALLBACK!

          const configuredCompanyName = await getSystemSetting('companyName', 'Ticket Wise', req.session.companyId);

          

          const userWithCompany = {

            ...user,

            company_id: req.session.companyId, // Adicionar company_id explicitamente

            company: { // Apenas campos existentes no schema.companies + nome configurado

              id: companyData.id,

              name: configuredCompanyName, // üéØ SEMPRE DAS CONFIGURA√á√ïES

              email: companyData.email,

              domain: companyData.domain || '',

              active: companyData.active,

              cnpj: companyData.cnpj || '',

              phone: companyData.phone || '',

              ai_permission: companyData.ai_permission

            }

          };

          

          return res.json(userWithCompany);

        } else {

          return res.json(user);

        }

      } else {

        return res.json(user);

      }

    } catch (error) {

      console.error('Erro ao obter usu√°rio atual:', error);

      res.status(500).json({ message: "Erro interno do servidor" });

    }

  });

  

  // Rotas para configura√ß√µes do sistema

  // Configura√ß√µes gerais

  router.get("/settings/general", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      

      // Buscar configura√ß√µes do sistema para a empresa espec√≠fica

      const companyName = await getSystemSetting('companyName', 'Ticket Lead', companyId);

      const supportEmail = await getSystemSetting('supportEmail', 'suporte@ticketlead.exemplo', companyId);

      const allowCustomerRegistration = await getSystemSetting('allowCustomerRegistration', 'true', companyId);

      

      // Montar objeto de resposta

      res.json({

        companyName,

        supportEmail,

        allowCustomerRegistration: allowCustomerRegistration === 'true'

      });

    } catch (error) {

      console.error('Erro ao obter configura√ß√µes gerais:', error);

      res.status(500).json({ message: "Falha ao buscar configura√ß√µes gerais", error: String(error) });

    }

  });

  

  router.post("/settings/general", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { companyName, supportEmail, allowCustomerRegistration } = req.body;

      const companyId = req.session.companyId;

      

      // Salvar configura√ß√µes para a empresa espec√≠fica

      await saveSystemSetting('companyName', companyName, companyId);

      await saveSystemSetting('supportEmail', supportEmail, companyId);

      await saveSystemSetting('allowCustomerRegistration', allowCustomerRegistration.toString(), companyId);

      

      res.json({

        companyName,

        supportEmail,

        allowCustomerRegistration

      });

    } catch (error) {

      console.error('Erro ao salvar configura√ß√µes gerais:', error);

      res.status(500).json({ message: "Falha ao salvar configura√ß√µes gerais", error: String(error) });

    }

  });

  

  // Configura√ß√µes de departamentos

  router.get("/settings/departments", authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      // Buscar configura√ß√µes de departamentos

      const departmentsJson = await getSystemSetting('departments', '[]');

      

      try {

        const departments = JSON.parse(departmentsJson);

        return res.json(departments);

      } catch (parseError) {

        console.error('Erro ao fazer parse dos departamentos:', parseError);

        const defaultDepartments = [

          { id: 1, name: "Suporte T√©cnico", description: "Para problemas t√©cnicos e de produto" },

          { id: 2, name: "Faturamento", description: "Para consultas de pagamento e faturamento" },

          { id: 3, name: "Atendimento ao Cliente", description: "Para consultas gerais e assist√™ncia" }

        ];

        return res.json(defaultDepartments);

      }

    } catch (error) {

      console.error('Erro ao obter departamentos:', error);

      res.status(500).json({ message: "Falha ao buscar departamentos", error: String(error) });

    }

  });

  

  router.post("/settings/departments", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const departments = req.body;

      

      if (!Array.isArray(departments)) {

        return res.status(400).json({ message: "Formato inv√°lido. Envie um array de departamentos." });

      }

      

      // Converter para string JSON e salvar

      const departmentsJson = JSON.stringify(departments);

      await saveSystemSetting('departments', departmentsJson);

      

      res.json(departments);

    } catch (error) {

      console.error('Erro ao salvar departamentos:', error);

      res.status(500).json({ message: "Falha ao salvar departamentos", error: String(error) });

    }

  });

  

  // Configura√ß√µes de tipos de incidentes

  router.get("/settings/incident-types", adminRequired, async (req: Request, res: Response) => {

    try {

      // Buscar tipos de incidentes da nova tabela

      const incidentTypes = await db

        .select()

        .from(schema.incidentTypes)

        .orderBy(schema.incidentTypes.id);

      

      return res.json(incidentTypes);

    } catch (error) {

      console.error('Erro ao obter tipos de incidentes:', error);

      res.status(500).json({ message: "Falha ao buscar tipos de incidentes", error: String(error) });

    }

  });

  

  // Rota para usu√°rios obterem tipos de incidentes com pagina√ß√£o

  router.get("/incident-types", authRequired, async (req: Request, res: Response) => {

    try {

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50; // 50 por p√°gina por padr√£o

      const search = (req.query.search as string) || '';

      const active_only = req.query.active_only === "true";

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const department_id = req.query.department_id ? parseInt(req.query.department_id as string) : null;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;



      // Verificar se o usu√°rio tem uma empresa associada (exceto admin)

      if (!sessionCompanyId && userRole !== 'admin') {

        return res.status(400).json({ message: "Usu√°rio sem empresa associada" });

      }



      const conditions: SQLWrapper[] = [];



      // L√≥gica de filtro por empresa

      if (userRole === 'admin') {

        // Admin pode filtrar por empresa espec√≠fica ou ver todas

        if (filterCompanyId) {

          conditions.push(eq(schema.incidentTypes.company_id, filterCompanyId));

        }

        // Se filterCompanyId for null, mostra todos

      } else {

        // Usu√°rios n√£o-admin veem sua empresa + globais (company_id IS NULL)

        if (sessionCompanyId) {

          conditions.push(

            or(

              isNull(schema.incidentTypes.company_id),

              eq(schema.incidentTypes.company_id, sessionCompanyId)

            )

          );

        }

      }



      if (active_only) {

        conditions.push(eq(schema.incidentTypes.is_active, true));

      }



      if (department_id) {

        conditions.push(eq(schema.incidentTypes.department_id, department_id));

      }



      // Filtro por busca (nome ou descri√ß√£o)

      if (search) {

        const searchCondition = or(

          ilike(schema.incidentTypes.name, `%${search}%`),

          ilike(schema.incidentTypes.description, `%${search}%`)

        );

        if (searchCondition) {

          conditions.push(searchCondition);

        }

      }



      // Contar total de registros com filtros aplicados

      let countQuery = db

        .select({ count: sql<number>`count(*)`.mapWith(Number) })

        .from(schema.incidentTypes);



      if (conditions.length > 0) {

        countQuery = countQuery.where(and(...conditions)) as typeof countQuery;

      }



      const [{ count: totalCount }] = await countQuery;



      // Calcular offset para pagina√ß√£o

      const offset = (page - 1) * limit;



      // Se for admin, incluir informa√ß√µes da empresa

      if (userRole === 'admin') {

        const incidentTypes = await db.query.incidentTypes.findMany({

          where: conditions.length > 0 ? and(...conditions) : undefined,

          orderBy: [asc(schema.incidentTypes.name)], // Ordena√ß√£o alfab√©tica

          limit: limit,

          offset: offset,

          with: {

            company: {

              columns: {

                id: true,

                name: true,

              }

            }

          }

        });

        

        const totalPages = Math.ceil(totalCount / limit);

        

        return res.json({

          incidentTypes: incidentTypes,

          pagination: {

            current: page,

            pages: totalPages,

            total: totalCount,

            limit: limit

          }

        });

      } else {

        // Para outros usu√°rios, buscar sem informa√ß√µes da empresa

        let queryBuilder = db

          .select()

          .from(schema.incidentTypes);



        if (conditions.length > 0) {

          queryBuilder = queryBuilder.where(and(...conditions)) as typeof queryBuilder;

        }



        const incidentTypes = await queryBuilder

          .orderBy(asc(schema.incidentTypes.name)) // Ordena√ß√£o alfab√©tica

          .limit(limit)

          .offset(offset);

        

        const totalPages = Math.ceil(totalCount / limit);

        

        return res.json({

          incidentTypes: incidentTypes,

          pagination: {

            current: page,

            pages: totalPages,

            total: totalCount,

            limit: limit

          }

        });

      }

    } catch (error) {

      console.error('Erro ao obter tipos de incidentes para usu√°rio:', error);

      res.status(500).json({ message: "Falha ao buscar tipos de incidentes", error: String(error) });

    }

  });

  

  // Rota para criar um novo Tipo de Chamado (Incident Type)

  router.post(

    "/incident-types",

    authRequired,

    authorize(['admin', 'manager', 'company_admin', 'supervisor']),

    async (req: Request, res: Response) => {

      try {

        const { name, value, description, department_id, company_id: company_id_from_body, is_active } = req.body;

        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        let effectiveCompanyId: number | null = null; // Default para NULL (global) se admin n√£o especificar



        if (userRole === 'admin') {

          if (company_id_from_body !== undefined) { // Admin pode explicitamente setar company_id ou null

            effectiveCompanyId = company_id_from_body;

          }

          // Se company_id_from_body for undefined, effectiveCompanyId permanece null (global)

        } else if (userRole === 'company_admin') {

          // Company_admin s√≥ pode criar tipos de chamado para sua pr√≥pria empresa

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Company_admin n√£o possui uma empresa associada na sess√£o." });

          }

          effectiveCompanyId = sessionCompanyId;

          if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

            console.warn("Company_admin tentou especificar um company_id diferente do seu na cria√ß√£o do tipo de chamado. A√ß√£o ignorada, usando o company_id da sess√£o.");

          }

        } else if (userRole === 'manager') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Manager n√£o possui uma empresa associada na sess√£o." });

          }

          effectiveCompanyId = sessionCompanyId;

          if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

            console.warn("Manager tentou especificar um company_id diferente do seu na cria√ß√£o do tipo de chamado. A√ß√£o ignorada, usando o company_id da sess√£o.");

          }

        } else if (userRole === 'supervisor') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Supervisor n√£o possui uma empresa associada na sess√£o." });

          }

          effectiveCompanyId = sessionCompanyId;

          if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

            console.warn("Supervisor tentou especificar um company_id diferente do seu na cria√ß√£o do tipo de chamado. A√ß√£o ignorada, usando o company_id da sess√£o.");

          }

        } else {

          return res.status(403).json({ message: "Acesso negado." });

        }



        if (!name || !value) {

          return res.status(400).json({ message: "Nome e Valor do tipo de chamado s√£o obrigat√≥rios." });

        }

        if (department_id === undefined) {

            return res.status(400).json({ message: "Department ID √© obrigat√≥rio." });

        }

        

        // Opcional: Verificar se o department_id fornecido pertence √† effectiveCompanyId (se n√£o for global)

        if (effectiveCompanyId !== null && department_id) {

            const [department] = await db.select().from(departmentsSchema).where(and(eq(departmentsSchema.id, department_id), eq(departmentsSchema.company_id, effectiveCompanyId)));

            if(!department){

                return res.status(400).json({ message: `Departamento ID ${department_id} n√£o encontrado ou n√£o pertence √† empresa ID ${effectiveCompanyId}.` });

            }

        }





        // Verificar duplicidade (nome + company_id) ou (nome + global)

        const existingConditions: SQLWrapper[] = [eq(schema.incidentTypes.name, name)];

        if (effectiveCompanyId === null) {

          existingConditions.push(isNull(schema.incidentTypes.company_id));

        } else {

          existingConditions.push(eq(schema.incidentTypes.company_id, effectiveCompanyId));

        }

        const [existingIncidentType] = await db.select().from(schema.incidentTypes).where(and(...existingConditions));



        if (existingIncidentType) {

          return res.status(409).json({ message: `J√° existe um tipo de chamado com o nome "${name}" ${effectiveCompanyId === null ? 'globalmente' : 'nesta empresa'}.` });

        }



        const newIncidentType = await db

          .insert(schema.incidentTypes)

          .values({

            name,

            value,

            description: description || null,

            department_id,

            company_id: effectiveCompanyId,

            is_active: is_active !== undefined ? is_active : true,

            created_at: new Date(),

            updated_at: new Date(),

          })

          .returning();

        res.status(201).json(newIncidentType[0]);

      } catch (error: any) {

        console.error("Error creating incident type:", error);

        if (error instanceof z.ZodError) {

          return res.status(400).json({ message: "Validation failed", errors: error.errors });

        }

        // Tratar erro de chave duplicada de PK

        if (error && error.code === '23505' && error.constraint === 'incident_types_pkey') {

          console.warn("Tentativa de inserir incident_type com ID duplicado. Rejeitar solicita√ß√£o.");

          return res.status(409).json({ message: "Tipo de incidente j√° existe com este ID. Tente novamente." });

        }

        // Tratar erro de FK para department_id, se aplic√°vel (embora j√° tenhamos checado)

        if (error && error.code === '23503' && error.constraint && error.constraint.includes('incident_types_department_id_fkey')) {

            return res.status(400).json({ message: "Department ID inv√°lido ou n√£o existente."});

        }

        res.status(500).json({ message: "Failed to create incident type" });

      }

    }

  );



  // Rota para usu√°rios n√£o-admin obterem departamentos com pagina√ß√£o

  router.get("/departments", authRequired, async (req: Request, res: Response) => {

    try {

      // Suporte a contexto espec√≠fico da tela de cria√ß√£o de ticket

      const context = (req.query.context as string) || '';

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50; // 50 por p√°gina por padr√£o

      const search = (req.query.search as string) || '';

      const active_only = req.query.active_only === "true";

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const userRole = req.session?.userRole as string;

      const userId = req.session?.userId;

      const sessionCompanyId = req.session.companyId;



      const conditions: SQLWrapper[] = [];



      // Contexto de cria√ß√£o de ticket: obrigatoriamente filtrar por empresa e apenas departamentos ativos

      if (context === 'create_ticket' || context === 'transfer_ticket') {

        // Determinar empresa efetiva

        let effectiveCompanyId: number | null = null;

        if (userRole === 'admin') {

          // Admin precisa especificar a empresa alvo via query

          effectiveCompanyId = filterCompanyId ?? null;

          if (!effectiveCompanyId) {

            return res.status(400).json({ message: `Para context=${context}, admin deve informar company_id.` });

          }

        } else {

          // Demais pap√©is: usar empresa da sess√£o

          effectiveCompanyId = sessionCompanyId ?? null;

          if (!effectiveCompanyId) {

            return res.status(403).json({ message: "Acesso negado: ID da empresa n√£o encontrado na sess√£o." });

          }

        }



        // Filtros obrigat√≥rios

        conditions.push(eq(departmentsSchema.company_id, effectiveCompanyId));

        conditions.push(eq(departmentsSchema.is_active, true));



        // Filtro por busca (opcional)

        if (search) {

          const searchCondition = or(

            ilike(departmentsSchema.name, `%${search}%`),

            ilike(departmentsSchema.description, `%${search}%`)

          );

          conditions.push(searchCondition);

        }



        // Contagem total

        let countQuery = db

          .select({ count: sql<number>`count(*)`.mapWith(Number) })

          .from(departmentsSchema)

          .where(and(...conditions));

        const [{ count: totalCount }] = await countQuery;



        const offset = (page - 1) * limit;

        const departments = await db

          .select()

          .from(departmentsSchema)

          .where(and(...conditions))

          .orderBy(asc(departmentsSchema.name))

          .limit(limit)

          .offset(offset);



        const totalPages = Math.ceil(totalCount / limit);

        return res.json({

          departments,

          pagination: {

            current: page,

            pages: totalPages,

            total: totalCount,

            limit: limit

          }

        });

      }



      // L√≥gica de filtro por empresa E por departamentos espec√≠ficos do usu√°rio

      if (userRole === 'admin') {

        // Admin pode filtrar por empresa espec√≠fica ou ver todas

        if (filterCompanyId) {

          conditions.push(eq(departmentsSchema.company_id, filterCompanyId));

        }

        // Se filterCompanyId for null, mostra todos

      } else if (userRole === 'company_admin') {

        // Company Admin v√™ todos os departamentos da sua empresa

        if (sessionCompanyId) {

          conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

        } else {

          return res.status(403).json({ message: "Acesso negado: ID da empresa n√£o encontrado na sess√£o." });

        }

      } else if (userRole === 'manager') {

        // Manager v√™ APENAS os departamentos que est√° vinculado

        if (!sessionCompanyId || !userId) {

          return res.status(403).json({ message: "Acesso negado: ID da empresa ou usu√°rio n√£o encontrado na sess√£o." });

        }



        // Buscar o official do usu√°rio

        const [official] = await db

          .select()

          .from(schema.officials)

          .where(eq(schema.officials.user_id, userId))

          .limit(1);



        if (!official) {

          return res.status(403).json({ message: "Manager n√£o √© um atendente." });

        }



        // Buscar departamentos do manager

        const userDepartments = await db

          .select({ department_id: schema.officialDepartments.department_id })

          .from(schema.officialDepartments)

          .where(eq(schema.officialDepartments.official_id, official.id));



        if (userDepartments.length === 0) {

          // Se o manager n√£o tem departamentos, retornar lista vazia

          return res.json({

            departments: [],

            pagination: {

              current: page,

              pages: 0,

              total: 0,

              limit: limit

            }

          });

        }



        const allowedDepartmentIds = userDepartments.map(d => d.department_id).filter(id => id !== null);



        if (allowedDepartmentIds.length === 0) {

          return res.json({

            departments: [],

            pagination: {

              current: page,

              pages: 0,

              total: 0,

              limit: limit

            }

          });

        }



        // Filtrar apenas pelos departamentos do manager + empresa

        conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

        conditions.push(inArray(departmentsSchema.id, allowedDepartmentIds));

      } else if (userRole === 'supervisor' || userRole === 'support') {

        // üÜï NOVA L√ìGICA: Support/Supervisor veem APENAS seus departamentos

        if (!sessionCompanyId || !userId) {

          return res.status(403).json({ message: "Acesso negado: ID da empresa ou usu√°rio n√£o encontrado na sess√£o." });

        }



        // Buscar o official do usu√°rio

        const [official] = await db

          .select()

          .from(schema.officials)

          .where(eq(schema.officials.user_id, userId))

          .limit(1);



        if (!official) {

          return res.status(403).json({ message: "Usu√°rio n√£o √© um atendente." });

        }



        // Buscar departamentos do usu√°rio

        const userDepartments = await db

          .select({ department_id: schema.officialDepartments.department_id })

          .from(schema.officialDepartments)

          .where(eq(schema.officialDepartments.official_id, official.id));



        if (userDepartments.length === 0) {

          // Se o usu√°rio n√£o tem departamentos, retornar lista vazia

          return res.json({

            departments: [],

            pagination: {

              current: page,

              pages: 0,

              total: 0,

              limit: limit

            }

          });

        }



        let allowedDepartmentIds = userDepartments.map(d => d.department_id).filter(id => id !== null);



        // Se for supervisor, tamb√©m incluir departamentos dos subordinados

        if (userRole === 'supervisor') {

          const subordinates = await db

            .select({ id: schema.officials.id })

            .from(schema.officials)

            .where(eq(schema.officials.supervisor_id, official.id));



          for (const subordinate of subordinates) {

            const subordinateDepartments = await db

              .select({ department_id: schema.officialDepartments.department_id })

              .from(schema.officialDepartments)

              .where(eq(schema.officialDepartments.official_id, subordinate.id));

            

            // Adicionar departamentos dos subordinados que ainda n√£o est√£o na lista

            subordinateDepartments.forEach(dept => {

              if (dept.department_id && !allowedDepartmentIds.includes(dept.department_id)) {

                allowedDepartmentIds.push(dept.department_id);

              }

            });

          }

        }



        if (allowedDepartmentIds.length === 0) {

          // Se n√£o tem IDs de departamentos, retornar lista vazia

          return res.json({

            departments: [],

            pagination: {

              current: page,

              pages: 0,

              total: 0,

              limit: limit

            }

          });

        }



        // Filtrar apenas pelos departamentos do usu√°rio + empresa

        conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

        if (allowedDepartmentIds.length > 0) {

          conditions.push(inArray(departmentsSchema.id, allowedDepartmentIds));

        }

      } else {

        // Usu√°rios n√£o-admin sempre veem apenas sua empresa (fallback)

        if (sessionCompanyId) {

          conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

        } else {

          return res.status(403).json({ message: "Acesso negado: ID da empresa n√£o encontrado na sess√£o." });

        }

      }



      if (active_only) {

        conditions.push(eq(departmentsSchema.is_active, true));

      }



      // Filtro por busca (nome ou descri√ß√£o)

      if (search) {

        const searchCondition = or(

          ilike(departmentsSchema.name, `%${search}%`),

          ilike(departmentsSchema.description, `%${search}%`)

        );

        if (searchCondition) {

          conditions.push(searchCondition);

        }

      }



      // Contar total de registros com filtros aplicados

      let countQuery = db

        .select({ count: sql<number>`count(*)`.mapWith(Number) })

        .from(departmentsSchema);



      if (conditions.length > 0) {

        countQuery = countQuery.where(and(...conditions)) as typeof countQuery;

      }



      const [{ count: totalCount }] = await countQuery;



      // Calcular offset para pagina√ß√£o

      const offset = (page - 1) * limit;



      // Se for admin, incluir informa√ß√µes da empresa

      if (userRole === 'admin') {

        const departments = await db.query.departments.findMany({

          where: conditions.length > 0 ? and(...conditions) : undefined,

          orderBy: [asc(departmentsSchema.name)], // Ordena√ß√£o alfab√©tica

          limit: limit,

          offset: offset,

          with: {

            company: {

              columns: {

                id: true,

                name: true,

              }

            }

          }

        });

        

        const totalPages = Math.ceil(totalCount / limit);

        

        res.json({

          departments,

          pagination: {

            current: page,

            pages: totalPages,

            total: totalCount,

            limit: limit

          }

        });

      } else {

        // Para outros usu√°rios, buscar sem informa√ß√µes da empresa

        let queryBuilder = db

          .select()

          .from(departmentsSchema);



        if (conditions.length > 0) {

          queryBuilder = queryBuilder.where(and(...conditions)) as typeof queryBuilder;

        }



        const departments = await queryBuilder

          .orderBy(asc(departmentsSchema.name)) // Ordena√ß√£o alfab√©tica

          .limit(limit)

          .offset(offset);

        

        const totalPages = Math.ceil(totalCount / limit);

        

        res.json({

          departments,

          pagination: {

            current: page,

            pages: totalPages,

            total: totalCount,

            limit: limit

          }

        });

      }

    } catch (error) {

      console.error("Error fetching departments:", error);

      res.status(500).json({ message: "Failed to fetch departments" });

    }

  });



  // Rota para buscar um √∫nico departamento pelo ID

  router.get(

    "/departments/:id",

    authRequired,

    async (req: Request, res: Response) => {

      try {

        const { id } = req.params;

        const company_id = req.session.companyId;

        if (!company_id) {

          return res.status(400).json({ message: "Company ID is required" });

        }



        const department = await db

          .select()

          .from(departmentsSchema)

          .where(

            and(

              eq(departmentsSchema.id, parseInt(id, 10)),

              eq(departmentsSchema.company_id, company_id)

            )

          )

          .limit(1);



        if (department.length === 0) {

          return res.status(404).json({ message: "Department not found" });

        }

        res.json(department[0]);

      } catch (error) {

        console.error("Error fetching department:", error);

        res.status(500).json({ message: "Failed to fetch department" });

      }

    }

  );



  // Rota para criar um novo departamento

  router.post(

    "/departments",

    authRequired,

    authorize(['admin', 'company_admin', 'manager']), 

    async (req: Request, res: Response) => {

      try {

        const { name, description, is_active, company_id: company_id_from_body, sla_mode, satisfaction_survey_enabled } = req.body;

        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        let effectiveCompanyId: number;



        if (userRole === 'admin') {

          if (company_id_from_body === undefined || company_id_from_body === null) {

            return res.status(400).json({ message: "Para administradores, o campo company_id √© obrigat√≥rio no corpo da requisi√ß√£o ao criar um departamento." });

          }

          // TODO: Validar se a company_id_from_body existe na tabela companies

          effectiveCompanyId = company_id_from_body;

        } else if (userRole === 'company_admin') {

          // Company_admin s√≥ pode criar departamentos para sua pr√≥pria empresa

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Company_admin n√£o possui uma empresa associada na sess√£o." });

          }

          effectiveCompanyId = sessionCompanyId;

          if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

            console.warn("Company_admin tentou especificar um company_id diferente do seu na cria√ß√£o do departamento. A√ß√£o ignorada, usando o company_id da sess√£o.");

          }

        } else if (userRole === 'manager') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Manager n√£o possui uma empresa associada na sess√£o." });

          }

          effectiveCompanyId = sessionCompanyId;

          if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

            console.warn("Manager tentou especificar um company_id diferente do seu na cria√ß√£o do departamento. A√ß√£o ignorada, usando o company_id da sess√£o.");

          }

        } else {

          // Este caso n√£o deve ser alcan√ßado devido ao middleware authorize

          return res.status(403).json({ message: "Acesso negado." });

        }



        if (!name) {

          return res.status(400).json({ message: "Nome do departamento √© obrigat√≥rio." });

        }



        // Verificar se j√° existe um departamento com o mesmo nome na mesma empresa

        const [existingDepartment] = await db

          .select()

          .from(departmentsSchema)

          .where(and(

            eq(departmentsSchema.name, name),

            eq(departmentsSchema.company_id, effectiveCompanyId)

          ));

        

        if (existingDepartment) {

          return res.status(409).json({ message: `J√° existe um departamento com o nome "${name}" nesta empresa.` });

        }



        // Validar sla_mode se enviado

        let slaModeToUse: 'type' | 'category' = 'type';

        if (sla_mode !== undefined) {

          if (sla_mode !== 'type' && sla_mode !== 'category') {

            return res.status(400).json({ message: "Valor inv√°lido para sla_mode. Use 'type' ou 'category'." });

          }

          slaModeToUse = sla_mode;

        }



        const newDepartment = await db

          .insert(departmentsSchema)

          .values({

            name,

            description,

            company_id: effectiveCompanyId,

            is_active: is_active !== undefined ? is_active : true,

            sla_mode: slaModeToUse,

            satisfaction_survey_enabled: satisfaction_survey_enabled !== undefined ? satisfaction_survey_enabled : false,

            created_at: new Date(),

            updated_at: new Date(),

          })

          .returning();

        res.status(201).json(newDepartment[0]);

      } catch (error) {

        console.error("Error creating department:", error);

        if (error instanceof z.ZodError) {

          return res.status(400).json({

            message: "Validation failed",

            errors: error.errors,

          });

        }

        res.status(500).json({ message: "Failed to create department" });

      }

    }

  );



  // Rota para atualizar um departamento existente

  router.put(

    "/departments/:id",

    authRequired,

    authorize(['admin', 'company_admin', 'manager']), // Pap√©is que podem acessar a rota

    async (req: Request, res: Response) => {

      try {

        const departmentIdParam = parseInt(req.params.id, 10);

        if (isNaN(departmentIdParam)) {

          return res.status(400).json({ message: "ID de departamento inv√°lido." });

        }



        const { name, description, is_active, company_id: new_company_id, sla_mode, satisfaction_survey_enabled } = req.body; // Captura company_id, sla_mode e satisfaction_survey_enabled do corpo

        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        const updatePayload: any = { updated_at: new Date() };



        if (name !== undefined) updatePayload.name = name;

        if (description !== undefined) updatePayload.description = description;

        if (is_active !== undefined) updatePayload.is_active = is_active;

        if (sla_mode !== undefined) {

          if (sla_mode !== 'type' && sla_mode !== 'category') {

            return res.status(400).json({ message: "Valor inv√°lido para sla_mode. Use 'type' ou 'category'." });

          }

          updatePayload.sla_mode = sla_mode;

        }

        if (satisfaction_survey_enabled !== undefined) updatePayload.satisfaction_survey_enabled = satisfaction_survey_enabled;



        const conditions: SQLWrapper[] = [eq(departmentsSchema.id, departmentIdParam)];



        if (userRole === 'admin') {

          // Admin pode tentar mudar o company_id do departamento

          if (new_company_id !== undefined) {

            updatePayload.company_id = new_company_id;

          }

          // Nenhuma condi√ß√£o de company_id no WHERE para admin, ele pode editar qualquer depto pelo ID.

        } else if (userRole === 'manager') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Manager deve ter um ID de empresa na sess√£o." });

          }

          // Manager s√≥ pode editar departamentos da sua pr√≥pria empresa.

          conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

          // Manager n√£o pode mudar o company_id do departamento.

          if (new_company_id !== undefined) {

            console.warn("Manager tentou alterar company_id do departamento. Esta a√ß√£o foi ignorada.");

          }

        } else if (userRole === 'company_admin') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Company_admin deve ter um ID de empresa na sess√£o." });

          }

          // Company_admin s√≥ pode editar departamentos da sua pr√≥pria empresa.

          conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

          // Company_admin n√£o pode mudar o company_id do departamento.

          if (new_company_id !== undefined) {

            console.warn("Company_admin tentou alterar company_id do departamento. Esta a√ß√£o foi ignorada.");

          }

        } else {

          return res.status(403).json({ message: "Acesso negado." });

        }



        const updatedDepartment = await db

          .update(departmentsSchema)

          .set(updatePayload)

          .where(and(...conditions))

          .returning();



        if (updatedDepartment.length === 0) {

          return res

            .status(404)

            .json({ message: "Departamento n√£o encontrado ou n√£o autorizado para esta opera√ß√£o." });

        }

        res.json(updatedDepartment[0]);

      } catch (error) {

        console.error("Error updating department:", error);

        if (error instanceof z.ZodError) {

          return res.status(400).json({

            message: "Validation failed",

            errors: error.errors,

          });

        }

        res.status(500).json({ message: "Failed to update department" });

      }

    }

  );



  // Rota para excluir um departamento

  router.delete(

    "/departments/:id",

    authRequired,

    authorize(['admin', 'manager', 'company_admin']), // Incluir company_admin

    async (req: Request, res: Response) => {

      try {

        const departmentIdParam = parseInt(req.params.id, 10);

        if (isNaN(departmentIdParam)) {

          return res.status(400).json({ message: "ID de departamento inv√°lido." });

        }



        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        // Primeiro, verificar se o departamento existe e a qual empresa pertence

        const [departmentToDelete] = await db

          .select({ id: departmentsSchema.id, company_id: departmentsSchema.company_id, name: departmentsSchema.name })

          .from(departmentsSchema)

          .where(eq(departmentsSchema.id, departmentIdParam));



        if (!departmentToDelete) {

          return res.status(404).json({ message: "Departamento n√£o encontrado." });

        }



        const conditions: SQLWrapper[] = [eq(departmentsSchema.id, departmentIdParam)];



        if (userRole === 'manager') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Manager deve ter um ID de empresa na sess√£o para excluir departamentos." });

          }

          // Manager s√≥ pode excluir departamentos da sua empresa

          if (departmentToDelete.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Manager n√£o tem permiss√£o para excluir este departamento." });

          }

          conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

        } else if (userRole === 'company_admin') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Company_admin deve ter um ID de empresa na sess√£o para excluir departamentos." });

          }

          // Company_admin s√≥ pode excluir departamentos da sua empresa

          if (departmentToDelete.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Company_admin n√£o tem permiss√£o para excluir este departamento." });

          }

          conditions.push(eq(departmentsSchema.company_id, sessionCompanyId));

        } else if (userRole === 'admin') {

          // Admin pode excluir departamento de qualquer empresa, a condi√ß√£o √© apenas o ID do departamento.

        } else {

          return res.status(403).json({ message: "Acesso negado." });

        }



        // Verificar v√≠nculos antes de deletar

        const [ticketLink] = await db.select({ count: sql<number>`count(*)`.mapWith(Number) })

                                       .from(schema.tickets)

                                       .where(eq(schema.tickets.department_id, departmentIdParam));

        if(ticketLink && ticketLink.count > 0) {

            return res.status(400).json({ 

              message: `Departamento n√£o pode ser exclu√≠do pois est√° vinculado a ${ticketLink.count} chamado(s).` 

            });

        }



        // Verificar v√≠nculos com tipos de incidente

        const [incidentTypeLink] = await db.select({ count: sql<number>`count(*)`.mapWith(Number) })

                                           .from(schema.incidentTypes)

                                           .where(eq(schema.incidentTypes.department_id, departmentIdParam));

        if(incidentTypeLink && incidentTypeLink.count > 0) {

            return res.status(400).json({ 

              message: `Departamento n√£o pode ser exclu√≠do pois est√° vinculado a ${incidentTypeLink.count} tipo(s) de chamado.` 

            });

        }



        // Verificar v√≠nculos com oficial_departments

        const [officialDepartmentLink] = await db.select({ count: sql<number>`count(*)`.mapWith(Number) })

                                                 .from(schema.officialDepartments)

                                                 .where(eq(schema.officialDepartments.department_id, departmentIdParam));

        if(officialDepartmentLink && officialDepartmentLink.count > 0) {

            return res.status(400).json({ 

              message: `Departamento n√£o pode ser exclu√≠do pois est√° vinculado a ${officialDepartmentLink.count} oficial(is).` 

            });

        }



        // Verificar v√≠nculos com categorias

        const [categoryLink] = await db.select({ count: sql<number>`count(*)`.mapWith(Number) })

                                      .from(schema.categories)

                                      .where(eq(schema.categories.department_id, departmentIdParam));

        if(categoryLink && categoryLink.count > 0) {

            return res.status(400).json({ 

              message: `Departamento n√£o pode ser exclu√≠do pois est√° vinculado a ${categoryLink.count} categoria(s).` 

            });

        }



        const deleteResult = await db

          .delete(departmentsSchema)

          .where(and(...conditions))

          .returning(); // Para saber se algo foi realmente deletado



        if (deleteResult.length === 0) {

          return res

            .status(404)

            .json({ message: "Departamento n√£o encontrado ou n√£o autorizado para exclus√£o." });

        }



        res.status(200).json({ message: "Departamento exclu√≠do com sucesso." });

      } catch (error: any) {

        console.error("Error deleting department:", error);

        

        // Verificar se o erro √© por viola√ß√£o de FK

        if (error && typeof error === 'object' && 'code' in error && error.code === '23503') {

          // Identificar qual tabela causou a viola√ß√£o de FK

          const constraint = error.constraint || '';

          let specificMessage = "Departamento n√£o pode ser exclu√≠do pois possui v√≠nculos existentes.";

          

          if (constraint.includes('tickets')) {

            specificMessage = "Departamento n√£o pode ser exclu√≠do pois possui chamados vinculados.";

          } else if (constraint.includes('incident_types')) {

            specificMessage = "Departamento n√£o pode ser exclu√≠do pois possui tipos de chamado vinculados.";

          } else if (constraint.includes('official_departments')) {

            specificMessage = "Departamento n√£o pode ser exclu√≠do pois possui oficiais vinculados.";

          } else if (constraint.includes('categories')) {

            specificMessage = "Departamento n√£o pode ser exclu√≠do pois possui categorias vinculadas.";

          }

          

          return res.status(400).json({ message: specificMessage });

        }

        

        // Outros tipos de erro

        if (error && typeof error === 'object' && 'message' in error) {

          return res.status(500).json({ 

            message: "Erro ao excluir departamento",

            details: error.message 

          });

        }

        

        res.status(500).json({ 

          message: "Erro interno ao excluir departamento. Tente novamente mais tarde." 

        });

      }

    }

  );



  // --- ROTAS DE EMPRESAS ---

  router.get("/companies", authRequired, adminRequired, async (req: Request, res: Response) => {

    console.log('[/API/COMPANIES] Session no in√≠cio da rota:', JSON.stringify(req.session)); // Mantendo o log original dos middlewares

    try {

        // Verificar conex√£o com o banco

        const testConnection = await db.select().from(schema.companies).limit(1);

        

        // Buscar todas as empresas

        const companies = await db.select().from(schema.companies).orderBy(desc(schema.companies.id));

        

        res.json(companies);

    } catch (error) {

        console.error("[ERROR] Erro completo ao buscar empresas:", error);

        res.status(500).json({ 

            message: "Erro interno ao buscar empresas",

            error: error instanceof Error ? error.message : String(error)

        });

    }

  });



  // Criar nova empresa

  router.post("/companies", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { name, email, domain, cnpj, phone, active = true } = req.body;



      // Valida√ß√µes b√°sicas

      if (!name || !email) {

        return res.status(400).json({ message: "Nome e email s√£o obrigat√≥rios" });

      }



      // Verificar se j√° existe empresa com este CNPJ

      if (cnpj) {

        const [existingCompany] = await db

          .select()

          .from(schema.companies)

          .where(eq(schema.companies.cnpj, cnpj));



        if (existingCompany) {

          return res.status(409).json({ message: "J√° existe uma empresa com este CNPJ" });

        }

      }



      // Criar nova empresa

      const [newCompany] = await db

        .insert(schema.companies)

        .values({

          name,

          email,

          domain: domain || null,

          cnpj: cnpj || null,

          phone: phone || null,

          active: active === false ? false : true,

          created_at: new Date(),

          updated_at: new Date()

        })

        .returning();



      res.status(201).json(newCompany);

    } catch (error) {

      console.error("Erro ao criar empresa:", error);

      res.status(500).json({ message: "Erro interno ao criar empresa" });

    }

  });



  // Atualizar empresa existente

  router.put("/companies/:id", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const companyId = parseInt(req.params.id);

      if (isNaN(companyId)) {

        return res.status(400).json({ message: "ID da empresa inv√°lido" });

      }



      const { name, email, domain, cnpj, phone, active } = req.body;



      // Verificar se a empresa existe

      const [existingCompany] = await db

        .select()

        .from(schema.companies)

        .where(eq(schema.companies.id, companyId));



      if (!existingCompany) {

        return res.status(404).json({ message: "Empresa n√£o encontrada" });

      }



      // Verificar se j√° existe outra empresa com este CNPJ

      if (cnpj && cnpj !== existingCompany.cnpj) {

        const [duplicateCnpj] = await db

          .select()

          .from(schema.companies)

          .where(and(

            eq(schema.companies.cnpj, cnpj),

            ne(schema.companies.id, companyId)

          ));



        if (duplicateCnpj) {

          return res.status(409).json({ message: "J√° existe outra empresa com este CNPJ" });

        }

      }



      // Montar objeto de atualiza√ß√£o

      const updateData: Record<string, any> = {};

      if (name !== undefined) updateData.name = name;

      if (email !== undefined) updateData.email = email;

      if (domain !== undefined) updateData.domain = domain;

      if (cnpj !== undefined) updateData.cnpj = cnpj;

      if (phone !== undefined) updateData.phone = phone;

      if (active !== undefined) updateData.active = active;

      updateData.updated_at = new Date();



      // Atualizar empresa

      const [updatedCompany] = await db

        .update(schema.companies)

        .set(updateData)

        .where(eq(schema.companies.id, companyId))

        .returning();



      res.json(updatedCompany);

    } catch (error) {

      console.error("Erro ao atualizar empresa:", error);

      res.status(500).json({ message: "Erro interno ao atualizar empresa" });

    }

  });



  // Alternar status da empresa (ativar/desativar)

  router.put("/companies/:id/toggle-status", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const companyId = parseInt(req.params.id);

      if (isNaN(companyId)) {

        return res.status(400).json({ message: "ID da empresa inv√°lido" });

      }



      // Obter empresa atual

      const [existingCompany] = await db

        .select()

        .from(schema.companies)

        .where(eq(schema.companies.id, companyId));



      if (!existingCompany) {

        return res.status(404).json({ message: "Empresa n√£o encontrada" });

      }



      // Inverter status

      const newStatus = !existingCompany.active;



      // Atualizar status

      const [updatedCompany] = await db

        .update(schema.companies)

        .set({

          active: newStatus,

          updated_at: new Date()

        })

        .where(eq(schema.companies.id, companyId))

        .returning();



      res.json(updatedCompany);

    } catch (error) {

      console.error("Erro ao alterar status da empresa:", error);

      res.status(500).json({ message: "Erro interno ao alterar status da empresa" });

    }

  });



  // Rota para atualizar um Tipo de Chamado (Incident Type) existente

  router.put(

    "/incident-types/:id",

    authRequired,

    authorize(['admin', 'manager', 'company_admin', 'supervisor']),

    async (req: Request, res: Response) => {

      try {

        const incidentTypeId = parseInt(req.params.id, 10);

        if (isNaN(incidentTypeId)) {

          return res.status(400).json({ message: "ID de tipo de chamado inv√°lido." });

        }



        const { name, value, description, department_id, company_id: new_company_id_from_body, is_active } = req.body;

        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId; // This is number | undefined



        const updatePayload: any = { updated_at: new Date() };

        if (name !== undefined) updatePayload.name = name;

        if (value !== undefined) updatePayload.value = value;

        if (description !== undefined) updatePayload.description = description;

        if (department_id !== undefined) updatePayload.department_id = department_id;

        if (is_active !== undefined) updatePayload.is_active = is_active;



        const conditions: SQLWrapper[] = [eq(schema.incidentTypes.id, incidentTypeId)];

        

        // Fetch the current incident type to know its original company_id

        const [currentIncidentType] = await db

          .select({ id: schema.incidentTypes.id, company_id: schema.incidentTypes.company_id })

          .from(schema.incidentTypes)

          .where(eq(schema.incidentTypes.id, incidentTypeId));



        if (!currentIncidentType) {

          return res.status(404).json({ message: "Tipo de chamado n√£o encontrado." });

        }



        let effectiveCompanyIdForUpdateLogic: number | null; // This will be number or null for logic checks



        if (userRole === 'admin') {

          if (new_company_id_from_body !== undefined) { // Admin explicitly wants to change company_id

            updatePayload.company_id = new_company_id_from_body; // Can be number or null

            effectiveCompanyIdForUpdateLogic = new_company_id_from_body;

          } else {

            // Admin is not changing company_id, so use the original one for logic checks

            effectiveCompanyIdForUpdateLogic = currentIncidentType.company_id;

          }

          // Admin can edit any incident type, so `conditions` only has the ID check.

        } else if (userRole === 'manager') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Manager deve ter um ID de empresa na sess√£o." });

          }

          // Manager can edit types belonging to their company OR global types.

          if (currentIncidentType.company_id !== null && currentIncidentType.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Manager n√£o pode editar este tipo de chamado espec√≠fico da empresa." });

          }

          // Add condition to ensure manager only updates their own company's types or global ones

          const managerCondition = or(

              isNull(schema.incidentTypes.company_id), 

              eq(schema.incidentTypes.company_id, sessionCompanyId)

          );

          if (managerCondition) { // Check if or() returned a valid SQLWrapper

            conditions.push(managerCondition);

          } else {

            // This case should ideally not happen if `or` is always given valid conditions

            console.error("Error generating manager condition for incident type update");

            return res.status(500).json({ message: "Erro interno ao processar permiss√µes." });

          }

          

          // Manager cannot change company_id. If sent in body, it's ignored.

          if (new_company_id_from_body !== undefined && new_company_id_from_body !== currentIncidentType.company_id) {

            console.warn("Manager tentou alterar company_id do tipo de chamado. Esta a√ß√£o foi ignorada. O company_id original ser√° mantido.");

          }

          effectiveCompanyIdForUpdateLogic = currentIncidentType.company_id; // Use original for department/name checks

          // updatePayload.company_id is NOT set for manager, so it remains unchanged.

        } else if (userRole === 'company_admin') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Company Admin n√£o est√° associado a nenhuma empresa." });

          }

          effectiveCompanyIdForUpdateLogic = sessionCompanyId; // Company Admin sempre usa o seu companyId da sess√£o

        } else if (userRole === 'supervisor') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Supervisor deve ter um ID de empresa na sess√£o." });

          }

          // Supervisor pode editar tipos pertencentes √† sua empresa OU tipos globais.

          if (currentIncidentType.company_id !== null && currentIncidentType.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Supervisor n√£o pode editar este tipo de chamado espec√≠fico da empresa." });

          }

          // Adicionar condi√ß√£o para garantir que supervisor s√≥ atualize tipos da sua empresa ou globais

          const supervisorCondition = or(

              isNull(schema.incidentTypes.company_id), 

              eq(schema.incidentTypes.company_id, sessionCompanyId)

          );

          if (supervisorCondition) {

            conditions.push(supervisorCondition);

          } else {

            console.error("Error generating supervisor condition for incident type update");

            return res.status(500).json({ message: "Erro interno ao processar permiss√µes." });

          }

          

          // Supervisor n√£o pode alterar company_id. Se enviado no body, √© ignorado.

          if (new_company_id_from_body !== undefined && new_company_id_from_body !== currentIncidentType.company_id) {

            console.warn("Supervisor tentou alterar company_id do tipo de chamado. Esta a√ß√£o foi ignorada. O company_id original ser√° mantido.");

          }

          effectiveCompanyIdForUpdateLogic = currentIncidentType.company_id; // Usar original para verifica√ß√µes de departamento/nome

        } else {

          return res.status(403).json({ message: "Acesso negado." });

        }

        

        // Valida√ß√£o do department_id

        if (department_id !== undefined) {

          if (effectiveCompanyIdForUpdateLogic !== null) { // Tipo de chamado √©/ser√° espec√≠fico de uma empresa

            const [department] = await db.select()

                                         .from(departmentsSchema)

                                         .where(and(eq(departmentsSchema.id, department_id), eq(departmentsSchema.company_id, effectiveCompanyIdForUpdateLogic)));

            if(!department){

                return res.status(400).json({ message: `Departamento ID ${department_id} n√£o encontrado ou n√£o pertence √† empresa ID ${effectiveCompanyIdForUpdateLogic}.` });

            }

          } else { // Tipo de chamado √©/ser√° global

            const [department] = await db.select().from(departmentsSchema).where(eq(departmentsSchema.id, department_id));

            if(!department){ // Se global, o depto precisa existir, mas n√£o precisa ser global (pode pertencer a uma empresa)

                return res.status(400).json({ message: `Departamento ID ${department_id} n√£o encontrado.`});

            }

          }

        }



        // Verificar duplicidade de nome se o nome estiver sendo alterado

        if (name !== undefined) {

            const duplicateCheckConditions: SQLWrapper[] = [

                eq(schema.incidentTypes.name, name),

                ne(schema.incidentTypes.id, incidentTypeId)

            ];

            if (effectiveCompanyIdForUpdateLogic === null) {

                duplicateCheckConditions.push(isNull(schema.incidentTypes.company_id));

            } else {

                duplicateCheckConditions.push(eq(schema.incidentTypes.company_id, effectiveCompanyIdForUpdateLogic));

            }

            const [existingIncidentTypeWithName] = await db.select().from(schema.incidentTypes).where(and(...duplicateCheckConditions));

            if (existingIncidentTypeWithName) {

                return res.status(409).json({ message: `J√° existe um tipo de chamado com o nome "${name}" ${effectiveCompanyIdForUpdateLogic === null ? 'globalmente' : 'nesta empresa'}.` });

            }

        }



        const updatedIncidentType = await db

          .update(schema.incidentTypes)

          .set(updatePayload)

          .where(and(...conditions))

          .returning();



        if (updatedIncidentType.length === 0) {

          return res.status(404).json({ message: "Tipo de chamado n√£o encontrado ou n√£o autorizado para esta opera√ß√£o." });

        }

        res.json(updatedIncidentType[0]);

      } catch (error: any) {

        console.error("Error updating incident type:", error);

        if (error instanceof z.ZodError) {

          return res.status(400).json({ message: "Validation failed", errors: error.errors });

        }

        if (error && error.code === '23503' && error.constraint && error.constraint.includes('incident_types_department_id_fkey')) {

            return res.status(400).json({ message: "Department ID inv√°lido ou n√£o existente ao atualizar."});

        }

        res.status(500).json({ message: "Failed to update incident type" });

      }

    }

  );



  // Rota para excluir um Tipo de Chamado (Incident Type)

  router.delete(

    "/incident-types/:id",

    authRequired,

    authorize(['admin', 'manager', 'company_admin', 'supervisor']),

    async (req: Request, res: Response) => {

      try {

        const incidentTypeId = parseInt(req.params.id, 10);

        if (isNaN(incidentTypeId)) {

          return res.status(400).json({ message: "ID de tipo de chamado inv√°lido." });

        }



        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        // Primeiro, verificar a qual empresa (se houver) o tipo de chamado pertence

        const [incidentTypeToDelete] = await db

          .select({ id: schema.incidentTypes.id, company_id: schema.incidentTypes.company_id })

          .from(schema.incidentTypes)

          .where(eq(schema.incidentTypes.id, incidentTypeId));



        if (!incidentTypeToDelete) {

          return res.status(404).json({ message: "Tipo de chamado n√£o encontrado." });

        }



        const conditions: SQLWrapper[] = [eq(schema.incidentTypes.id, incidentTypeId)];



        if (userRole === 'manager') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Manager deve ter um ID de empresa na sess√£o para excluir." });

          }

          // Manager s√≥ pode excluir tipos da sua empresa ou tipos globais.

          // Se o tipo n√£o √© global E n√£o pertence √† empresa do manager, negar.

          if (incidentTypeToDelete.company_id !== null && incidentTypeToDelete.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Manager n√£o tem permiss√£o para excluir este tipo de chamado espec√≠fico da empresa." });

          }

          // Adiciona a condi√ß√£o para garantir que o manager s√≥ delete da sua empresa ou globais

           const managerDeleteCondition = or(

              isNull(schema.incidentTypes.company_id),

              eq(schema.incidentTypes.company_id, sessionCompanyId)

            );

            if (managerDeleteCondition) {

                conditions.push(managerDeleteCondition);

            } else {

                console.error("Error generating manager condition for incident type delete");

                return res.status(500).json({ message: "Erro interno ao processar permiss√µes." });

            }

        } else if (userRole === 'admin') {

          // Admin pode excluir qualquer tipo, condi√ß√£o j√° tem o ID.

        } else if (userRole === 'company_admin') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Company Admin deve ter um ID de empresa na sess√£o para excluir." });

          }

          // Company Admin pode excluir tipos da sua empresa OU tipos globais

          if (incidentTypeToDelete.company_id !== null && incidentTypeToDelete.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Company Admin n√£o tem permiss√£o para excluir este tipo de chamado espec√≠fico da empresa." });

          }

          // Adiciona a condi√ß√£o para garantir que o company_admin s√≥ delete da sua empresa ou globais

          const companyAdminDeleteCondition = or(

            isNull(schema.incidentTypes.company_id),

            eq(schema.incidentTypes.company_id, sessionCompanyId)

          );

          if (companyAdminDeleteCondition) {

            conditions.push(companyAdminDeleteCondition);

          } else {

            console.error("Error generating company_admin condition for incident type delete");

            return res.status(500).json({ message: "Erro interno ao processar permiss√µes." });

          }

        } else if (userRole === 'supervisor') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: "Supervisor deve ter um ID de empresa na sess√£o para excluir." });

          }

          // Supervisor s√≥ pode excluir tipos da sua empresa ou tipos globais.

          if (incidentTypeToDelete.company_id !== null && incidentTypeToDelete.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "Supervisor n√£o tem permiss√£o para excluir este tipo de chamado espec√≠fico da empresa." });

          }

          // Adiciona a condi√ß√£o para garantir que o supervisor s√≥ delete da sua empresa ou globais

           const supervisorDeleteCondition = or(

              isNull(schema.incidentTypes.company_id),

              eq(schema.incidentTypes.company_id, sessionCompanyId)

            );

            if (supervisorDeleteCondition) {

                conditions.push(supervisorDeleteCondition);

            } else {

                console.error("Error generating supervisor condition for incident type delete");

                return res.status(500).json({ message: "Erro interno ao processar permiss√µes." });

            }

        } else {

          return res.status(403).json({ message: "Acesso negado." });

        }



        // Verificar v√≠nculos antes de deletar (Ex: tickets)

        const [ticketLink] = await db.select({ count: sql<number>`count(*)`.mapWith(Number) })

                                       .from(schema.tickets)

                                       .where(eq(schema.tickets.incident_type_id, incidentTypeId));

        if(ticketLink && ticketLink.count > 0) {

            return res.status(400).json({ message: "Tipo de chamado n√£o pode ser exclu√≠do pois est√° vinculado a chamados existentes." });

        }

        // Adicionar mais verifica√ß√µes de FK aqui conforme necess√°rio



        const deleteResult = await db

          .delete(schema.incidentTypes)

          .where(and(...conditions))

          .returning(); 



        if (deleteResult.length === 0) {

          return res.status(404).json({ message: "Tipo de chamado n√£o encontrado ou n√£o autorizado para exclus√£o (ap√≥s verifica√ß√£o de permiss√£o)." });

        }

        res.status(200).json({ message: "Tipo de chamado exclu√≠do com sucesso." });

      } catch (error: any) {

        console.error("Error deleting incident type:", error);

        if (error && typeof error === 'object' && 'code' in error && error.code === '23503') { 

          return res.status(400).json({ message: "Tipo de chamado n√£o pode ser exclu√≠do devido a v√≠nculos existentes (erro de banco de dados)." });

        }

        res.status(500).json({ message: "Failed to delete incident type" });

      }

    }

  );



  // === ROTAS DE TICKET TYPES ===

  

  // GET /api/ticket-types - Listar tipos de chamado

  router.get("/ticket-types", authRequired, async (req: Request, res: Response) => {

    try {

      // Par√¢metros de pagina√ß√£o

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50;

      const search = (req.query.search as string) || '';

      const active_only = req.query.active_only === "true";

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const department_id = req.query.department_id ? parseInt(req.query.department_id as string) : null;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;

      const sessionUserId = req.session.userId;



      // Verificar se o usu√°rio tem uma empresa associada (exceto admin)

      if (!sessionCompanyId && userRole !== 'admin') {

        return res.status(400).json({ message: "Usu√°rio sem empresa associada" });

      }



      const conditions: SQLWrapper[] = [];



      // L√≥gica de filtro por empresa

      if (userRole === 'admin') {

        // Admin pode filtrar por empresa espec√≠fica ou ver todas

        if (filterCompanyId) {

          conditions.push(eq(schema.ticketTypes.company_id, filterCompanyId));

        }

      } else if (userRole === 'company_admin') {

        // Company_admin v√™ todos os tipos da sua empresa

        if (sessionCompanyId) {

          conditions.push(eq(schema.ticketTypes.company_id, sessionCompanyId));

        }

             } else if (['manager', 'supervisor', 'support'].includes(userRole)) {

         // Manager/Supervisor/Support veem apenas tipos dos seus departamentos

         if (sessionCompanyId && sessionUserId) {

           // Buscar o official do usu√°rio

           const [userOfficial] = await db.select().from(schema.officials).where(eq(schema.officials.user_id, sessionUserId));

           

           if (userOfficial) {

             // Buscar departamentos do oficial

             const userDepartments = await db.select({ department_id: schema.officialDepartments.department_id })

               .from(schema.officialDepartments)

               .where(eq(schema.officialDepartments.official_id, userOfficial.id));

             

             if (userDepartments.length > 0) {

               const departmentIds = userDepartments.map(dept => dept.department_id);

               

               conditions.push(

                 and(

                   eq(schema.ticketTypes.company_id, sessionCompanyId),

                   inArray(schema.ticketTypes.department_id, departmentIds)

                 )

               );

             } else {

               // Se o usu√°rio n√£o tem departamentos, n√£o deve ver nada

               conditions.push(sql`1 = 0`);

             }

           } else {

             // Se n√£o h√° official, n√£o deve ver nada

             conditions.push(sql`1 = 0`);

           }

         }

      } else {

        return res.status(403).json({ message: "Acesso negado" });

      }



      if (active_only) {

        conditions.push(eq(schema.ticketTypes.is_active, true));

      }



      if (department_id) {

        conditions.push(eq(schema.ticketTypes.department_id, department_id));

      }



      // Filtro por busca (nome ou descri√ß√£o)

      if (search) {

        const searchCondition = or(

          ilike(schema.ticketTypes.name, `%${search}%`),

          ilike(schema.ticketTypes.description, `%${search}%`)

        );

        if (searchCondition) {

          conditions.push(searchCondition);

        }

      }



      // Contar total de registros com filtros aplicados

      let countQuery = db

        .select({ count: sql<number>`count(*)`.mapWith(Number) })

        .from(schema.ticketTypes);



      if (conditions.length > 0) {

        countQuery = countQuery.where(and(...conditions)) as typeof countQuery;

      }



      const [{ count: totalCount }] = await countQuery;



      // Calcular offset para pagina√ß√£o

      const offset = (page - 1) * limit;



      // Buscar tipos de chamado com informa√ß√µes do departamento

      const ticketTypes = await db.query.ticketTypes.findMany({

        where: conditions.length > 0 ? and(...conditions) : undefined,

        orderBy: [asc(schema.ticketTypes.name)],

        limit: limit,

        offset: offset,

        with: {

          department: {

            columns: {

              id: true,

              name: true,

            }

          },

          company: userRole === 'admin' ? {

            columns: {

              id: true,

              name: true,

            }

          } : undefined

        }

      });

      

      const totalPages = Math.ceil(totalCount / limit);

      

      return res.json({

        ticketTypes: ticketTypes,

        pagination: {

          current: page,

          pages: totalPages,

          total: totalCount,

          limit: limit

        }

      });

    } catch (error) {

      console.error('Erro ao obter tipos de chamado:', error);

      res.status(500).json({ message: "Falha ao buscar tipos de chamado", error: String(error) });

    }

  });



  // POST /api/ticket-types - Criar um novo tipo de chamado

  router.post(

    "/ticket-types",

    authRequired,

    authorize(['admin', 'manager', 'company_admin', 'supervisor']),

    async (req: Request, res: Response) => {

      try {

        const { name, value, description, department_id, company_id: company_id_from_body, is_active } = req.body;

        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        let effectiveCompanyId: number | null = null;



        if (userRole === 'admin') {

          if (company_id_from_body !== undefined) {

            effectiveCompanyId = company_id_from_body;

          }

        } else if (['company_admin', 'manager', 'supervisor'].includes(userRole)) {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: `${userRole} n√£o possui uma empresa associada na sess√£o.` });

          }

          effectiveCompanyId = sessionCompanyId;

          if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

            console.warn(`${userRole} tentou especificar um company_id diferente do seu na cria√ß√£o do tipo de chamado.`);

          }

        } else {

          return res.status(403).json({ message: "Acesso negado." });

        }



        if (!name || !value) {

          return res.status(400).json({ message: "Nome e Valor do tipo de chamado s√£o obrigat√≥rios." });

        }

        if (department_id === undefined) {

          return res.status(400).json({ message: "Department ID √© obrigat√≥rio." });

        }

        

        // Verificar se o department_id pertence √† empresa

        if (effectiveCompanyId !== null && department_id) {

          const [department] = await db.select().from(schema.departments).where(and(eq(schema.departments.id, department_id), eq(schema.departments.company_id, effectiveCompanyId)));

          if (!department) {

            return res.status(400).json({ message: `Departamento ID ${department_id} n√£o encontrado ou n√£o pertence √† empresa ID ${effectiveCompanyId}.` });

          }

        }



        // Verificar duplicidade

        const existingConditions: SQLWrapper[] = [eq(schema.ticketTypes.name, name)];

        if (effectiveCompanyId !== null) {

          existingConditions.push(eq(schema.ticketTypes.company_id, effectiveCompanyId));

        } else {

          existingConditions.push(isNull(schema.ticketTypes.company_id));

        }



        const [existing] = await db.select().from(schema.ticketTypes).where(and(...existingConditions));

        if (existing) {

          return res.status(400).json({ message: "J√° existe um tipo de chamado com este nome para esta empresa." });

        }



        // Verificar duplicidade do valor

        const existingValueConditions: SQLWrapper[] = [eq(schema.ticketTypes.value, value)];

        if (effectiveCompanyId !== null) {

          existingValueConditions.push(eq(schema.ticketTypes.company_id, effectiveCompanyId));

        } else {

          existingValueConditions.push(isNull(schema.ticketTypes.company_id));

        }



        const [existingValue] = await db.select().from(schema.ticketTypes).where(and(...existingValueConditions));

        if (existingValue) {

          return res.status(400).json({ message: "J√° existe um tipo de chamado com este valor para esta empresa." });

        }



        // Criar tipo de chamado

        const [newTicketType] = await db

          .insert(schema.ticketTypes)

          .values({

            name,

            value,

            description: description || null,

            department_id,

            company_id: effectiveCompanyId,

            is_active: is_active !== undefined ? is_active : true,

            created_at: new Date(),

            updated_at: new Date(),

          })

          .returning();



        res.status(201).json(newTicketType);

      } catch (error: any) {

        console.error("Error creating ticket type:", error);

        res.status(500).json({ message: "Failed to create ticket type" });

      }

    }

  );



  // PUT /api/ticket-types/:id - Atualizar um tipo de chamado

  router.put(

    "/ticket-types/:id",

    authRequired,

    authorize(['admin', 'manager', 'company_admin', 'supervisor']),

    async (req: Request, res: Response) => {

      try {

        const ticketTypeId = parseInt(req.params.id);

        if (isNaN(ticketTypeId)) {

          return res.status(400).json({ message: "ID do tipo de chamado inv√°lido." });

        }



        const { name, value, description, department_id, is_active } = req.body;

        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        // Verificar se o tipo de chamado existe

        const [ticketTypeToUpdate] = await db

          .select()

          .from(schema.ticketTypes)

          .where(eq(schema.ticketTypes.id, ticketTypeId));



        if (!ticketTypeToUpdate) {

          return res.status(404).json({ message: "Tipo de chamado n√£o encontrado." });

        }



        // Verificar permiss√µes

        if (userRole !== 'admin') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: `${userRole} deve ter um ID de empresa na sess√£o.` });

          }

          if (ticketTypeToUpdate.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "N√£o √© poss√≠vel editar tipo de chamado de outra empresa." });

          }

        }



        // Validar departamento se fornecido

        if (department_id && department_id !== ticketTypeToUpdate.department_id) {

          const effectiveCompanyId = userRole === 'admin' ? ticketTypeToUpdate.company_id : sessionCompanyId;

          

          if (effectiveCompanyId !== null) {

            const [department] = await db.select().from(schema.departments).where(and(eq(schema.departments.id, department_id), eq(schema.departments.company_id, effectiveCompanyId)));

            if (!department) {

              return res.status(400).json({ message: `Departamento ID ${department_id} n√£o encontrado ou n√£o pertence √† empresa.` });

            }

          }

        }



        // Verificar duplicidade de nome se alterado

        if (name && name !== ticketTypeToUpdate.name) {

          const existingConditions: SQLWrapper[] = [

            eq(schema.ticketTypes.name, name),

            ne(schema.ticketTypes.id, ticketTypeId)

          ];

          

          if (ticketTypeToUpdate.company_id !== null) {

            existingConditions.push(eq(schema.ticketTypes.company_id, ticketTypeToUpdate.company_id));

          } else {

            existingConditions.push(isNull(schema.ticketTypes.company_id));

          }



          const [existing] = await db.select().from(schema.ticketTypes).where(and(...existingConditions));

          if (existing) {

            return res.status(400).json({ message: "J√° existe um tipo de chamado com este nome para esta empresa." });

          }

        }



        // Verificar duplicidade de valor se alterado

        if (value && value !== ticketTypeToUpdate.value) {

          const existingValueConditions: SQLWrapper[] = [

            eq(schema.ticketTypes.value, value),

            ne(schema.ticketTypes.id, ticketTypeId)

          ];

          

          if (ticketTypeToUpdate.company_id !== null) {

            existingValueConditions.push(eq(schema.ticketTypes.company_id, ticketTypeToUpdate.company_id));

          } else {

            existingValueConditions.push(isNull(schema.ticketTypes.company_id));

          }



          const [existingValue] = await db.select().from(schema.ticketTypes).where(and(...existingValueConditions));

          if (existingValue) {

            return res.status(400).json({ message: "J√° existe um tipo de chamado com este valor para esta empresa." });

          }

        }



        // Atualizar tipo de chamado

        const updateData: any = { updated_at: new Date() };

        if (name !== undefined) updateData.name = name;

        if (value !== undefined) updateData.value = value;

        if (description !== undefined) updateData.description = description;

        if (department_id !== undefined) updateData.department_id = department_id;

        if (is_active !== undefined) updateData.is_active = is_active;



        const [updatedTicketType] = await db

          .update(schema.ticketTypes)

          .set(updateData)

          .where(eq(schema.ticketTypes.id, ticketTypeId))

          .returning();



        res.json(updatedTicketType);

      } catch (error: any) {

        console.error("Error updating ticket type:", error);

        res.status(500).json({ message: "Failed to update ticket type" });

      }

    }

  );



  // DELETE /api/ticket-types/:id - Desativar um tipo de chamado

  router.delete(

    "/ticket-types/:id",

    authRequired,

    authorize(['admin', 'manager', 'company_admin', 'supervisor']),

    async (req: Request, res: Response) => {

      try {

        const ticketTypeId = parseInt(req.params.id);

        if (isNaN(ticketTypeId)) {

          return res.status(400).json({ message: "ID do tipo de chamado inv√°lido." });

        }



        const userRole = req.session.userRole as string;

        const sessionCompanyId = req.session.companyId;



        // Verificar se o tipo de chamado existe

        const [ticketTypeToDelete] = await db

          .select()

          .from(schema.ticketTypes)

          .where(eq(schema.ticketTypes.id, ticketTypeId));



        if (!ticketTypeToDelete) {

          return res.status(404).json({ message: "Tipo de chamado n√£o encontrado." });

        }



        // Verificar permiss√µes

        if (userRole !== 'admin') {

          if (!sessionCompanyId) {

            return res.status(403).json({ message: `${userRole} deve ter um ID de empresa na sess√£o.` });

          }

          if (ticketTypeToDelete.company_id !== sessionCompanyId) {

            return res.status(403).json({ message: "N√£o √© poss√≠vel excluir tipo de chamado de outra empresa." });

          }

        }



        // Verificar v√≠nculos antes de deletar (tickets)

        const [ticketLink] = await db.select({ count: sql<number>`count(*)`.mapWith(Number) })

          .from(schema.tickets)

          .where(eq(schema.tickets.type, ticketTypeToDelete.value));

          

        if (ticketLink && ticketLink.count > 0) {

          return res.status(400).json({ message: "Tipo de chamado n√£o pode ser exclu√≠do pois est√° vinculado a chamados existentes." });

        }



        // Desativar em vez de excluir

        const [updatedTicketType] = await db

          .update(schema.ticketTypes)

          .set({

            is_active: false,

            updated_at: new Date(),

          })

          .where(eq(schema.ticketTypes.id, ticketTypeId))

          .returning();



        res.status(200).json({ message: "Tipo de chamado desativado com sucesso.", ticketType: updatedTicketType });

      } catch (error: any) {

        console.error("Error deleting ticket type:", error);

        if (error && typeof error === 'object' && 'code' in error && error.code === '23503') { 

          return res.status(400).json({ message: "Tipo de chamado n√£o pode ser exclu√≠do devido a v√≠nculos existentes." });

        }

        res.status(500).json({ message: "Failed to delete ticket type" });

      }

    }

  );



  // === ROTAS DE CATEGORIAS ===

  

  // GET /api/categories - Listar categorias

  router.get("/categories", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor', 'support', 'viewer', 'customer']), async (req: Request, res: Response) => {

    try {

      const page = parseInt(req.query.page as string) || 1;

      const limit = parseInt(req.query.limit as string) || 50;

      const search = (req.query.search as string) || '';

      const active_only = req.query.active_only === "true";

      const filterCompanyId = req.query.company_id ? parseInt(req.query.company_id as string) : null;

      const incident_type_id = req.query.incident_type_id ? parseInt(req.query.incident_type_id as string) : null;

      const context = (req.query.context as string) || '';

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;

      const sessionUserId = req.session.userId;



      // Verificar se o usu√°rio tem uma empresa associada (exceto admin)

      if (!sessionCompanyId && userRole !== 'admin') {

        return res.status(400).json({ message: "Usu√°rio sem empresa associada" });

      }



      const conditions: SQLWrapper[] = [];



      // Suporte ao contexto de cria√ß√£o de ticket: liberar categorias da empresa, sem restringir por departamentos do atendente

      if (context === 'create_ticket') {

        let effectiveCompanyId: number | null = null;

        if (userRole === 'admin') {

          effectiveCompanyId = filterCompanyId ?? null;

          if (!effectiveCompanyId) {

            return res.status(400).json({ message: "Para context=create_ticket, admin deve informar company_id." });

          }

        } else {

          effectiveCompanyId = sessionCompanyId ?? null;

          if (!effectiveCompanyId) {

            return res.status(403).json({ message: "Acesso negado: ID da empresa n√£o encontrado na sess√£o." });

          }

        }



        // Filtros obrigat√≥rios por empresa (e ativos se solicitado)

        conditions.push(eq(schema.categories.company_id, effectiveCompanyId));

        if (active_only) {

          conditions.push(eq(schema.categories.is_active, true));

        }

        if (incident_type_id) {

          conditions.push(eq(schema.categories.incident_type_id, incident_type_id));

        }



        // Filtro por busca (opcional)

        if (search) {

          const searchCondition = or(

            ilike(schema.categories.name, `%${search}%`),

            ilike(schema.categories.description, `%${search}%`)

          );

          conditions.push(searchCondition);

        }



        // Query principal com JOIN para trazer dados do tipo de incidente

        const offset = (page - 1) * limit;

        const categoriesQuery = db

          .select({

            id: schema.categories.id,

            name: schema.categories.name,

            description: schema.categories.description,

            incident_type_id: schema.categories.incident_type_id,

            company_id: schema.categories.company_id,

            is_active: schema.categories.is_active,

            created_at: schema.categories.created_at,

            updated_at: schema.categories.updated_at,

            incident_type_name: schema.incidentTypes.name,

            department_id: schema.incidentTypes.department_id,

            department_name: schema.departments.name,

          })

          .from(schema.categories)

          .leftJoin(schema.incidentTypes, eq(schema.categories.incident_type_id, schema.incidentTypes.id))

          .leftJoin(schema.departments, eq(schema.incidentTypes.department_id, schema.departments.id))

          .where(and(...conditions))

          .orderBy(desc(schema.categories.created_at))

          .limit(limit)

          .offset(offset);



        const countQuery = db

          .select({ count: sql<number>`count(*)`.mapWith(Number) })

          .from(schema.categories)

          .leftJoin(schema.incidentTypes, eq(schema.categories.incident_type_id, schema.incidentTypes.id))

          .where(and(...conditions));



        const [categories, countResult] = await Promise.all([

          categoriesQuery,

          countQuery

        ]);



        const total = countResult[0]?.count || 0;

        const totalPages = Math.ceil(total / limit);



        return res.json({

          categories,

          pagination: {

            current: page,

            pages: totalPages,

            total,

            limit,

          },

        });

      }



      // L√≥gica de filtro por empresa (com restri√ß√µes por papel)

      if (userRole === 'admin') {

        // Admin pode filtrar por empresa espec√≠fica ou ver todas

        if (filterCompanyId) {

          conditions.push(eq(schema.categories.company_id, filterCompanyId));

        }

      } else if (userRole === 'company_admin') {

        // Company_admin v√™ todas as categorias da sua empresa

        if (sessionCompanyId) {

          conditions.push(eq(schema.categories.company_id, sessionCompanyId));

        }

      } else if (['manager', 'supervisor', 'support', 'viewer'].includes(userRole)) {

        // Manager/Supervisor/Support/Viewer veem apenas categorias dos seus departamentos

        if (sessionCompanyId && sessionUserId) {

          // Buscar o official do usu√°rio

          const [userOfficial] = await db.select().from(schema.officials).where(eq(schema.officials.user_id, sessionUserId));

          

          if (userOfficial) {

            // Buscar departamentos do oficial

            const userDepartments = await db.select({ department_id: schema.officialDepartments.department_id })

              .from(schema.officialDepartments)

              .where(eq(schema.officialDepartments.official_id, userOfficial.id));

            

            if (userDepartments.length > 0) {

              const departmentIds = userDepartments.map(dept => dept.department_id);

              

              // Buscar tipos de incidente dos departamentos do usu√°rio

              const incidentTypes = await db.select({ id: schema.incidentTypes.id })

                .from(schema.incidentTypes)

                .where(

                  and(

                    eq(schema.incidentTypes.company_id, sessionCompanyId),

                    inArray(schema.incidentTypes.department_id, departmentIds)

                  )

                );

              

              if (incidentTypes.length > 0) {

                const incidentTypeIds = incidentTypes.map(it => it.id);

                conditions.push(

                  and(

                    eq(schema.categories.company_id, sessionCompanyId),

                    inArray(schema.categories.incident_type_id, incidentTypeIds)

                  )

                );

              } else {

                // Se n√£o h√° tipos de incidente, n√£o deve ver nada

                conditions.push(sql`1 = 0`);

              }

            } else {

              // Se o usu√°rio n√£o tem departamentos, n√£o deve ver nada

              conditions.push(sql`1 = 0`);

            }

          } else {

            // Se n√£o h√° official, n√£o deve ver nada

            conditions.push(sql`1 = 0`);

          }

        }

      } else if (userRole === 'customer') {

        // Customer v√™ apenas categorias ativas da sua empresa

        if (sessionCompanyId) {

          conditions.push(

            and(

              eq(schema.categories.company_id, sessionCompanyId),

              eq(schema.categories.is_active, true)

            )

          );

        } else {

          // Se customer n√£o tem empresa, n√£o v√™ nada

          conditions.push(sql`1 = 0`);

        }

      } else {

        return res.status(403).json({ message: "Acesso negado" });

      }



      if (active_only) {

        conditions.push(eq(schema.categories.is_active, true));

      }



      if (incident_type_id) {

        conditions.push(eq(schema.categories.incident_type_id, incident_type_id));

      }



      // Filtro por busca (nome ou descri√ß√£o)

      if (search) {

        const searchCondition = or(

          ilike(schema.categories.name, `%${search}%`),

          ilike(schema.categories.description, `%${search}%`)

        );

        if (searchCondition) {

          conditions.push(searchCondition);

        }

      }



      // Query principal com JOIN para trazer dados do tipo de incidente

      const offset = (page - 1) * limit;

      const categoriesQuery = db

        .select({

          id: schema.categories.id,

          name: schema.categories.name,

          description: schema.categories.description,

          incident_type_id: schema.categories.incident_type_id,

          company_id: schema.categories.company_id,

          is_active: schema.categories.is_active,

          created_at: schema.categories.created_at,

          updated_at: schema.categories.updated_at,

          incident_type_name: schema.incidentTypes.name,

          department_id: schema.incidentTypes.department_id,

          department_name: schema.departments.name,

        })

        .from(schema.categories)

        .leftJoin(schema.incidentTypes, eq(schema.categories.incident_type_id, schema.incidentTypes.id))

        .leftJoin(schema.departments, eq(schema.incidentTypes.department_id, schema.departments.id))

        .where(conditions.length > 0 ? and(...conditions) : undefined)

        .orderBy(asc(schema.categories.name))

        .limit(limit)

        .offset(offset);



      // Query para contar total

      const countQuery = db

        .select({ count: sql<number>`count(*)`.mapWith(Number) })

        .from(schema.categories)

        .leftJoin(schema.incidentTypes, eq(schema.categories.incident_type_id, schema.incidentTypes.id))

        .where(conditions.length > 0 ? and(...conditions) : undefined);



      const [categories, countResult] = await Promise.all([

        categoriesQuery,

        countQuery

      ]);



      const total = countResult[0]?.count || 0;

      const totalPages = Math.ceil(total / limit);



      res.json({

        categories,

        pagination: {

          current: page,

          pages: totalPages,

          total,

          limit,

        },

      });

    } catch (error) {

      console.error("Error fetching categories:", error);

      res.status(500).json({ message: "Falha ao buscar categorias" });

    }

  });



  // POST /api/categories - Criar nova categoria

  router.post("/categories", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { name, description, incident_type_id, company_id } = req.body;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;



      // Valida√ß√µes b√°sicas

      if (!name || !incident_type_id) {

        return res.status(400).json({ message: "Nome e tipo de incidente s√£o obrigat√≥rios" });

      }



      // Determinar company_id efetivo

      let effectiveCompanyId: number | null = null;

      

      if (userRole === 'admin') {

        effectiveCompanyId = company_id || null;

      } else {

        effectiveCompanyId = sessionCompanyId || null;

        if (company_id && company_id !== sessionCompanyId) {

          console.warn(`Usu√°rio ${userRole} tentou especificar company_id ${company_id}, mas ser√° usado o da sess√£o: ${sessionCompanyId}`);

        }

      }



      // Verificar se o tipo de incidente existe e se o usu√°rio tem acesso

      const [incidentType] = await db

        .select()

        .from(schema.incidentTypes)

        .where(eq(schema.incidentTypes.id, incident_type_id));



      if (!incidentType) {

        return res.status(404).json({ message: "Tipo de incidente n√£o encontrado" });

      }



      // Verificar se o usu√°rio tem acesso ao tipo de incidente

      if (userRole !== 'admin') {

        if (incidentType.company_id !== effectiveCompanyId) {

          return res.status(403).json({ message: "Acesso negado ao tipo de incidente" });

        }

      }



      // Verificar se j√° existe uma categoria com o mesmo nome para o tipo de incidente

      const [existingCategory] = await db

        .select()

        .from(schema.categories)

        .where(

          and(

            eq(schema.categories.name, name),

            eq(schema.categories.incident_type_id, incident_type_id),

            eq(schema.categories.company_id, effectiveCompanyId)

          )

        );



      if (existingCategory) {

        return res.status(409).json({ message: "J√° existe uma categoria com este nome para este tipo de incidente" });

      }



      const [category] = await db

        .insert(schema.categories)

        .values({

          name,

          description: description || null,

          incident_type_id,

          company_id: effectiveCompanyId,

          is_active: true,

          created_at: new Date(),

          updated_at: new Date(),

        })

        .returning();



      res.status(201).json(category);

    } catch (error) {

      console.error("Error creating category:", error);

      res.status(500).json({ message: "Falha ao criar categoria" });

    }

  });



  // PUT /api/categories/:id - Atualizar categoria

  router.put("/categories/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const categoryId = parseInt(req.params.id);

      if (isNaN(categoryId)) {

        return res.status(400).json({ message: "ID de categoria inv√°lido" });

      }



      const { name, description, incident_type_id, is_active } = req.body;

      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;



      // Buscar categoria existente

      const [existingCategory] = await db

        .select()

        .from(schema.categories)

        .where(eq(schema.categories.id, categoryId));



      if (!existingCategory) {

        return res.status(404).json({ message: "Categoria n√£o encontrada" });

      }



      // Verificar permiss√µes

      if (userRole !== 'admin') {

        if (existingCategory.company_id !== sessionCompanyId) {

          return res.status(403).json({ message: "Acesso negado" });

        }

      }



      // Se est√° alterando o tipo de incidente, verificar se existe e se tem acesso

      if (incident_type_id && incident_type_id !== existingCategory.incident_type_id) {

        const [incidentType] = await db

          .select()

          .from(schema.incidentTypes)

          .where(eq(schema.incidentTypes.id, incident_type_id));



        if (!incidentType) {

          return res.status(404).json({ message: "Tipo de incidente n√£o encontrado" });

        }



        if (userRole !== 'admin' && incidentType.company_id !== sessionCompanyId) {

          return res.status(403).json({ message: "Acesso negado ao tipo de incidente" });

        }

      }



      // Se est√° alterando o nome, verificar se n√£o h√° conflito

      if (name && name !== existingCategory.name) {

        const [conflictCategory] = await db

          .select()

          .from(schema.categories)

          .where(

            and(

              eq(schema.categories.name, name),

              eq(schema.categories.incident_type_id, incident_type_id || existingCategory.incident_type_id),

              eq(schema.categories.company_id, existingCategory.company_id),

              not(eq(schema.categories.id, categoryId))

            )

          );



        if (conflictCategory) {

          return res.status(409).json({ message: "J√° existe uma categoria com este nome para este tipo de incidente" });

        }

      }



      const [updatedCategory] = await db

        .update(schema.categories)

        .set({

          name: name || existingCategory.name,

          description: description !== undefined ? description : existingCategory.description,

          incident_type_id: incident_type_id || existingCategory.incident_type_id,

          is_active: is_active !== undefined ? is_active : existingCategory.is_active,

          updated_at: new Date(),

        })

        .where(eq(schema.categories.id, categoryId))

        .returning();



      res.json(updatedCategory);

    } catch (error) {

      console.error("Error updating category:", error);

      res.status(500).json({ message: "Falha ao atualizar categoria" });

    }

  });



  // DELETE /api/categories/:id - Excluir categoria

  router.delete("/categories/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const categoryId = parseInt(req.params.id);

      if (isNaN(categoryId)) {

        return res.status(400).json({ message: "ID de categoria inv√°lido" });

      }



      const userRole = req.session?.userRole as string;

      const sessionCompanyId = req.session.companyId;



      // Buscar categoria existente

      const [existingCategory] = await db

        .select()

        .from(schema.categories)

        .where(eq(schema.categories.id, categoryId));



      if (!existingCategory) {

        return res.status(404).json({ message: "Categoria n√£o encontrada" });

      }



      // Verificar permiss√µes

      if (userRole !== 'admin') {

        if (existingCategory.company_id !== sessionCompanyId) {

          return res.status(403).json({ message: "Acesso negado" });

        }

      }



      // Verificar se h√° tickets vinculados √† categoria

      const [ticketLink] = await db

        .select({ count: sql<number>`count(*)`.mapWith(Number) })

        .from(schema.tickets)

        .where(eq(schema.tickets.category_id, categoryId));



      if (ticketLink && ticketLink.count > 0) {

        return res.status(400).json({ message: "Categoria n√£o pode ser exclu√≠da pois est√° vinculada a chamados existentes" });

      }



      await db

        .delete(schema.categories)

        .where(eq(schema.categories.id, categoryId));



      res.json({ message: "Categoria exclu√≠da com sucesso" });

    } catch (error) {

      console.error("Error deleting category:", error);

      res.status(500).json({ message: "Falha ao excluir categoria" });

    }

  });



  // --- ROTAS DE SLA DEFINITIONS ---

  router.get("/settings/sla", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support', 'customer']), async (req: Request, res: Response) => {

    let effectiveCompanyId: number | undefined = undefined; // Inicializada e tipo ajustado

    try {

      const userRole = req.session.userRole as string;

      const sessionCompanyId = req.session.companyId; // Pode ser undefined

      let queryCompanyId = req.query.company_id ? parseInt(req.query.company_id as string, 10) : undefined;



      if (userRole === 'admin') {

        effectiveCompanyId = queryCompanyId; // Admin usa o company_id da query, se fornecido

        if (effectiveCompanyId === undefined) {

          // Se admin n√£o fornecer company_id, pode-se decidir retornar da primeira empresa com SLA

          // ou da empresa do pr√≥prio admin (se ele tiver uma), ou vazio para o frontend solicitar sele√ß√£o.

          // Por agora, retornaremos vazio se n√£o especificado, para for√ßar sele√ß√£o no frontend.

          return res.json([]);

        }

      } else if (userRole === 'manager') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Manager n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId; // Manager sempre usa o seu companyId da sess√£o

      } else if (userRole === 'company_admin') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Company Admin n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId; // Company Admin sempre usa o seu companyId da sess√£o

      } else if (userRole === 'supervisor') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Supervisor n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId; // Supervisor sempre usa o seu companyId da sess√£o

      } else if (userRole === 'support') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Support n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId; // Support sempre usa o seu companyId da sess√£o

      } else if (userRole === 'customer') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Customer n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId; // Customer sempre usa o seu companyId da sess√£o

      } else {

        return res.status(403).json({ message: "Usu√°rio sem permiss√£o para acessar defini√ß√µes de SLA." });

      }



      if (effectiveCompanyId === undefined || isNaN(effectiveCompanyId)) {

        // Se mesmo ap√≥s a l√≥gica acima, n√£o temos um company ID v√°lido (ex: admin n√£o forneceu)

        return res.status(400).json({ message: "ID da empresa n√£o especificado ou inv√°lido." });

      }



      const slaRules = await db

        .select()

        .from(schema.slaDefinitions)

        .where(eq(schema.slaDefinitions.company_id, effectiveCompanyId))

        .orderBy(schema.slaDefinitions.priority); // Ordenar pode ser √∫til, mas prioridades s√£o fixas

      

      // Estruturar a resposta para ser facilmente consumida pelo frontend

      // (ex: um objeto com prioridades como chaves)

      const slaSettings: Record<string, { response_time_hours?: number, resolution_time_hours?: number }> = {};

      

      // Usar prioridades din√¢micas ao inv√©s de enum fixo

      const allPriorities = [...new Set(slaRules.map(r => r.priority))];

      // Fallback para prioridades padr√£o se n√£o houver regras

      const priorities = allPriorities.length > 0 ? allPriorities : ['BAIXA', 'M√âDIA', 'ALTA', 'CR√çTICA'];



      priorities.forEach(prio => {

        const rule = slaRules.find(r => r.priority === prio);

        if (rule) {

          slaSettings[prio] = {

            response_time_hours: rule.response_time_hours,

            resolution_time_hours: rule.resolution_time_hours

          };

        } else {

          // Se n√£o houver regra definida para uma prioridade, pode-se enviar null/undefined ou valores padr√£o

          slaSettings[prio] = { response_time_hours: undefined, resolution_time_hours: undefined }; 

        }

      });



      res.json({ company_id: effectiveCompanyId, settings: slaSettings });



    } catch (error) {

      console.error("Error fetching SLA definitions:", error);

      res.status(500).json({ message: "Falha ao buscar defini√ß√µes de SLA." });

    }

  });



  type DrizzleReturningQuery = any; // Placeholder para tipo de query Drizzle com .returning()

  router.post("/settings/sla", authRequired, authorize(['admin', 'manager', 'company_admin', 'supervisor', 'support']), async (req: Request, res: Response) => {

    let effectiveCompanyId: number | undefined = undefined; // Inicializada e tipo ajustado

    try {

      const userRole = req.session.userRole as string;

      const sessionCompanyId = req.session.companyId;

      const { company_id: company_id_from_body, settings } = req.body;



      if (userRole === 'admin') {

        if (company_id_from_body === undefined || company_id_from_body === null) {

          return res.status(400).json({ message: "Admin deve fornecer company_id no corpo da requisi√ß√£o." });

        }

        effectiveCompanyId = parseInt(company_id_from_body, 10);

        if (isNaN(effectiveCompanyId)) {

            return res.status(400).json({ message: "company_id inv√°lido fornecido no corpo da requisi√ß√£o." });

        }

        const [companyExists] = await db.select({id: schema.companies.id}).from(schema.companies).where(eq(schema.companies.id, effectiveCompanyId));

        if (!companyExists) {

            return res.status(404).json({ message: `Empresa com ID ${effectiveCompanyId} n√£o encontrada.` });

        }

      } else if (userRole === 'manager') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Manager n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId;

        if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

          console.warn("Manager tentou salvar SLA para company_id diferente da sua sess√£o. Usando company_id da sess√£o.");

        }

      } else if (userRole === 'company_admin') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Company Admin n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId;

        if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

          console.warn("Company Admin tentou salvar SLA para company_id diferente da sua sess√£o. Usando company_id da sess√£o.");

        }

      } else if (userRole === 'supervisor') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Supervisor n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId;

        if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

          console.warn("Supervisor tentou salvar SLA para company_id diferente da sua sess√£o. Usando company_id da sess√£o.");

        }

      } else if (userRole === 'support') {

        if (!sessionCompanyId) {

          return res.status(403).json({ message: "Support n√£o est√° associado a nenhuma empresa." });

        }

        effectiveCompanyId = sessionCompanyId;

        if (company_id_from_body !== undefined && company_id_from_body !== sessionCompanyId) {

          console.warn("Support tentou salvar SLA para company_id diferente da sua sess√£o. Usando company_id da sess√£o.");

        }

      } else {

        return res.status(403).json({ message: "Usu√°rio sem permiss√£o para salvar defini√ß√µes de SLA." });

      }



      if (!settings || typeof settings !== 'object') {

        return res.status(400).json({ message: "Formato inv√°lido. 'settings' deve ser um objeto com as prioridades." });

      }



      // Usar prioridades din√¢micas ao inv√©s de enum fixo

      const priorities = Object.keys(settings);

      const results: Array<any> = []; // Tipagem mais expl√≠cita para results



      await db.transaction(async (tx) => {

        for (const priority of priorities) {

          const ruleData = settings[priority];

          

          const existingRule = await tx.query.slaDefinitions.findFirst({

            where: and(

              eq(schema.slaDefinitions.company_id, effectiveCompanyId as number), // Cast para number aqui, pois j√° validamos

              eq(schema.slaDefinitions.priority, priority)

            )

          });



          if (ruleData && ruleData.response_time_hours !== undefined && ruleData.resolution_time_hours !== undefined &&

              ruleData.response_time_hours !== '' && ruleData.resolution_time_hours !== '') {

            

            const response_time_hours = parseInt(ruleData.response_time_hours, 10);

            const resolution_time_hours = parseInt(ruleData.resolution_time_hours, 10);



            if (isNaN(response_time_hours) || response_time_hours < 0) {

              // Lan√ßar erro para abortar a transa√ß√£o

              throw new Error(`Tempo de resposta inv√°lido para prioridade ${priority}. Deve ser um n√∫mero n√£o negativo.`);

            }

            if (isNaN(resolution_time_hours) || resolution_time_hours < 0) {

              // Lan√ßar erro para abortar a transa√ß√£o

              throw new Error(`Tempo de resolu√ß√£o inv√°lido para prioridade ${priority}. Deve ser um n√∫mero n√£o negativo.`);

            }



            let opResult;

            if (existingRule) {

              opResult = await tx.update(schema.slaDefinitions)

                .set({

                  response_time_hours: response_time_hours,

                  resolution_time_hours: resolution_time_hours,

                  updated_at: new Date(),

                })

                .where(eq(schema.slaDefinitions.id, existingRule.id))

                .returning();

              results.push(opResult[0] || { priority, status: 'updated_error' });

            } else {

              opResult = await tx.insert(schema.slaDefinitions)

                .values({

                  company_id: effectiveCompanyId as number, // Cast para number

                  priority: priority, // Agora TEXT aceita qualquer string

                  response_time_hours: response_time_hours,

                  resolution_time_hours: resolution_time_hours,

                  created_at: new Date(),

                  updated_at: new Date(),

                })

                .returning();

              results.push(opResult[0] || { priority, status: 'inserted_error' });

            }

          } else if (existingRule) {

            await tx.delete(schema.slaDefinitions)

              .where(eq(schema.slaDefinitions.id, existingRule.id));

            results.push({ priority, status: 'deleted' });

          } else {

            results.push({ priority, status: 'not_set' });

          }

        }

      }); // Fim da db.transaction

      

      res.status(200).json({ company_id: effectiveCompanyId, outcome: results });



    } catch (error) {

      console.error("Error saving SLA definitions:", error);

      // @ts-ignore: Verificar se o erro √© uma inst√¢ncia de Error para acessar message

      if (error instanceof Error && (error.message.includes('Tempo de resposta inv√°lido') || error.message.includes('Tempo de resolu√ß√£o inv√°lido'))) {

        return res.status(400).json({ message: error.message });

      }

      // @ts-ignore: Acessar error.code e error.constraint se existirem

      if (error && typeof error === 'object' && 'code' in error && error.code === '23503') { 

        // @ts-ignore

        if ('constraint' in error && error.constraint && typeof error.constraint === 'string' && error.constraint.includes('sla_definitions_company_id_fkey')) {

            return res.status(400).json({ message: `ID da empresa ${effectiveCompanyId !== undefined ? effectiveCompanyId : 'desconhecido'} inv√°lido ou n√£o existente.` });

        }

      }

      res.status(500).json({ message: "Falha ao salvar defini√ß√µes de SLA." });

    }

  });



  // --- ROTAS DE CONFIGURA√á√ïES DE NOTIFICA√á√ÉO ---

  // Obter configura√ß√µes de notifica√ß√£o do usu√°rio atual

  router.get("/notification-settings", authRequired, async (req: Request, res: Response) => {

    try {

      const userId = req.session.userId;

      if (!userId) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }



      // Buscar configura√ß√µes existentes do usu√°rio

      const [settings] = await db

        .select()

        .from(schema.userNotificationSettings)

        .where(eq(schema.userNotificationSettings.user_id, userId))

        .limit(1);



      if (!settings) {

        // Se n√£o existe, criar configura√ß√µes padr√£o

        const [newSettings] = await db

          .insert(schema.userNotificationSettings)

          .values({

            user_id: userId,

            created_at: new Date(),

            updated_at: new Date()

          })

          .returning();

        

        return res.json(newSettings);

      }



      res.json(settings);

    } catch (error) {

      console.error("Erro ao buscar configura√ß√µes de notifica√ß√£o:", error);

      res.status(500).json({ message: "Erro interno ao buscar configura√ß√µes de notifica√ß√£o" });

    }

  });



  // Atualizar configura√ß√µes de notifica√ß√£o do usu√°rio atual

  router.put("/notification-settings", authRequired, async (req: Request, res: Response) => {

    try {

      const userId = req.session.userId;

      if (!userId) {

        return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });

      }



      const {

        new_ticket_assigned,

        ticket_status_changed,

        new_reply_received,

        ticket_escalated,

        ticket_due_soon,

        new_customer_registered,

        new_user_created,

        system_maintenance,

        email_notifications,

        notification_hours_start,

        notification_hours_end,

        weekend_notifications,

        digest_frequency

      } = req.body;



      // Valida√ß√µes b√°sicas

      if (notification_hours_start !== undefined) {

        const start = parseInt(notification_hours_start);

        if (isNaN(start) || start < 0 || start > 23) {

          return res.status(400).json({ message: "Hor√°rio de in√≠cio inv√°lido (0-23)" });

        }

      }



      if (notification_hours_end !== undefined) {

        const end = parseInt(notification_hours_end);

        if (isNaN(end) || end < 0 || end > 23) {

          return res.status(400).json({ message: "Hor√°rio de fim inv√°lido (0-23)" });

        }

      }



      if (digest_frequency !== undefined && !['never', 'daily', 'weekly'].includes(digest_frequency)) {

        return res.status(400).json({ message: "Frequ√™ncia de resumo inv√°lida" });

      }



      // Preparar dados para atualiza√ß√£o

      const updateData: Record<string, any> = {

        updated_at: new Date()

      };



      // Adicionar apenas os campos que foram enviados

      if (new_ticket_assigned !== undefined) updateData.new_ticket_assigned = new_ticket_assigned;

      if (ticket_status_changed !== undefined) updateData.ticket_status_changed = ticket_status_changed;

      if (new_reply_received !== undefined) updateData.new_reply_received = new_reply_received;

      if (ticket_escalated !== undefined) updateData.ticket_escalated = ticket_escalated;

      if (ticket_due_soon !== undefined) updateData.ticket_due_soon = ticket_due_soon;

      if (new_customer_registered !== undefined) updateData.new_customer_registered = new_customer_registered;

      if (new_user_created !== undefined) updateData.new_user_created = new_user_created;

      if (system_maintenance !== undefined) updateData.system_maintenance = system_maintenance;

      if (email_notifications !== undefined) updateData.email_notifications = email_notifications;

      if (notification_hours_start !== undefined) updateData.notification_hours_start = parseInt(notification_hours_start);

      if (notification_hours_end !== undefined) updateData.notification_hours_end = parseInt(notification_hours_end);

      if (weekend_notifications !== undefined) updateData.weekend_notifications = weekend_notifications;

      if (digest_frequency !== undefined) updateData.digest_frequency = digest_frequency;



      // Verificar se o usu√°rio j√° tem configura√ß√µes

      const [existingSettings] = await db

        .select()

        .from(schema.userNotificationSettings)

        .where(eq(schema.userNotificationSettings.user_id, userId))

        .limit(1);



      let updatedSettings;

      if (existingSettings) {

        // Atualizar configura√ß√µes existentes

        [updatedSettings] = await db

          .update(schema.userNotificationSettings)

          .set(updateData)

          .where(eq(schema.userNotificationSettings.user_id, userId))

          .returning();

      } else {

        // Criar novas configura√ß√µes

        [updatedSettings] = await db

          .insert(schema.userNotificationSettings)

          .values({

            user_id: userId,

            ...updateData,

            created_at: new Date()

          })

          .returning();

      }



      res.json(updatedSettings);

    } catch (error) {

      console.error("Erro ao atualizar configura√ß√µes de notifica√ß√£o:", error);

      res.status(500).json({ message: "Erro interno ao atualizar configura√ß√µes de notifica√ß√£o" });

    }

  });



  // --- FIM DAS ROTAS DE CONFIGURA√á√ïES DE NOTIFICA√á√ÉO ---



  // --- ROTAS DE ANEXOS DE TICKETS ---



  // Configura√ß√£o do multer para upload em mem√≥ria

  const upload = multer({

    storage: multer.memoryStorage(),

    limits: {

      fileSize: parseInt(process.env.MAX_FILE_SIZE || '10485760'), // 10MB padr√£o

    },

    fileFilter: (req, file, cb) => {

      const allowedTypes = (process.env.ALLOWED_FILE_TYPES || 'pdf,doc,docx,txt,rtf,xls,xlsx,csv,ppt,pptx,sql,db,sqlite,jpg,jpeg,png,gif,bmp,tiff,svg,webp,zip,rar,7z,tar,gz,json,xml,yaml,yml,log,ini,cfg,conf,exe,msi,deb,rpm,mp4,avi,mov,wmv,flv,webm,mp3,wav,flac,aac').split(',');

      const extension = file.originalname.split('.').pop()?.toLowerCase();

      

      if (extension && allowedTypes.includes(extension)) {

        cb(null, true);

      } else {

        cb(new Error(`Tipo de arquivo n√£o permitido. Tipos aceitos: ${allowedTypes.join(', ')}`));

      }

    }

  });



  // Upload de anexo para um ticket

  router.post("/tickets/:ticketId/attachments", authRequired, uploadLimiter, upload.single('file'), validateFileUpload, async (req: Request, res: Response) => {

    try {

      const ticketId = parseInt(req.params.ticketId);

      const userId = req.session.userId!;

      const file = req.file;



      if (!file) {

        return res.status(400).json({ message: "Nenhum arquivo enviado" });

      }



      // Verificar se o ticket existe

      const [ticket] = await db

        .select()

        .from(schema.tickets)

        .where(eq(schema.tickets.id, ticketId))

        .limit(1);



      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // Fazer upload do arquivo

      const fileData = {

        buffer: file.buffer,

        originalName: file.originalname,

        mimeType: file.mimetype,

        size: file.size

      };



      const uploadResult = await s3Service.uploadFile(fileData, ticketId, userId);



      // Salvar metadados no banco

      const [attachment] = await db

        .insert(schema.ticketAttachments)

        .values({

          ticket_id: ticketId,

          user_id: userId,

          filename: uploadResult.filename,

          original_filename: uploadResult.originalFilename,

          file_size: uploadResult.fileSize,

          mime_type: uploadResult.mimeType,

          s3_key: uploadResult.s3Key,

          s3_bucket: uploadResult.bucket,

          uploaded_at: new Date()

        })

        .returning();



      res.status(201).json(attachment);

    } catch (error) {

      console.error('Erro ao fazer upload de anexo:', error);

      if (error instanceof Error) {

        return res.status(400).json({ message: error.message });

      }

      res.status(500).json({ message: "Erro interno ao fazer upload do arquivo" });

    }

  });



  // Gerar URL de download para um anexo

  router.get("/attachments/:attachmentId/download", authRequired, async (req: Request, res: Response) => {

    try {

      const attachmentId = parseInt(req.params.attachmentId);



      // Buscar anexo

      const [attachment] = await db

        .select()

        .from(schema.ticketAttachments)

        .where(

          and(

            eq(schema.ticketAttachments.id, attachmentId),

            eq(schema.ticketAttachments.is_deleted, false)

          )

        )

        .limit(1);



      if (!attachment) {

        return res.status(404).json({ message: "Anexo n√£o encontrado" });

      }



      // Gerar URL de download assinada

      const downloadUrl = await s3Service.getDownloadUrl(attachment.s3_key);



      res.json({

        download_url: downloadUrl,

        filename: attachment.original_filename,

        expires_in: parseInt(process.env.FILE_URL_EXPIRATION || '3600')

      });

    } catch (error) {

      console.error('Erro ao gerar URL de download:', error);

      res.status(500).json({ message: "Erro interno ao gerar URL de download" });

    }

  });



  // Listar anexos de um ticket

  router.get("/tickets/:ticketId/attachments", authRequired, async (req: Request, res: Response) => {

    try {

      const ticketId = parseInt(req.params.ticketId);



      // Verificar se o ticket existe

      const [ticket] = await db

        .select()

        .from(schema.tickets)

        .where(eq(schema.tickets.id, ticketId))

        .limit(1);



      if (!ticket) {

        return res.status(404).json({ message: "Ticket n√£o encontrado" });

      }



      // Buscar anexos n√£o deletados

      const attachments = await db

        .select({

          id: schema.ticketAttachments.id,

          ticket_id: schema.ticketAttachments.ticket_id,

          user_id: schema.ticketAttachments.user_id,

          filename: schema.ticketAttachments.filename,

          original_filename: schema.ticketAttachments.original_filename,

          file_size: schema.ticketAttachments.file_size,

          mime_type: schema.ticketAttachments.mime_type,

          uploaded_at: schema.ticketAttachments.uploaded_at,

          user_name: schema.users.name,

          user_email: schema.users.email

        })

        .from(schema.ticketAttachments)

        .leftJoin(schema.users, eq(schema.ticketAttachments.user_id, schema.users.id))

        .where(

          and(

            eq(schema.ticketAttachments.ticket_id, ticketId),

            eq(schema.ticketAttachments.is_deleted, false)

          )

        )

        .orderBy(desc(schema.ticketAttachments.uploaded_at));



      // Formatar resposta

      const formattedAttachments = attachments.map(attachment => ({

        id: attachment.id,

        ticket_id: attachment.ticket_id,

        user_id: attachment.user_id,

        filename: attachment.filename,

        original_filename: attachment.original_filename,

        file_size: attachment.file_size,

        mime_type: attachment.mime_type,

        uploaded_at: attachment.uploaded_at,

        user: {

          id: attachment.user_id,

          name: attachment.user_name,

          email: attachment.user_email

        }

      }));



      res.json(formattedAttachments);

    } catch (error) {

      console.error('Erro ao buscar anexos:', error);

      res.status(500).json({ message: "Erro interno ao buscar anexos" });

    }

  });



  // Endpoint para testar conex√£o com S3/Wasabi (apenas admins)

  router.get("/test-s3-connection", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const result = await s3Service.testConnection();

      res.json(result);

    } catch (error) {

      console.error('Erro ao testar conex√£o S3:', error);

      res.status(500).json({ 

        success: false, 

        error: "Erro interno ao testar conex√£o" 

      });

    }

  });



  // Endpoints para testar sistema de prioridades flex√≠veis (apenas em desenvolvimento)

  if (process.env.NODE_ENV === 'development') {

    router.get("/priority-test", async (req: Request, res: Response) => {

      try {

        const { testPriorities } = await import('./api/priority-test');

        await testPriorities(req, res);

      } catch (error) {

        console.error('Erro ao executar teste de prioridades:', error);

        res.status(500).json({ 

          success: false, 

          error: "Erro interno ao executar teste" 

        });

      }

    });



    router.get("/priority-test/department/:companyId/:departmentId", async (req: Request, res: Response) => {

      try {

        const { testDepartmentPriorities } = await import('./api/priority-test');

        await testDepartmentPriorities(req, res);

      } catch (error) {

        console.error('Erro ao testar prioridades do departamento:', error);

        res.status(500).json({ 

          success: false, 

          error: "Erro interno ao testar prioridades" 

        });

      }

    });

  }



  // --- ROTAS DE PRIORIDADES FLEX√çVEIS ---

  

  // Listar prioridades de um departamento

  router.get("/departments/:departmentId/priorities", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor', 'support', 'customer']), async (req: Request, res: Response) => {

    try {

      const { getDepartmentPriorities } = await import('./api/priorities');

      await getDepartmentPriorities(req, res);

    } catch (error) {

      console.error('Erro ao buscar prioridades do departamento:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao buscar prioridades" 

      });

    }

  });



  // Criar nova prioridade para um departamento

  router.post("/departments/:departmentId/priorities", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { createDepartmentPriority } = await import('./api/department-priorities');

      await createDepartmentPriority(req, res);

    } catch (error) {

      console.error('Erro ao criar prioridade:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao criar prioridade" 

      });

    }

  });



  // Editar prioridade

  router.put("/departments/:departmentId/priorities/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { updatePriority } = await import('./api/department-priorities');

      await updatePriority(req, res);

    } catch (error) {

      console.error('Erro ao editar prioridade:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao editar prioridade" 

      });

    }

  });



  // Excluir prioridade

  router.delete("/departments/:departmentId/priorities/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { deletePriority } = await import('./api/department-priorities');

      await deletePriority(req, res);

    } catch (error) {

      console.error('Erro ao excluir prioridade:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao excluir prioridade" 

      });

    }

  });



  // Reordenar prioridades

  router.post("/departments/:departmentId/priorities/reorder", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { reorderPriorities } = await import('./api/department-priorities');

      await reorderPriorities(req, res);

    } catch (error) {

      console.error('Erro ao reordenar prioridades:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao reordenar prioridades" 

      });

    }

  });



  // Criar prioridades padr√£o para um departamento

  router.post("/departments/:departmentId/priorities/create-defaults", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { createDefaultPriorities } = await import('./api/priorities');

      await createDefaultPriorities(req, res);

    } catch (error) {

      console.error('Erro ao criar prioridades padr√£o:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao criar prioridades padr√£o" 

      });

    }

  });



  // Buscar todas as prioridades de uma empresa (para SLA Matrix)

  router.get("/department-priorities", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const { getAllCompanyPriorities } = await import('./api/department-priorities');

      await getAllCompanyPriorities(req, res);

    } catch (error) {

      console.error('Erro ao buscar prioridades da empresa:', error);

      res.status(500).json({ 

        success: false, 

        message: "Erro interno ao buscar prioridades da empresa" 

      });

    }

  });







  // Buscar configura√ß√µes de email

  router.get("/email-config", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      let companyId = req.session.companyId;

      

      // Se for admin e especificou company_id na query, usar ele

      if (req.session.userRole === 'admin' && req.query.company_id) {

        companyId = parseInt(req.query.company_id as string);

      }

      

      const config = await emailConfigService.getEmailConfigForFrontend(companyId);

      res.json(config);

    } catch (error) {

      console.error('Erro ao buscar configura√ß√µes de email:', error);

      res.status(500).json({ message: "Erro interno ao buscar configura√ß√µes de email" });

    }

  });



  // Salvar configura√ß√µes de email

  router.post("/email-config", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      let companyId = req.session.companyId;

      const config: any = { ...req.body };

      

      // Se for admin e especificou company_id no body, usar ele

      if (req.session.userRole === 'admin' && config.company_id) {

        companyId = config.company_id;

        // Remover company_id do config antes de salvar

        delete config.company_id;

      }

      

      // Debug: Logar o que est√° chegando

      console.log('[DEBUG] Dados recebidos no backend:', JSON.stringify(config, null, 2));

      console.log('[DEBUG] Company ID usado:', companyId);

      console.log('[DEBUG] Provider:', config.provider);

      console.log('[DEBUG] From email:', config.from_email);

      console.log('[DEBUG] API Key:', config.api_key ? '***mascarado***' : 'vazio');

      

      await emailConfigService.saveEmailConfigFromFrontend(config, companyId);

      

      console.log('[DEBUG] Configura√ß√µes salvas com sucesso!');

      

      res.json({ 

        success: true, 

        message: "Configura√ß√µes de email salvas com sucesso" 

      });

    } catch (error) {

      console.error('Erro ao salvar configura√ß√µes de email:', error);

      res.status(500).json({ message: error instanceof Error ? error.message : "Erro interno ao salvar configura√ß√µes de email" });

    }

  });



  // Buscar templates de email

  router.get("/email-templates", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      let companyId = req.session.companyId;

      const type = req.query.type as string;

      

      // Se for admin e especificou company_id na query, usar ele

      if (req.session.userRole === 'admin' && req.query.company_id) {

        companyId = parseInt(req.query.company_id as string);

      }

      

      const templates = await emailConfigService.getEmailTemplates(companyId, type);

      

      // Se for uma requisi√ß√£o para verificar templates faltantes

      if (req.query.check_missing === 'true') {

        const allTemplateTypes = [

          'new_ticket',

          'ticket_assigned', 

          'ticket_reply',

          'status_changed',

          'ticket_resolved',

          'ticket_escalated',

          'ticket_due_soon',

          'customer_registered',

          'user_created',

          'system_maintenance',

          'ticket_participant_added',

          'ticket_participant_removed'

        ];

        

        const existingTypes = templates.map(t => t.type);

        const missingTypes = allTemplateTypes.filter(type => !existingTypes.includes(type));

        

        res.json({

          templates,

          missing: missingTypes,

          total_expected: allTemplateTypes.length,

          total_existing: templates.length,

          total_missing: missingTypes.length

        });

      } else {

        res.json(templates);

      }

    } catch (error) {

      console.error('Erro ao buscar templates de email:', error);

      res.status(500).json({ message: "Erro interno ao buscar templates de email" });

    }

  });



  // Criar template de email

  router.post("/email-templates", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      let companyId = req.session.companyId;

      const userId = req.session.userId;

      const templateData: any = { ...req.body };

      

      // Se for admin e especificou company_id no body, usar ele

      if (req.session.userRole === 'admin' && templateData.company_id) {

        companyId = templateData.company_id;

        // Remover company_id do templateData antes de salvar

        delete templateData.company_id;

      }

      

      const template = await emailConfigService.saveEmailTemplate({

        ...templateData,

        company_id: companyId,

        created_by_id: userId,

        updated_by_id: userId

      });

      

      res.status(201).json(template);

    } catch (error) {

      console.error('Erro ao criar template de email:', error);

      res.status(500).json({ message: "Erro interno ao criar template de email" });

    }

  });



  // Atualizar template de email

  router.put("/email-templates/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const templateId = parseInt(req.params.id);

      const userId = req.session.userId;

      const templateData: any = { ...req.body };

      

      // Se for admin e especificou company_id no body, remover antes de salvar

      if (req.session.userRole === 'admin' && templateData.company_id) {

        delete templateData.company_id;

      }

      

      const template = await emailConfigService.updateEmailTemplate(templateId, {

        ...templateData,

        updated_by_id: userId

      });

      

      if (!template) {

        return res.status(404).json({ message: "Template n√£o encontrado" });

      }

      

      res.json(template);

    } catch (error) {

      console.error('Erro ao atualizar template de email:', error);

      res.status(500).json({ message: "Erro interno ao atualizar template de email" });

    }

  });



  // Deletar template de email

  router.delete("/email-templates/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const templateId = parseInt(req.params.id);

      

      const success = await emailConfigService.deleteEmailTemplate(templateId);

      

      if (!success) {

        return res.status(404).json({ message: "Template n√£o encontrado" });

      }

      

      res.json({ success: true, message: "Template deletado com sucesso" });

    } catch (error) {

      console.error('Erro ao deletar template de email:', error);

      res.status(500).json({ message: "Erro interno ao deletar template de email" });

    }

  });



  // Criar templates padr√£o de e-mail (modernos)

  router.post("/email-templates/seed-defaults", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      const userId = req.session.userId;

      

      // Para admin, pode receber company_id via body

      let targetCompanyId = companyId;

      if (req.session.userRole === 'admin' && req.body.company_id) {

        targetCompanyId = req.body.company_id;

      }

      

      if (!targetCompanyId) {

        return res.status(400).json({ message: 'Empresa n√£o encontrada.' });

      }



      // Criar templates modernos (apenas se n√£o existirem)

      const defaultTemplates = [

        {

          name: 'Novo Ticket',

          type: 'new_ticket',

          description: 'Notifica√ß√£o enviada quando um novo ticket √© criado',

          subject_template: 'Novo ticket criado: {{ticket.ticket_id}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Novo Ticket Criado</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER (logo ou nome da empresa) -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO / T√çTULO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Novo Ticket Criado</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Um novo ticket foi criado no sistema e requer sua aten√ß√£o.

              </p>

            </td>

          </tr>



          <!-- DETALHES DO TICKET -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Cliente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.name}} ({{customer.email}})</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Prioridade:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.priority_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Status:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.status_text}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;text-decoration:none;padding:14px 28px;border-radius:6px;font-size:15px;font-weight:600;display:inline-block;box-shadow:0 2px 4px rgba(0,0,0,0.1);">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">

                Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.

              </p>

            </td>

          </tr>



        </table><!-- /container -->

      </td>

    </tr>

  </table><!-- /wrapper -->

</body>

</html>`,

          text_template: `Novo ticket criado: {{ticket.ticket_id}}

T√≠tulo: {{ticket.title}}

Cliente: {{customer.name}} ({{customer.email}})

Prioridade: {{ticket.priority_text}}

Status: {{ticket.status_text}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','customer.name','customer.email','ticket.priority_text','ticket.status_text','ticket.link','user.name','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text','system.from_name'])

        },

        {

          name: 'Ticket Atribu√≠do',

          type: 'ticket_assigned',

          description: 'Notifica√ß√£o enviada quando um ticket √© atribu√≠do a um atendente',

          subject_template: 'Ticket {{ticket.ticket_id}} atribu√≠do a voc√™',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Ticket Atribu√≠do</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Ticket Atribu√≠do</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Um ticket foi atribu√≠do a voc√™ e requer sua aten√ß√£o imediata.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Cliente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.name}} ({{customer.email}})</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Prioridade:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.priority_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Status:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.status_text}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- DESCRI√á√ÉO -->

          <tr>

            <td style="padding:0 40px 24px 40px;color:{{system.colors.text}};">

              <div style="background:{{system.colors.accent}};padding:16px;border-radius:6px;border-left:4px solid {{system.colors.primary}};">

                <p style="font-size:15px;margin:0;line-height:1.6;">{{ticket.description}}</p>

              </div>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:600;display:inline-block;font-size:14px;">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">

                Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.

              </p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Ticket atribu√≠do a voc√™: {{ticket.ticket_id}}

T√≠tulo: {{ticket.title}}

Cliente: {{customer.name}} ({{customer.email}})

Prioridade: {{ticket.priority_text}}

Status: {{ticket.status_text}}

Descri√ß√£o: {{ticket.description}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','customer.name','customer.email','ticket.priority_text','ticket.status_text','ticket.description','ticket.link','user.name','system.company_name','system.support_email','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Nova Resposta',

          type: 'ticket_reply',

          description: 'Notifica√ß√£o enviada quando h√° uma nova resposta no ticket',

          subject_template: 'Nova resposta no ticket {{ticket.ticket_id}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Nova Resposta no Ticket</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Nova Resposta no Ticket</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Uma nova resposta foi adicionada ao ticket {{ticket.ticket_id}}.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}} - {{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Respondido por:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{reply.user.name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Data:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{reply.created_at_formatted}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- MENSAGEM -->

          <tr>

            <td style="padding:0 40px 24px 40px;color:{{system.colors.text}};">

              <div style="background:{{system.colors.accent}};padding:16px;border-radius:6px;border-left:4px solid {{system.colors.primary}};">

                <p style="font-size:15px;margin:0;line-height:1.6;">{{reply.message}}</p>

              </div>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:600;display:inline-block;font-size:14px;">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">

                Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.

              </p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Nova resposta no ticket {{ticket.ticket_id}}

Respondido por: {{reply.user.name}}

Data: {{reply.created_at_formatted}}

Mensagem: {{reply.message}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','reply.user.name','reply.created_at_formatted','reply.message','ticket.link','user.name','system.company_name','system.support_email','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Status Alterado',

          type: 'status_changed',

          description: 'Notifica√ß√£o enviada quando o status do ticket √© alterado',

          subject_template: 'Ticket {{ticket.ticket_id}}: Status alterado para {{ticket.status_text}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Status do Ticket Alterado</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Status do Ticket Alterado</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                O status do ticket {{ticket.ticket_id}} foi alterado.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}} - {{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Status anterior:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{status_change.old_status_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Novo status:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{status_change.new_status_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Alterado por:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{status_change.changed_by.name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Data:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{status_change.created_at_formatted}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:600;display:inline-block;font-size:14px;">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">

                Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.

              </p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Status do Ticket Alterado

Ticket: {{ticket.ticket_id}} - {{ticket.title}}

Status anterior: {{status_change.old_status_text}}

Novo status: {{status_change.new_status_text}}

Alterado por: {{status_change.changed_by.name}}

Data: {{status_change.created_at_formatted}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','status_change.old_status_text','status_change.new_status_text','status_change.changed_by.name','status_change.created_at_formatted','ticket.link','user.name','system.company_name','system.support_email','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Ticket Resolvido',

          type: 'ticket_resolved',

          description: 'Notifica√ß√£o enviada quando um ticket √© resolvido',

          subject_template: 'Ticket {{ticket.ticket_id}} foi resolvido',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Ticket Resolvido</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Ticket Resolvido</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Seu ticket foi resolvido com sucesso! Agradecemos por utilizar nosso sistema de suporte.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Resolvido em:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.resolved_at_formatted}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Resolvido por:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{user.name}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:600;display:inline-block;font-size:14px;">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">

                Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.

              </p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Ticket Resolvido

Ticket: {{ticket.ticket_id}}

T√≠tulo: {{ticket.title}}

Resolvido em: {{ticket.resolved_at_formatted}}

Resolvido por: {{user.name}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','ticket.resolved_at_formatted','user.name','ticket.link','system.company_name','system.support_email','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Ticket Escalado',

          type: 'ticket_escalated',

          description: 'Notifica√ß√£o enviada quando um ticket √© escalado',

          subject_template: 'Ticket {{ticket.ticket_id}} foi escalado',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Ticket Escalado</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Ticket Escalado</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                O ticket foi escalado para um n√≠vel superior de atendimento.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Prioridade:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.priority_text}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- MOTIVO -->

          <tr>

            <td style="padding:0 40px 24px 40px;color:{{system.colors.text}};">

              <div style="background:#fff3cd;border:1px solid #ffeaa7;border-radius:6px;padding:16px;margin:0;">

                <p style="font-size:15px;margin:0;color:#856404;line-height:1.6;">

                  <strong>Motivo da Escala√ß√£o:</strong><br>

                  {{system.message}}

                </p>

              </div>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:600;display:inline-block;font-size:14px;">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Ticket Escalado

Ticket: {{ticket.ticket_id}}

T√≠tulo: {{ticket.title}}

Prioridade: {{ticket.priority_text}}

Motivo: {{system.message}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','ticket.priority_text','system.message','ticket.link'])

        },

        {

          name: 'Vencimento Pr√≥ximo',

          type: 'ticket_due_soon',

          description: 'Notifica√ß√£o enviada quando um ticket est√° pr√≥ximo do vencimento',

          subject_template: 'Ticket {{ticket.ticket_id}} pr√≥ximo do vencimento',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Ticket Pr√≥ximo do Vencimento</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Ticket Pr√≥ximo do Vencimento</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Um ticket est√° pr√≥ximo do vencimento e requer aten√ß√£o imediata.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.ticket_id}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Cliente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Prioridade:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.priority_text}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- AVISO -->

          <tr>

            <td style="padding:0 40px 24px 40px;color:{{system.colors.text}};">

              <div style="background:#fff3cd;border:1px solid #ffeaa7;border-radius:6px;padding:16px;margin:0;">

                <p style="font-size:15px;margin:0;color:#856404;line-height:1.6;">

                  <strong>Aten√ß√£o:</strong><br>

                  {{system.message}}

                </p>

              </div>

            </td>

          </tr>



          <!-- CTA -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:600;display:inline-block;font-size:14px;">

                Ver Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Ticket Pr√≥ximo do Vencimento

Aten√ß√£o: {{system.message}}

Ticket: {{ticket.ticket_id}}

T√≠tulo: {{ticket.title}}

Cliente: {{customer.name}}

Prioridade: {{ticket.priority_text}}

Ver Ticket: {{ticket.link}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['ticket.ticket_id','ticket.title','customer.name','ticket.priority_text','system.message','ticket.link'])

        },

        {

          name: 'Cliente Registrado',

          type: 'customer_registered',

          description: 'Notifica√ß√£o enviada quando um novo cliente √© registrado',

          subject_template: 'Novo cliente registrado: {{customer.name}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Novo Cliente Registrado</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Novo Cliente Registrado</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Um novo cliente foi registrado no sistema.

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Nome:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Email:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.email}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Empresa:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.company}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Telefone:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.phone}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Novo Cliente Registrado

Nome: {{customer.name}}

Email: {{customer.email}}

Empresa: {{customer.company}}

Telefone: {{customer.phone}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['customer.name','customer.email','customer.company','customer.phone'])

        },

        {

          name: 'Usu√°rio Criado',

          type: 'user_created',

          description: 'Notifica√ß√£o enviada quando um novo usu√°rio √© criado',

          subject_template: 'Novo usu√°rio criado: {{user.name}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Novo Usu√°rio Criado</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Novo Usu√°rio Criado</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                {{system.message}}

              </p>

            </td>

          </tr>



          <!-- DETALHES -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">Nome:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{user.name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Email:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{user.email}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Fun√ß√£o:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{user.role_text}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Novo Usu√°rio Criado

{{system.message}}

Nome: {{user.name}}

Email: {{user.email}}

Fun√ß√£o: {{user.role_text}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['user.name','user.email','user.role_text','system.message'])

        },

        {

          name: 'Manuten√ß√£o do Sistema',

          type: 'system_maintenance',

          description: 'Notifica√ß√£o enviada para avisar sobre manuten√ß√£o do sistema',

          subject_template: 'Manuten√ß√£o Programada do Sistema',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Manuten√ß√£o Programada</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER (logo ou nome da empresa) -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO / T√çTULO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Manuten√ß√£o Programada</h2>

              <p style="font-size:16px;margin:0;line-height:1.6;">

                {{system.message}}

              </p>

            </td>

          </tr>



          <!-- DETALHES DA MANUTEN√á√ÉO -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">In√≠cio:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{system.maintenance_start}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">T√©rmino previsto:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{system.maintenance_end}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- AVISO IMPORTANTE -->

          <tr>

            <td style="padding:0 40px 32px 40px;color:{{system.colors.text}};">

              <div style="background:#fff3cd;border:1px solid #ffeaa7;border-radius:6px;padding:16px;margin:0;">

                <p style="font-size:15px;margin:0;color:#856404;">

                  <strong>‚ö†Ô∏è Aten√ß√£o:</strong> Durante este per√≠odo, o sistema poder√° ficar indispon√≠vel.

                </p>

              </div>

            </td>

          </tr>



          <!-- MENSAGEM FINAL -->

          <tr>

            <td style="padding:0 40px 32px 40px;color:{{system.colors.text}};">

              <p style="font-size:16px;margin:0;line-height:1.6;">

                Agradecemos a compreens√£o e pedimos desculpas pelos transtornos.

              </p>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>



        </table><!-- /container -->

      </td>

    </tr>

  </table><!-- /wrapper -->

</body>

</html>`,

          text_template: `Manuten√ß√£o Programada

{{system.message}}



In√≠cio: {{system.maintenance_start}}

T√©rmino previsto: {{system.maintenance_end}}



‚ö†Ô∏è Aten√ß√£o: Durante este per√≠odo, o sistema poder√° ficar indispon√≠vel.



Agradecemos a compreens√£o e pedimos desculpas pelos transtornos.



Atenciosamente,

{{system.from_name}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['system.message','system.maintenance_start','system.maintenance_end','system.company_name','system.from_name','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Participante Adicionado',

          type: 'ticket_participant_added',

          description: 'Notifica√ß√£o enviada quando um participante √© adicionado ao ticket',

          subject_template: 'Voc√™ foi adicionado como participante do ticket {{ticket.ticket_id}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Voc√™ foi adicionado como participante</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER (logo ou nome da empresa) -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO / T√çTULO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Voc√™ foi adicionado como participante!</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Voc√™ foi adicionado como participante do ticket <strong>{{ticket.ticket_id}}</strong> por {{official.name}}.

              </p>

            </td>

          </tr>



          <!-- DETALHES DO TICKET -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Status:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.status_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Prioridade:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.priority_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Criado em:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.created_at_formatted}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Cliente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.name}} ({{customer.email}})</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- CTA (link para o ticket) -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;text-decoration:none;padding:12px 24px;border-radius:4px;font-size:15px;font-weight:bold;display:inline-block;">

                Acompanhar Ticket

              </a>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>



        </table><!-- /container -->

      </td>

    </tr>

  </table><!-- /wrapper -->

</body>

</html>`,

          text_template: `Voc√™ foi adicionado como participante!

Ol√° {{user.name}},



Voc√™ foi adicionado como participante do ticket {{ticket.ticket_id}} por {{official.name}}.



Detalhes do Ticket:

- T√≠tulo: {{ticket.title}}

- Status: {{ticket.status_text}}

- Prioridade: {{ticket.priority_text}}

- Criado em: {{ticket.created_at_formatted}}

- Cliente: {{customer.name}} ({{customer.email}})



Para acompanhar este ticket, acesse: {{ticket.link}}



Atenciosamente,

{{system.from_name}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['user.name','ticket.ticket_id','official.name','ticket.title','ticket.status_text','ticket.priority_text','ticket.created_at_formatted','customer.name','customer.email','ticket.link','system.company_name','system.from_name','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Participante Removido',

          type: 'ticket_participant_removed',

          description: 'Notifica√ß√£o enviada quando um participante √© removido do ticket',

          subject_template: 'Voc√™ foi removido como participante do ticket {{ticket.ticket_id}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Voc√™ foi removido do ticket</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER (logo ou nome da empresa) -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO / T√çTULO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:20px;margin:0 0 12px 0;color:{{system.colors.text}};">Voc√™ foi removido como participante</h2>

              <p style="font-size:16px;margin:0;">Ol√° {{user.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;">

                Voc√™ foi removido do ticket <strong>{{ticket.ticket_id}}</strong> por {{official.name}}.

              </p>

            </td>

          </tr>



          <!-- DETALHES DO TICKET -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Status:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.status_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Prioridade:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.priority_text}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Cliente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{customer.name}} ({{customer.email}})</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- CTA opcional (link para o ticket) -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{ticket.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;text-decoration:none;padding:12px 24px;border-radius:4px;font-size:15px;font-weight:bold;display:inline-block;">

                Abrir Ticket

              </a>

            </td>

          </tr>



          <!-- AVISO -->

          <tr>

            <td style="padding:0 40px 32px 40px;color:{{system.colors.text}};">

              <div style="background:#fff3cd;border:1px solid #ffeaa7;border-radius:6px;padding:16px;margin:0;">

                <p style="font-size:15px;margin:0;color:#856404;">

                  Voc√™ n√£o receber√° mais notifica√ß√µes sobre este ticket.

                </p>

              </div>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>



        </table><!-- /container -->

      </td>

    </tr>

  </table><!-- /wrapper -->

</body>

</html>`,

          text_template: `Voc√™ foi removido como participante

Ol√° {{user.name}},



Voc√™ foi removido como participante do ticket {{ticket.ticket_id}} por {{official.name}}.



Detalhes do Ticket:

- T√≠tulo: {{ticket.title}}

- Status: {{ticket.status_text}}

- Prioridade: {{ticket.priority_text}}



Cliente: {{customer.name}} ({{customer.email}})



Voc√™ n√£o receber√° mais notifica√ß√µes sobre este ticket.



Atenciosamente,

{{system.from_name}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['user.name','ticket.ticket_id','official.name','ticket.title','ticket.status_text','ticket.priority_text','customer.name','customer.email','ticket.link','system.company_name','system.from_name','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Pesquisa de Satisfa√ß√£o',

          type: 'satisfaction_survey',

          description: 'Pesquisa de satisfa√ß√£o enviada quando um ticket √© resolvido',

          subject_template: 'Como foi seu atendimento? Avalie o ticket {{ticket.ticket_id}}',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Pesquisa de Satisfa√ß√£o</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <!-- 100% wrapper -->

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">



        <!-- CARD / CONTAINER -->

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">



          <!-- HEADER (logo ou nome da empresa) -->

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>



          <!-- HERO / T√çTULO -->

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:24px;margin:0 0 12px 0;color:{{system.colors.text}};text-align:center;">Como foi seu atendimento?</h2>

              <p style="font-size:16px;margin:0;text-align:center;">Ol√° {{customer.name}},</p>

              <p style="font-size:16px;margin:16px 0 0 0;line-height:1.6;text-align:center;">

                Seu ticket <strong>{{ticket.ticket_id}}</strong> foi resolvido com sucesso!<br>

                Gostar√≠amos muito de saber como foi sua experi√™ncia.

              </p>

            </td>

          </tr>



          <!-- DETALHES DO TICKET -->

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:120px;background:{{system.colors.accent}};color:{{system.colors.text}};">T√≠tulo:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Atendente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.assigned_official_name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Resolvido em:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.resolved_at_formatted}}</td>

                </tr>

              </table>

            </td>

          </tr>



          <!-- CTA PRINCIPAL - Avaliar -->

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <p style="font-size:18px;margin:0 0 20px 0;color:{{system.colors.text}};text-align:center;font-weight:600;">

                Clique abaixo para avaliar seu atendimento:

              </p>

              <a href="{{survey.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;text-decoration:none;padding:16px 32px;border-radius:6px;font-size:18px;font-weight:bold;display:inline-block;box-shadow:0 2px 4px rgba(0,0,0,0.1);">

                ‚≠ê Avaliar Atendimento

              </a>

              <p style="font-size:13px;margin:16px 0 0 0;color:#666666;text-align:center;">

                Leva apenas 1 minuto ‚Ä¢ Expira em 7 dias

              </p>

            </td>

          </tr>



          <!-- INFORMA√á√ÉO ADICIONAL -->

          <tr>

            <td style="padding:0 40px 32px 40px;color:{{system.colors.text}};">

              <div style="background:#f8f9fa;border:1px solid #e9ecef;border-radius:6px;padding:20px;margin:0;">

                <h3 style="font-size:16px;margin:0 0 12px 0;color:{{system.colors.text}};">Por que sua opini√£o √© importante?</h3>

                <p style="font-size:14px;margin:0;color:#666666;line-height:1.6;">

                  Seu feedback nos ajuda a melhorar continuamente nossos servi√ßos e garantir que voc√™ tenha sempre a melhor experi√™ncia poss√≠vel.

                </p>

              </div>

            </td>

          </tr>



          <!-- FOOTER -->

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Atenciosamente,<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Esta √© uma mensagem autom√°tica ‚Äî por favor, n√£o responda a este e-mail.</p>

            </td>

          </tr>



        </table><!-- /container -->

      </td>

    </tr>

  </table><!-- /wrapper -->

</body>

</html>`,

          text_template: `Como foi seu atendimento?



Ol√° {{customer.name}},



Seu ticket {{ticket.ticket_id}} foi resolvido com sucesso!



Detalhes do Ticket:

- T√≠tulo: {{ticket.title}}

- Atendente: {{ticket.assigned_official_name}}

- Resolvido em: {{ticket.resolved_at_formatted}}



Gostar√≠amos muito de saber como foi sua experi√™ncia. Por favor, avalie nosso atendimento clicando no link abaixo:



{{survey.link}}



Sua opini√£o √© muito importante para n√≥s e nos ajuda a melhorar continuamente nossos servi√ßos.



A pesquisa expira em 7 dias e leva apenas 1 minuto para ser preenchida.



Atenciosamente,

{{system.from_name}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['customer.name','ticket.ticket_id','ticket.title','ticket.assigned_official_name','ticket.resolved_at_formatted','survey.link','system.company_name','system.from_name','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        },

        {

          name: 'Lembrete Pesquisa de Satisfacao',

          type: 'satisfaction_survey_reminder',

          description: 'Lembrete enviado antes da expiracao da pesquisa de satisfacao',

          subject_template: 'Ainda da tempo! Sua pesquisa expira em {{survey.days_until_expiration}} dia(s)',

          html_template: `<!DOCTYPE html>

<html lang="pt-BR">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Lembrete de Pesquisa de Satisfacao</title>

</head>



<body style="margin:0;padding:0;background:{{system.colors.background}};">

  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" style="background:{{system.colors.background}};">

    <tr>

      <td align="center" style="padding:24px 12px;">

        <table role="presentation" width="600" cellspacing="0" cellpadding="0"

               style="max-width:600px;background:#ffffff;border-radius:8px;overflow:hidden;font-family:Arial,Helvetica,sans-serif;box-shadow:0 4px 6px rgba(0,0,0,0.1);">

          <tr>

            <td align="center" style="background:{{system.colors.primary}};padding:24px;">

              <h1 style="color:#ffffff;font-size:22px;margin:0;font-weight:600;">{{system.company_name}}</h1>

            </td>

          </tr>

          <tr>

            <td style="padding:32px 40px 16px 40px;color:{{system.colors.text}};">

              <h2 style="font-size:22px;margin:0 0 12px 0;color:{{system.colors.text}};text-align:center;">Ajude-nos com seu feedback</h2>

              <p style="font-size:16px;margin:0;text-align:center;line-height:1.6;">

                O link da sua pesquisa expira em <strong>{{survey.days_until_expiration}} dia(s)</strong>.

              </p>

              <p style="font-size:15px;margin:16px 0 0 0;text-align:center;line-height:1.6;">

                Bastam poucos cliques para compartilhar como foi o atendimento referente ao ticket <strong>{{ticket.ticket_id}}</strong>.

              </p>

            </td>

          </tr>

          <tr>

            <td style="padding:0 40px;">

              <table role="presentation" width="100%" cellspacing="0" cellpadding="0"

                     style="font-size:15px;border-collapse:collapse;margin:0 0 24px 0;background:{{system.colors.secondary}};border-radius:6px;overflow:hidden;">

                <tr>

                  <td style="padding:12px 16px;font-weight:600;width:130px;background:{{system.colors.accent}};color:{{system.colors.text}};">Ticket:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.title}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Atendente:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.assigned_official_name}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Resolvido em:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{ticket.resolved_at_formatted}}</td>

                </tr>

                <tr>

                  <td style="padding:12px 16px;font-weight:600;background:{{system.colors.accent}};color:{{system.colors.text}};">Expira em:</td>

                  <td style="padding:12px 16px;color:{{system.colors.text}};">{{survey.days_until_expiration}} dia(s)</td>

                </tr>

              </table>

            </td>

          </tr>

          <tr>

            <td align="center" style="padding:0 40px 32px 40px;">

              <a href="{{survey.link}}"

                 style="background:{{system.colors.primary}};color:#ffffff;text-decoration:none;padding:16px 32px;border-radius:6px;font-size:18px;font-weight:bold;display:inline-block;box-shadow:0 2px 4px rgba(0,0,0,0.1);">

                Responder agora

              </a>

              <p style="font-size:13px;margin:16px 0 0 0;color:#666666;text-align:center;">

                Se ja tiver respondido, desconsidere este lembrete. O link expira em {{survey.days_until_expiration}} dia(s).

              </p>

            </td>

          </tr>

          <tr>

            <td align="center" style="background:{{system.colors.secondary}};padding:24px;font-size:13px;color:#666666;">

              <p style="margin:0;">Obrigado!<br><strong>{{system.from_name}}</strong></p>

              <p style="margin:8px 0 0 0;font-style:italic;color:#888888;">Mensagem automatica do sistema de tickets.</p>

            </td>

          </tr>

        </table>

      </td>

    </tr>

  </table>

</body>

</html>`,

          text_template: `Ola {{customer.name}},



Seu link para avaliar o ticket {{ticket.ticket_id}} expira em {{survey.days_until_expiration}} dia(s).



Conte com a gente! Compartilhe seu feedback acessando:

{{survey.link}}



Resumo do ticket:

- Titulo: {{ticket.title}}

- Atendente: {{ticket.assigned_official_name}}

- Resolvido em: {{ticket.resolved_at_formatted}}



Obrigado por nos ajudar a melhorar continuamente.



{{system.from_name}}`,

          is_active: true,

          is_default: true,

          available_variables: JSON.stringify(['customer.name','ticket.ticket_id','ticket.title','ticket.assigned_official_name','ticket.resolved_at_formatted','survey.link','survey.days_until_expiration','system.company_name','system.from_name','system.colors.primary','system.colors.secondary','system.colors.accent','system.colors.background','system.colors.text'])

        }

      ];



      // Verificar templates existentes antes de criar

      const existingTemplates = await emailConfigService.getEmailTemplates(targetCompanyId);

      const existingTypes = new Set(existingTemplates.map(t => t.type));

      

      let created = 0;

      let skipped = 0;

      

      // Salvar apenas templates que n√£o existem

      for (const template of defaultTemplates) {

        if (existingTypes.has(template.type)) {

          console.log(`Template ${template.type} j√° existe para empresa ${targetCompanyId}, pulando...`);

          skipped++;

          continue;

        }

        

        try {

          await emailConfigService.saveEmailTemplate({

            ...template,

            company_id: targetCompanyId,

            created_by_id: userId,

            updated_by_id: userId

          });

          created++;

          console.log(`Template ${template.type} criado com sucesso para empresa ${targetCompanyId}`);

        } catch (error) {

          console.error(`Erro ao criar template ${template.type}:`, error);

          // Continuar com os pr√≥ximos templates mesmo se um falhar

        }

      }



      if (created === 0 && skipped > 0) {

        res.json({ 

          success: true, 

          message: `Todos os templates padr√£o j√° existem para esta empresa (${skipped} templates encontrados)`,

          created,

          skipped

        });

      } else {

        res.json({ 

          success: true, 

          message: `Templates padr√£o processados com sucesso (${created} criados, ${skipped} j√° existiam)`,

          created,

          skipped

        });

      }

    } catch (error) {

      console.error('Erro ao criar templates padr√£o de e-mail:', error);

      res.status(500).json({ message: "Erro interno ao criar templates padr√£o de e-mail" });

    }

  });







  // Buscar configura√ß√µes do sistema (incluindo cores da empresa)

  router.get("/system-config", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      

      // Para admin, pode receber company_id via query

      let targetCompanyId = companyId;

      if (req.session.userRole === 'admin' && req.query.company_id) {

        targetCompanyId = parseInt(req.query.company_id as string);

      }

      

      if (!targetCompanyId) {

        return res.status(400).json({ message: 'Empresa n√£o encontrada.' });

      }



      // Buscar configura√ß√µes de cores da empresa

      const colorSettings = await db

        .select()

        .from(schema.systemSettings)

        .where(

          and(

            eq(schema.systemSettings.company_id, targetCompanyId),

            inArray(schema.systemSettings.key, [

              'theme_primary',

              'theme_secondary', 

              'theme_accent',

              'theme_background',

              'theme_text'

            ])

          )

        );



      // Converter para objeto

      const colors: Record<string, string> = {};

      colorSettings.forEach(setting => {

        colors[setting.key] = setting.value;

      });



      // Buscar outras configura√ß√µes da empresa

      const companyName = await getSystemSetting('companyName', 'Sistema de Tickets', targetCompanyId);

      const fromName = await getSystemSetting('from_name', 'Service Desk - Sistema de Chamados', targetCompanyId);

      const fromEmail = await getSystemSetting('from_email', 'noreply@empresa.com', targetCompanyId);



      res.json({

        success: true,

        data: {

          colors,

          company_name: companyName,

          from_name: fromName,

          from_email: fromEmail

        }

      });

    } catch (error) {

      console.error('Erro ao buscar configura√ß√µes do sistema:', error);

      res.status(500).json({ message: "Erro interno ao buscar configura√ß√µes do sistema" });

    }

  });



  // Testar conex√£o de email

  router.post("/email-config/test", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const config: SMTPConfigInput = req.body;

      

      const result = await emailConfigService.testEmailConnection(config);

      

      res.json(result);

    } catch (error) {

      console.error('Erro ao testar conex√£o de email:', error);

      res.status(500).json({ 

        success: false, 

        error: "Erro interno ao testar conex√£o de email" 

      });

    }

  });



  // Rotas para controle do sistema de notifica√ß√µes

  router.post("/notifications/scheduler/start", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { schedulerService } = await import("./services/scheduler-service");

      schedulerService.start();

      res.json({ success: true, message: "Scheduler de notifica√ß√µes iniciado" });

    } catch (error) {

      console.error('Erro ao iniciar scheduler:', error);

      res.status(500).json({ message: "Erro ao iniciar scheduler", error: String(error) });

    }

  });



  router.post("/notifications/scheduler/stop", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { schedulerService } = await import("./services/scheduler-service");

      schedulerService.stop();

      res.json({ success: true, message: "Scheduler de notifica√ß√µes parado" });

    } catch (error) {

      console.error('Erro ao parar scheduler:', error);

      res.status(500).json({ message: "Erro ao parar scheduler", error: String(error) });

    }

  });



  router.get("/notifications/scheduler/status", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { schedulerService } = await import("./services/scheduler-service");

      const isRunning = schedulerService.isSchedulerRunning();

      res.json({ isRunning, message: isRunning ? "Scheduler est√° rodando" : "Scheduler est√° parado" });

    } catch (error) {

      console.error('Erro ao verificar status do scheduler:', error);

      res.status(500).json({ message: "Erro ao verificar status do scheduler", error: String(error) });

    }

  });



  router.post("/notifications/scheduler/check-now", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { schedulerService } = await import("./services/scheduler-service");

      await schedulerService.runManualCheck();

      res.json({ success: true, message: "Verifica√ß√£o manual de tickets executada" });

    } catch (error) {

      console.error('Erro ao executar verifica√ß√£o manual:', error);

      res.status(500).json({ message: "Erro ao executar verifica√ß√£o manual", error: String(error) });

    }

  });



  // Rota para executar digest di√°rio manual

  router.post("/notifications/scheduler/daily-digest", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { schedulerService } = await import("./services/scheduler-service");

      await schedulerService.runManualDailyDigest();

      res.json({ success: true, message: "Digest di√°rio executado manualmente" });

    } catch (error) {

      console.error('Erro ao executar digest di√°rio manual:', error);

      res.status(500).json({ message: "Erro ao executar digest di√°rio manual", error: String(error) });

    }

  });



  // Rota para executar digest semanal manual

  router.post("/notifications/scheduler/weekly-digest", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { schedulerService } = await import("./services/scheduler-service");

      await schedulerService.runManualWeeklyDigest();

      res.json({ success: true, message: "Digest semanal executado manualmente" });

    } catch (error) {

      console.error('Erro ao executar digest semanal manual:', error);

      res.status(500).json({ message: "Erro ao executar digest semanal manual", error: String(error) });

    }

  });



  // Rota para enviar notifica√ß√£o de manuten√ß√£o do sistema

  router.post("/notifications/system-maintenance", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const { maintenance_start, maintenance_end, message, company_id } = req.body;



      if (!maintenance_start || !maintenance_end || !message) {

        return res.status(400).json({ 

          message: "Campos obrigat√≥rios: maintenance_start, maintenance_end, message" 

        });

      }



      const startDate = new Date(maintenance_start);

      const endDate = new Date(maintenance_end);



      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {

        return res.status(400).json({ 

          message: "Datas de manuten√ß√£o inv√°lidas" 

        });

      }



      if (startDate >= endDate) {

        return res.status(400).json({ 

          message: "Data de in√≠cio deve ser anterior √† data de fim" 

        });

      }



      await emailNotificationService.notifySystemMaintenance(

        startDate,

        endDate,

        message,

        company_id || undefined

      );



      res.json({ 

        success: true, 

        message: "Notifica√ß√£o de manuten√ß√£o enviada com sucesso",

        details: {

          start: startDate.toISOString(),

          end: endDate.toISOString(),

          affected_company: company_id || "Todas as empresas"

        }

      });

    } catch (error) {

      console.error('Erro ao enviar notifica√ß√£o de manuten√ß√£o:', error);

      res.status(500).json({ message: "Erro ao enviar notifica√ß√£o de manuten√ß√£o", error: String(error) });

    }

  });



  // Rota para testar notifica√ß√£o de escala√ß√£o manual

  router.post("/notifications/escalate-ticket/:ticketId", authRequired, adminRequired, async (req: Request, res: Response) => {

    try {

      const ticketId = parseInt(req.params.ticketId);

      const { reason } = req.body;



      if (isNaN(ticketId)) {

        return res.status(400).json({ message: "ID de ticket inv√°lido" });

      }



      await emailNotificationService.notifyTicketEscalated(

        ticketId,

        req.session?.userId,

        reason || "Ticket escalado manualmente por administrador"

      );



      res.json({ 

        success: true, 

        message: "Notifica√ß√£o de escala√ß√£o enviada com sucesso" 

      });

    } catch (error) {

      console.error('Erro ao escalar ticket:', error);

      res.status(500).json({ message: "Erro ao escalar ticket", error: String(error) });

    }

  });



  // --- FIM DAS ROTAS DE ANEXOS ---



  // === ROTAS DE SEGURAN√áA E MONITORAMENTO ===

  

  // Health check p√∫blico

  router.get("/health", healthCheck);

  

  // Relat√≥rio de seguran√ßa (apenas admin)

  router.get("/security/report", authRequired, adminRequired, getSecurityReport);

  

  // Estat√≠sticas do sistema (apenas admin)

  router.get("/security/stats", authRequired, adminRequired, getSystemStats);

  

  // Estat√≠sticas de performance (apenas admin)

  router.get("/performance/stats", authRequired, adminRequired, performanceStatsHandler);

  

  // Limpar logs de seguran√ßa (apenas admin)

  router.post("/security/clear-logs", authRequired, adminRequired, clearSecurityLogs);

  

  // Endpoint para for√ßar um evento de seguran√ßa (desenvolvimento/teste)

  router.post("/security/test-event", authRequired, adminRequired, (req: Request, res: Response) => {

    const { event, severity = 'medium', details = {} } = req.body;

    

    if (!event) {

      return res.status(400).json({ message: "Campo 'event' √© obrigat√≥rio" });

    }

    

    logSecurityEvent(

      req.ip || 'unknown',

      req.get('User-Agent') || 'unknown',

      event,

      severity,

      { ...details, testEvent: true, triggeredBy: req.session?.userId }

    );

    

    res.json({ 

      success: true, 

      message: `Evento de seguran√ßa '${event}' registrado com severidade '${severity}'` 

    });

  });



  // --- ROTAS DE IA ---

  

  // Listar configura√ß√µes de IA

  router.get("/ai-configurations", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor', 'customer']), getAiConfigurations);

  

  // Buscar provedores e modelos dispon√≠veis

  router.get("/ai-configurations/providers", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), getAiProviders);

  

  // Endpoints de admin para gerenciar provedores e tokens

  router.get("/ai-configurations/admin/providers", authRequired, authorize(['admin']), getAiProvidersAdmin);

  router.put("/ai-configurations/admin/providers", authRequired, authorize(['admin']), updateAiProvidersAdmin);

  

  // Endpoints de admin para gerenciar permiss√µes de IA das empresas

  router.get("/ai-configurations/admin/companies", authRequired, authorize(['admin']), getAiCompanies);

  router.put("/ai-configurations/admin/companies/:id/permission", authRequired, authorize(['admin']), updateAiCompanyPermission);

  

  // Criar nova configura√ß√£o de IA

  router.post("/ai-configurations", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), createAiConfiguration);

  

  // Atualizar configura√ß√£o de IA

  router.put("/ai-configurations/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), updateAiConfiguration);

  

  // Deletar configura√ß√£o de IA

  router.delete("/ai-configurations/:id", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), deleteAiConfiguration);

  

  // Testar configura√ß√£o de IA

  router.post("/ai-configurations/test", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), testAiConfiguration);



  // --- FIM DAS ROTAS DE IA ---



  // --- ROTAS DE PERMISS√ïES DE EMPRESA ---

  

  // Listar todas as empresas com suas permiss√µes (apenas admin)

  router.get("/companies-permissions", authRequired, authorize(['admin']), getAllCompaniesPermissions);

  

  // Buscar permiss√µes de uma empresa espec√≠fica (apenas admin)

  router.get("/company-permissions/:companyId", authRequired, authorize(['admin']), getCompanyPermissions);

  

  // Atualizar permiss√µes de uma empresa (apenas admin)

  router.put("/company-permissions/:companyId", authRequired, authorize(['admin']), updateCompanyPermissions);

  

  // Buscar configura√ß√µes de uso de IA para company_admin, manager e supervisor

  router.get("/settings/ai-usage", authRequired, authorize(['company_admin', 'manager', 'supervisor']), getAiUsageSettings);

  

  // Atualizar configura√ß√µes de uso de IA para company_admin, manager e supervisor

  router.put("/settings/ai-usage", authRequired, authorize(['company_admin', 'manager', 'supervisor']), updateAiUsageSettings);



  // --- FIM DAS ROTAS DE PERMISS√ïES ---



  // === ROTAS DE RESOLU√á√ÉO DE SLA ===

  

  // Resolver SLA para um ticket

  router.post("/sla/resolve", authRequired, resolveSLA);

router.get("/sla/resolve", authRequired, async (req, res) => {

  // Suporte para GET com query parameters (compatibilidade)

  const { companyId, departmentId, incidentTypeId, categoryId, priority } = req.query;

  

  // Converter para body format e chamar a fun√ß√£o original

  req.body = {

    companyId: parseInt(companyId as string),

    departmentId: parseInt(departmentId as string),

    incidentTypeId: parseInt(incidentTypeId as string),

    categoryId: categoryId ? parseInt(categoryId as string) : undefined,

    priority: priority as string

  };

  

  return resolveSLA(req, res);

});



  // Alias compat√≠vel com cliente legado: /api/sla-resolver

  router.get("/sla-resolver", authRequired, async (req, res) => {

    // Reaproveita a mesma l√≥gica do GET /sla/resolve

    const { companyId, departmentId, incidentTypeId, categoryId, priorityId, priorityName } = req.query as any;

    // Compatibilidade: o hook antigo envia priorityId/priorityName

    req.body = {

      companyId: parseInt(companyId),

      departmentId: parseInt(departmentId),

      incidentTypeId: parseInt(incidentTypeId),

      categoryId: categoryId ? parseInt(categoryId) : undefined,

      priority: priorityId ? parseInt(priorityId) : (priorityName || undefined)

    };

    return resolveSLA(req as any, res as any);

  });



  // Endpoint auxiliar: obter sla_mode de um departamento

  router.get("/departments/:id/sla-mode", authRequired, async (req: Request, res: Response) => {

    try {

      const id = parseInt(req.params.id);

      if (isNaN(id)) {

        return res.status(400).json({ error: 'ID inv√°lido' });

      }

      const [dept] = await db

        .select({ id: departmentsSchema.id, sla_mode: departmentsSchema.sla_mode })

        .from(departmentsSchema)

        .where(eq(departmentsSchema.id, id))

        .limit(1);

      if (!dept) {

        return res.status(404).json({ error: 'Departamento n√£o encontrado' });

      }

      res.json({ id: dept.id, sla_mode: dept.sla_mode });

    } catch (error) {

      console.error('Erro ao obter sla_mode do departamento:', error);

      res.status(500).json({ error: 'Erro interno' });

    }

});

  

  // Estat√≠sticas do cache de SLA (apenas admins)

  router.get("/sla/cache/stats", authRequired, adminRequired, getCacheStats);

  

  // Pr√©-carregar cache de SLA

  router.post("/sla/cache/preload", authRequired, adminRequired, preloadCache);

  

  // Limpar cache expirado

  router.delete("/sla/cache", authRequired, adminRequired, cleanCache);



  // --- FIM DAS ROTAS DE SLA ---



  // === ROTAS DE CONFIGURA√á√ïES SLA ===

  

  // CRUD b√°sico de configura√ß√µes SLA

  router.get("/sla-configurations", authRequired, getSLAConfigurations);

  router.get("/sla-configurations/:id", authRequired, getSLAConfigurationById);

  router.post("/sla-configurations", authRequired, createSLAConfiguration);

  router.put("/sla-configurations/:id", authRequired, updateSLAConfiguration);

  router.delete("/sla-configurations/:id", authRequired, deleteSLAConfiguration);

  

  // Bulk operations

  router.post("/sla-configurations/bulk", authRequired, bulkCreateSLAConfigurations);

  router.put("/sla-configurations/bulk", authRequired, bulkUpdateSLAConfigurations);

  router.delete("/sla-configurations/bulk", authRequired, bulkDeleteSLAConfigurations);

  router.patch("/sla-configurations/bulk/toggle", authRequired, bulkToggleActiveSLAConfigurations);

  

  // Opera√ß√µes especiais

  router.post("/sla-configurations/copy", authRequired, copySLAConfigurations);

  router.post("/sla-configurations/validate", authRequired, validateSLAConfiguration);

  router.post("/sla-configurations/import-csv", authRequired, importSLAConfigurationsCSV);



  // === ROTAS DO DASHBOARD SLA ===

  

  // Dashboard de estat√≠sticas SLA

  router.get("/sla-dashboard/stats", authRequired, async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      const userRole = req.session.userRole;

      const userId = req.session.userId;

      

      if (!companyId) {

        return res.status(400).json({ message: "Empresa n√£o identificada" });

      }



      let departmentIds = req.query.departments ? 

        (req.query.departments as string).split(',').map(id => parseInt(id)).filter(id => !isNaN(id)) : 

        undefined;



      // APLICAR FILTRO DE DEPARTAMENTO PARA MANAGERS

      if (userRole === 'manager') {

        if (!userId) {

          return res.status(403).json({

            success: false,

            error: 'Acesso negado: dados de sess√£o inv√°lidos'

          });

        }



        // Buscar departamentos do manager

        const allOfficials = await storage.getOfficials();

        const currentOfficial = allOfficials.find(o => o.user_id === userId);

        

        if (!currentOfficial) {

          return res.status(403).json({

            success: false,

            error: 'Acesso negado: atendente n√£o encontrado'

          });

        }



        // Buscar departamentos do manager

        const managerDepartments = await db

          .select({ department_id: schema.officialDepartments.department_id })

          .from(schema.officialDepartments)

          .where(eq(schema.officialDepartments.official_id, currentOfficial.id));

        

        const managerDepartmentIds = managerDepartments.map(d => d.department_id).filter(id => id !== null);

        

        if (managerDepartmentIds.length === 0) {

          return res.json({

            totalConfigurations: 0,

            configurationsByDepartment: [],

            slaCompliance: [],

            missingConfigurationAlerts: []

          });

        }



        // Se o filtro de departamento foi especificado, verificar se o manager tem acesso

        if (departmentIds && departmentIds.length > 0) {

          const hasAccess = departmentIds.every(id => managerDepartmentIds.includes(id));

          if (!hasAccess) {

            return res.status(403).json({

              success: false,

              error: 'Acesso negado: voc√™ n√£o tem permiss√£o para visualizar este departamento'

            });

          }

        } else {

          // Se nenhum departamento espec√≠fico foi solicitado, filtrar pelos departamentos do manager

          departmentIds = managerDepartmentIds;

        }

      }



      const stats = await slaApi.getDashboardStats(companyId, departmentIds);

      res.json(stats);

    } catch (error) {

      console.error('Erro ao obter estat√≠sticas do dashboard SLA:', error);

      res.status(500).json({ 

        message: "Erro ao carregar estat√≠sticas do dashboard SLA", 

        error: String(error) 

      });

    }

  });



  // Vis√£o geral de configura√ß√µes por departamento

  router.get("/sla-dashboard/department/:departmentId", authRequired, async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      const userRole = req.session.userRole;

      const userId = req.session.userId;

      

      if (!companyId) {

        return res.status(400).json({ message: "Empresa n√£o identificada" });

      }



      const departmentId = parseInt(req.params.departmentId);

      if (isNaN(departmentId)) {

        return res.status(400).json({ message: "ID do departamento inv√°lido" });

      }



      // APLICAR FILTRO DE DEPARTAMENTO PARA MANAGERS

      if (userRole === 'manager') {

        if (!userId) {

          return res.status(403).json({

            success: false,

            error: 'Acesso negado: dados de sess√£o inv√°lidos'

          });

        }



        // Buscar departamentos do manager

        const allOfficials = await storage.getOfficials();

        const currentOfficial = allOfficials.find(o => o.user_id === userId);

        

        if (!currentOfficial) {

          return res.status(403).json({

            success: false,

            error: 'Acesso negado: atendente n√£o encontrado'

          });

        }



        // Buscar departamentos do manager

        const managerDepartments = await db

          .select({ department_id: schema.officialDepartments.department_id })

          .from(schema.officialDepartments)

          .where(eq(schema.officialDepartments.official_id, currentOfficial.id));

        

        const managerDepartmentIds = managerDepartments.map(d => d.department_id).filter(id => id !== null);

        

        // Verificar se o manager tem acesso ao departamento espec√≠fico

        if (!managerDepartmentIds.includes(departmentId as number)) {

          return res.status(403).json({

            success: false,

            error: 'Acesso negado: voc√™ n√£o tem permiss√£o para visualizar este departamento'

          });

        }

      }



      const overview = await slaApi.getDepartmentOverview(companyId, departmentId);

      res.json(overview);

    } catch (error) {

      console.error('Erro ao obter vis√£o geral do departamento:', error);

      res.status(500).json({ 

        message: "Erro ao carregar vis√£o geral do departamento", 

        error: String(error) 

      });

    }

  });



  // --- FIM DAS ROTAS DO DASHBOARD SLA ---



  // --- FIM DAS ROTAS DE CONFIGURA√á√ïES SLA ---



  // === NOVAS ROTAS PARA COMPANY_ADMIN ===

  

  // Endpoint para listar usu√°rios (todos para admin, apenas da empresa para outros)

  router.get("/company/users", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor', 'support', 'customer']), async (req: Request, res: Response) => {

    try {

      const includeInactive = req.query.includeInactive === 'true';

      const companyId = req.session.companyId;

      const userRole = req.session.userRole;

      

      // Buscar usu√°rios

      const allUsers = includeInactive ? 

        await storage.getAllUsers() : 

        await storage.getActiveUsers();

      

      // Filtrar usu√°rios baseado no papel do usu√°rio

      let filteredUsers;

      if (userRole === 'admin') {

        // Admin v√™ TODOS os usu√°rios do sistema

        filteredUsers = allUsers;

      } else {

        // Outros pap√©is veem apenas usu√°rios da sua empresa

        if (!companyId) {

          return res.status(400).json({ message: "Empresa n√£o identificada" });

        }

        filteredUsers = allUsers.filter(user => user.company_id === companyId);

      }

      

      // N√£o retornar as senhas

      const usersWithoutPasswords = filteredUsers.map(user => {

        const { password, ...userWithoutPassword } = user;

        return userWithoutPassword;

      });

      

      res.json(usersWithoutPasswords);

    } catch (error) {

      console.error('Erro ao listar usu√°rios:', error);

      res.status(500).json({ message: "Falha ao listar usu√°rios", error: String(error) });

    }

  });

  

  // Endpoint para company_admin listar clientes da sua empresa

  router.get("/company/customers", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      

      if (!companyId) {

        return res.status(400).json({ message: "Empresa n√£o identificada" });

      }

      

      // Buscar todos os clientes

      const allCustomers = await storage.getCustomers();

      

      // Filtrar por empresa

      const companyCustomers = allCustomers.filter(customer => customer.company_id === companyId);

      

      res.json(companyCustomers);

    } catch (error) {

      console.error('Erro ao listar clientes da empresa:', error);

      res.status(500).json({ message: "Falha ao listar clientes da empresa", error: String(error) });

    }

  });

  

  // Endpoint para company_admin listar departamentos da sua empresa

  router.get("/company/departments", authRequired, authorize(['admin', 'company_admin', 'manager', 'supervisor']), async (req: Request, res: Response) => {

    try {

      const companyId = req.session.companyId;

      

      if (!companyId) {

        return res.status(400).json({ message: "Empresa n√£o identificada" });

      }

      

      // Buscar departamentos da empresa

      const departments = await db

        .select()

        .from(schema.departments)

        .where(eq(schema.departments.company_id, companyId))

        .orderBy(schema.departments.name);

      

      res.json(departments);

    } catch (error) {

      console.error('Erro ao listar departamentos da empresa:', error);

      res.status(500).json({ message: "Falha ao listar departamentos da empresa", error: String(error) });

    }

  });



  // Registrar router do dashboard

  app.use("/api/tickets", dashboardRouter);

  app.use("/api/logs", logsRouter);

  app.use("/api/ticket-participants", ticketParticipantsRouter);

// Registrar rotas de AI Suggestions
app.post("/api/ai-suggestions", aiSuggestionsAPI.generateSuggestion);
app.post("/api/ai-suggestions/:id/feedback", aiSuggestionsAPI.recordFeedback);
app.get("/api/ai-suggestions/ticket/:ticketId", aiSuggestionsAPI.getSuggestionHistory);

  // Registrar rotas de relat√≥rios

  app.use("/api/reports", reportsRouter);

  

  // Rotas de pesquisa de satisfa√ß√£o (sem autentica√ß√£o - acesso p√∫blico via token)

  const satisfactionSurveyHandlers = await import("./api/satisfaction-surveys");

  router.get("/satisfaction-surveys/:token", satisfactionSurveyHandlers.GET);

  router.post("/satisfaction-surveys/:token", satisfactionSurveyHandlers.POST);

  

  // Rotas do dashboard de satisfa√ß√£o (com autentica√ß√£o)

  const satisfactionDashboardHandlers = await import("./api/satisfaction-dashboard");

  router.get("/satisfaction-dashboard/surveys", authRequired, satisfactionDashboardHandlers.getSurveys);

  router.get("/satisfaction-dashboard/stats", authRequired, satisfactionDashboardHandlers.getStats);

  router.get("/satisfaction-dashboard/export", authRequired, satisfactionDashboardHandlers.exportData);

  

  app.use("/api", router);

  

  // Criar servidor HTTP

  const httpServer = createServer(app);

  

  // Interface para WebSocket com heartbeat

  interface WebSocketWithAlive extends WebSocket {

    isAlive?: boolean;

  }

  

  // Configurar o servidor WebSocket com configura√ß√µes mais flex√≠veis

  const wss = new WebSocketServer({ 

    server: httpServer, 

    path: '/ws',

    // Configura√ß√µes mais permissivas

    verifyClient: (info: any) => {

      // Em desenvolvimento, aceitar tudo

      if (process.env.NODE_ENV !== 'production') {

        console.log(`üîì [DEV] WebSocket aceito de origem: ${info.origin || 'sem origin'}`);

        return true;

      }

      

      // Em produ√ß√£o, verificar origin

      const origin = info.origin;

      const allowedOrigins = [

        'https://suporte.oficinamuda.com.br',

        'http://suporte.oficinamuda.com.br',

        'https://oficinamuda.com.br',

        'http://oficinamuda.com.br',

        'https://app.ticketwise.com.br',

        'http://app.ticketwise.com.br',

        'https://suporte.vixbrasil.com',

        'http://suporte.vixbrasil.com',

        'https://ticketwise.com.br',

        'http://ticketwise.com.br',

        'https://vixbrasil.com',

        'http://vixbrasil.com'

      ];

      

      // Permitir origins conhecidos ou sem origin (requests diretos)

      if (!origin || allowedOrigins.includes(origin)) {

        console.log(`‚úÖ [PROD] WebSocket aceito de origem conhecida: ${origin || 'request direto'}`);

        return true;

      }

      

      // Permitir qualquer subdom√≠nio dos dom√≠nios permitidos

      const allowedDomains = [

        '.oficinamuda.com.br',

        '.ticketwise.com.br', 

        '.vixbrasil.com'

      ];

      

      for (const domain of allowedDomains) {

        if (origin && origin.includes(domain)) {

          console.log(`‚úÖ [PROD] WebSocket aceito de subdom√≠nio: ${origin}`);

          return true;

        }

      }

      

      // Permitir qualquer IP (regex para IPs)

      const ipRegex = /^https?:\/\/(\d{1,3}\.){3}\d{1,3}(:\d+)?$/;

      if (origin && ipRegex.test(origin)) {

        console.log(`‚úÖ [PROD] WebSocket aceito de IP: ${origin}`);

        return true;

      }

      

      // Permitir localhost para testes

      if (origin && (origin.includes('localhost') || origin.includes('127.0.0.1'))) {

        console.log(`‚úÖ [PROD] WebSocket aceito de localhost: ${origin}`);

        return true;

      }

      

      console.log(`üö´ WebSocket bloqueado para origem: ${origin}`);

      return false;

    }

  });

  

  // Lidar com conex√µes WebSocket de forma mais robusta

  wss.on('connection', (ws: WebSocketWithAlive, req) => {

    console.log(`Nova conex√£o WebSocket recebida de: ${req.socket.remoteAddress}`);

    

    // Configurar heartbeat para manter conex√£o viva

    ws.isAlive = true;

    ws.on('pong', () => {

      if (ws.isAlive !== undefined) {

        ws.isAlive = true;

      }

    });

    

    // Autenticar o usu√°rio e configurar a conex√£o

    ws.on('message', (message) => {

      try {

        const data = JSON.parse(message.toString());

        

        // Processar mensagem de autentica√ß√£o

        if (data.type === 'auth') {

          const userId = data.userId;

          const userRole = data.userRole;

          

          if (userId && userRole) {

            // Adicionar o cliente ao servi√ßo de notifica√ß√µes

            notificationService.addClient(ws, userId, userRole);

          }

        }

      } catch (error) {

        console.error('Erro ao processar mensagem WebSocket:', error);

      }

    });

    

    // Lidar com fechamento da conex√£o

    ws.on('close', () => {

      notificationService.removeClient(ws);

      console.log('Conex√£o WebSocket fechada');

    });

    

    // Lidar com erros

    ws.on('error', (error) => {

      console.error('Erro WebSocket:', error);

      notificationService.removeClient(ws);

    });

  });

  

  // Implementar heartbeat para manter conex√µes vivas

  // Respeitar hor√°rio de hiberna√ß√£o: n√£o fazer heartbeat entre 21h e 6h

  const heartbeatInterval = setInterval(() => {

    const now = new Date();

    const hour = now.getHours();

    

    // N√£o fazer heartbeat durante a madrugada (21h √†s 6h)

    if (hour >= 21 || hour < 6) {

      return;

    }

    

    wss.clients.forEach((ws: WebSocketWithAlive) => {

      if (ws.isAlive === false) {

        return ws.terminate();

      }

      

      ws.isAlive = false;

      ws.ping();

    });

  }, 30000); // A cada 30 segundos

  

  // Limpar interval quando servidor fechar

  wss.on('close', () => {

    clearInterval(heartbeatInterval);

  });

  

  return httpServer;



}