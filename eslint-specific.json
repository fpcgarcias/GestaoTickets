[{"filePath":"C:\\Users\\fpcga\\Documents\\GitHub\\GestaoTickets\\server\\api\\clicksign-config.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ClicksignProvider' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"messageId":"unusedVar","endLine":3,"endColumn":27,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ClicksignProvider"},"fix":{"range":[122,198],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":125,"column":24,"messageId":"unusedVar","endLine":125,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":140,"column":22,"messageId":"unusedVar","endLine":140,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":21,"messageId":"unexpectedAny","endLine":163,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6180,6183],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6180,6183],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\r\nimport clicksignConfigService from '../services/clicksign-config-service';\r\nimport { ClicksignProvider } from '../services/digital-signature-service';\r\nimport https from 'https';\r\n\r\nfunction resolveCompanyId(req: Request): number {\r\n  const userRole = req.session?.userRole;\r\n  const sessionCompanyId = req.session?.companyId;\r\n  if (userRole === 'admin' && req.query.company_id) {\r\n    return parseInt(req.query.company_id as string, 10);\r\n  }\r\n  if (sessionCompanyId) {\r\n    return sessionCompanyId;\r\n  }\r\n  throw new Error('Empresa n├úo definida na sess├úo.');\r\n}\r\n\r\n/**\r\n * GET /api/clicksign-config\r\n * Buscar configura├º├Áes da ClickSign da empresa\r\n */\r\nexport async function getClicksignConfig(req: Request, res: Response) {\r\n  try {\r\n    const companyId = resolveCompanyId(req);\r\n    const config = await clicksignConfigService.getConfig(companyId);\r\n\r\n    // Retornar configura├º├Áes\r\n    // Para seguran├ºa, n├úo retornamos os valores reais, apenas indicamos se est├úo configurados\r\n    // O frontend deve manter os valores digitados localmente\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        accessToken: config.accessToken && config.accessToken.length > 0 ? '***configured***' : null,\r\n        apiUrl: config.apiUrl,\r\n        webhookSecret: config.webhookSecret && config.webhookSecret.length > 0 ? '***configured***' : null,\r\n        enabled: config.enabled,\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error('Erro ao buscar configura├º├Áes ClickSign:', error);\r\n    res.status(500).json({ success: false, message: String(error) });\r\n  }\r\n}\r\n\r\n/**\r\n * PUT /api/clicksign-config\r\n * Salvar configura├º├Áes da ClickSign da empresa\r\n */\r\nexport async function updateClicksignConfig(req: Request, res: Response) {\r\n  try {\r\n    const companyId = resolveCompanyId(req);\r\n    const { accessToken, apiUrl, webhookSecret, enabled } = req.body;\r\n\r\n    // Validar campos obrigat├│rios se enabled for true\r\n    if (enabled && (!accessToken || (typeof accessToken === 'string' && accessToken.trim() === ''))) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Access Token ├® obrigat├│rio quando ClickSign est├í habilitado',\r\n      });\r\n    }\r\n\r\n    // Sempre salvar os valores fornecidos (mesmo strings vazias para permitir limpar)\r\n    // Se vier undefined, converter para string vazia\r\n    const configToSave = {\r\n      accessToken: accessToken !== undefined ? String(accessToken) : '',\r\n      apiUrl: apiUrl !== undefined ? String(apiUrl) : 'https://sandbox.clicksign.com',\r\n      webhookSecret: webhookSecret !== undefined ? String(webhookSecret) : '',\r\n      enabled: enabled !== undefined ? Boolean(enabled) : false,\r\n    };\r\n\r\n    await clicksignConfigService.saveConfig(companyId, configToSave);\r\n\r\n    res.json({ success: true, message: 'Configura├º├Áes salvas com sucesso' });\r\n  } catch (error) {\r\n    console.error('Erro ao salvar configura├º├Áes ClickSign:', error);\r\n    res.status(500).json({ success: false, message: String(error) });\r\n  }\r\n}\r\n\r\n/**\r\n * POST /api/clicksign-config/test\r\n * Testar conex├úo com ClickSign\r\n */\r\nexport async function testClicksignConnection(req: Request, res: Response) {\r\n  try {\r\n    const companyId = resolveCompanyId(req);\r\n    const config = await clicksignConfigService.getConfig(companyId);\r\n\r\n    if (!config.enabled || !config.accessToken) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'ClickSign n├úo est├í configurado ou habilitado',\r\n      });\r\n    }\r\n\r\n    // Tentar fazer uma requisi├º├úo simples para validar o token\r\n    try {\r\n      const apiUrl = config.apiUrl;\r\n      const accessToken = config.accessToken!;\r\n      \r\n      // Fazer requisi├º├úo GET para /api/v3/envelopes para validar o token (API v3)\r\n      const url = new URL('/api/v3/envelopes', apiUrl);\r\n      url.searchParams.append('access_token', accessToken);\r\n      \r\n      const testResult = await new Promise((resolve, reject) => {\r\n        const options: https.RequestOptions = {\r\n          method: 'GET',\r\n          headers: {\r\n            'Accept': 'application/json',\r\n            'Content-Type': 'application/json',\r\n          },\r\n        };\r\n\r\n        const req = https.request(url, options, (res) => {\r\n          let body = '';\r\n          res.on('data', (chunk) => body += chunk);\r\n          res.on('end', () => {\r\n            // Se n├úo for sucesso, tratar erro\r\n            if (!res.statusCode || res.statusCode < 200 || res.statusCode >= 300) {\r\n              // Tentar parsear JSON primeiro\r\n              try {\r\n                const parsed = JSON.parse(body);\r\n                const errorMsg = parsed?.message || parsed?.error || `HTTP ${res.statusCode}`;\r\n                reject(new Error(`ClickSign API retornou erro: ${errorMsg}`));\r\n              } catch (e) {\r\n                // Se n├úo for JSON, verificar se ├® HTML\r\n                if (body.toLowerCase().includes('<!doctype') || body.toLowerCase().includes('<html')) {\r\n                  reject(new Error(`ClickSign API retornou erro HTTP ${res.statusCode}. Verifique se o Access Token est├í correto e se a URL da API est├í correta (sandbox ou produ├º├úo).`));\r\n                } else {\r\n                  reject(new Error(`ClickSign API retornou erro HTTP ${res.statusCode}: ${body.substring(0, 100)}`));\r\n                }\r\n              }\r\n              return;\r\n            }\r\n            \r\n            // Resposta de sucesso\r\n            try {\r\n              const parsed = JSON.parse(body);\r\n              resolve(parsed);\r\n            } catch (e) {\r\n              reject(new Error(`Resposta da API n├úo ├® um JSON v├ílido`));\r\n            }\r\n          });\r\n        });\r\n\r\n        req.on('error', (error) => {\r\n          reject(new Error(`Erro de conex├úo: ${error.message}`));\r\n        });\r\n        \r\n        req.setTimeout(10000, () => {\r\n          req.destroy();\r\n          reject(new Error('Timeout ao conectar com ClickSign (10s)'));\r\n        });\r\n        \r\n        req.end();\r\n      });\r\n      \r\n      res.json({\r\n        success: true,\r\n        message: 'Conex├úo com ClickSign estabelecida com sucesso',\r\n        data: testResult,\r\n      });\r\n    } catch (error: any) {\r\n      console.error('Erro ao testar conex├úo ClickSign:', error);\r\n      res.status(400).json({\r\n        success: false,\r\n        message: error.message || 'Falha ao conectar com ClickSign',\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error('Erro ao testar conex├úo ClickSign:', error);\r\n    res.status(500).json({ success: false, message: String(error) });\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\fpcga\\Documents\\GitHub\\GestaoTickets\\server\\api\\clicksign-webhook.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'eq' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"messageId":"unusedVar","endLine":6,"endColumn":12,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"eq"},"fix":{"range":[302,305],"text":""},"desc":"Remove unused variable \"eq\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":41,"messageId":"unexpectedAny","endLine":12,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[460,463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[460,463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":20,"messageId":"unexpectedAny","endLine":118,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4943,4946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4943,4946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":122,"column":26,"messageId":"unusedVar","endLine":122,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":130,"column":31,"messageId":"unusedVar","endLine":130,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":19,"messageId":"unexpectedAny","endLine":152,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6390,6393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6390,6393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":177,"column":16,"messageId":"unusedVar","endLine":177,"endColumn":17},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":189,"column":17,"messageId":"unexpected","endLine":189,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8001,8001],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":41,"messageId":"unexpectedAny","endLine":206,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8793,8796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8793,8796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\r\nimport digitalSignatureService from '../services/digital-signature-service';\r\nimport clicksignConfigService from '../services/clicksign-config-service';\r\nimport { db } from '../db';\r\nimport { inventoryResponsibilityTerms } from '@shared/schema';\r\nimport { eq, inArray } from 'drizzle-orm';\r\nimport crypto from 'crypto';\r\n\r\n/**\r\n * Valida o webhook secret da ClickSign\r\n */\r\nfunction validateWebhookSecret(payload: any, signature: string | undefined, secret: string): boolean {\r\n  if (!signature || !secret) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    // A ClickSign pode enviar o signature em diferentes formatos\r\n    // Normalmente vem como HMAC SHA256 do payload\r\n    let payloadToUpdate: string | Buffer;\r\n\r\n    if (Buffer.isBuffer(payload)) {\r\n        payloadToUpdate = payload;\r\n    } else if (typeof payload === 'string') {\r\n        payloadToUpdate = payload;\r\n    } else {\r\n        payloadToUpdate = JSON.stringify(payload);\r\n    }\r\n\r\n    const expectedSignature = crypto\r\n      .createHmac('sha256', secret)\r\n      .update(payloadToUpdate)\r\n      .digest('hex');\r\n\r\n    // Comparar de forma segura (timing-safe)\r\n    // Normalizar ambos para hex antes de comparar\r\n    const signatureBuffer = Buffer.from(signature, 'hex');\r\n    const expectedBuffer = Buffer.from(expectedSignature, 'hex');\r\n    \r\n    if (signatureBuffer.length !== expectedBuffer.length) {\r\n      return false;\r\n    }\r\n    \r\n    return crypto.timingSafeEqual(signatureBuffer, expectedBuffer);\r\n  } catch (error) {\r\n    console.error('[Clicksign Webhook] Erro ao validar signature:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Endpoint para receber webhooks da ClickSign\r\n */\r\nexport async function handleClicksignWebhook(req: Request, res: Response) {\r\n  const requestId = crypto.randomUUID();\r\n  console.log(`[Clicksign Webhook ${requestId}] Recebido POST /api/webhooks/clicksign`);\r\n  \r\n  try {\r\n    const payload = req.body;\r\n    // Tentar obter assinatura de m├║ltiplos headers poss├¡veis\r\n    let signature = req.headers['x-clicksign-signature'] as string | undefined;\r\n    \r\n    if (!signature && req.headers['content-hmac']) {\r\n        // Content-Hmac vem no formato \"sha256=...\"\r\n        const hmacHeader = req.headers['content-hmac'] as string;\r\n        signature = hmacHeader.replace('sha256=', '');\r\n    }\r\n\r\n    console.log(`[Clicksign Webhook ${requestId}] Headers:`, JSON.stringify(req.headers, null, 2));\r\n    console.log(`[Clicksign Webhook ${requestId}] Payload recebido:`, JSON.stringify(payload, null, 2));\r\n\r\n    // Validar estrutura b├ísica do payload\r\n    if (!payload?.envelope?.key && !payload?.document?.key) {\r\n      console.warn(`[Clicksign Webhook ${requestId}] Payload inv├ílido:`, payload);\r\n      return res.status(400).json({ success: false, message: 'Payload inv├ílido' });\r\n    }\r\n\r\n    // Normalizar nome do evento (API V3 manda objeto, V2 manda string)\r\n    let eventName = '';\r\n    if (payload.event && typeof payload.event === 'object' && payload.event.name) {\r\n      eventName = payload.event.name;\r\n    } else if (typeof payload.event === 'string') {\r\n      eventName = payload.event;\r\n    }\r\n\r\n    console.log(`[Clicksign Webhook ${requestId}] Recebido evento: ${eventName}`);\r\n\r\n    // IGNORAR eventos que ocorrem durante a cria├º├úo (evita erro de Race Condition no banco)\r\n    // upload, add_signer, create, etc. n├úo nos interessam, apenas o resultado final.\r\n    const relevantEvents = ['sign', 'signed', 'envelope.signed', 'envelope.finished', 'finish', 'finished', 'auto_close', 'document_closed', 'cancel', 'canceled', 'envelope.cancelled', 'envelope.canceled'];\r\n    \r\n    if (!relevantEvents.includes(eventName)) {\r\n      console.log(`[Clicksign Webhook ${requestId}] Ignorando evento irrelevante para status final: ${eventName}`);\r\n      return res.status(200).json({ success: true, message: 'Evento ignorado' });\r\n    }\r\n\r\n    // Extrair chaves poss├¡veis para busca\r\n    const keysToSearch = [];\r\n    if (payload.envelope?.key) keysToSearch.push(payload.envelope.key);\r\n    if (payload.document?.key) keysToSearch.push(payload.document.key);\r\n    \r\n    console.log(`[Clicksign Webhook ${requestId}] Processando evento relevante: ${eventName}`);\r\n    console.log(`[Clicksign Webhook ${requestId}] Chaves para busca: ${keysToSearch.join(', ')}`);\r\n\r\n    // Buscar termos candidatos\r\n    const terms = await db\r\n      .select()\r\n      .from(inventoryResponsibilityTerms)\r\n      .where(inArray(inventoryResponsibilityTerms.signature_method, ['clicksign', 'digital']));\r\n\r\n    console.log(`[Clicksign Webhook ${requestId}] Total de termos Clicksign encontrados no banco: ${terms.length}`);\r\n\r\n    // DEBUG EXTREMO: Listar o que temos no banco para entender por que n├úo est├í batendo\r\n    terms.forEach(t => {\r\n        try {\r\n            const rawData = t.signature_data;\r\n            // Tentar parsear. Se for string, parsear de novo (caso de double stringify)\r\n            let d: any = {};\r\n            if (typeof rawData === 'string') {\r\n                try {\r\n                    d = JSON.parse(rawData);\r\n                } catch (e) {\r\n                    console.log(`[DEBUG BANCO] Termo ID ${t.id}: FALHA AO PARSEAR JSON PRIM├üRIO. Conte├║do: ${rawData}`);\r\n                    return;\r\n                }\r\n                \r\n                if (typeof d === 'string') {\r\n                     try {\r\n                        d = JSON.parse(d);\r\n                     } catch (e) {\r\n                        console.log(`[DEBUG BANCO] Termo ID ${t.id}: FALHA AO PARSEAR JSON SECUND├üRIO (double stringify?). Conte├║do: ${d}`);\r\n                     }\r\n                }\r\n            } else if (typeof rawData === 'object') {\r\n                d = rawData;\r\n            }\r\n\r\n            // S├│ logar se tiver algum ID para n├úo poluir demais\r\n            if (d && (d.requestId || d.documentId)) {\r\n                console.log(`[DEBUG BANCO] Termo ID ${t.id}: requestId=${d.requestId}, documentId=${d.documentId}`);\r\n            } else {\r\n                 console.log(`[DEBUG BANCO] Termo ID ${t.id}: Objeto sem IDs. Keys: ${Object.keys(d || {}).join(', ')}`);\r\n            }\r\n        } catch (e) {\r\n            console.log(`[DEBUG BANCO] Termo ID ${t.id}: Erro gen├®rico no debug: ${e}`);\r\n        }\r\n    });\r\n\r\n    const targetTerm = terms.find((term) => {\r\n      if (!term.signature_data) return false;\r\n      try {\r\n        let data: any = term.signature_data;\r\n        // Tratamento robusto para JSON ou String\r\n        if (typeof data === 'string') {\r\n            data = JSON.parse(data);\r\n            // Se ainda for string, parsear de novo (double stringify)\r\n            if (typeof data === 'string') {\r\n                data = JSON.parse(data);\r\n            }\r\n        }\r\n        \r\n        const castedData = data as { requestId?: string; documentId?: string };\r\n        // Verificar se requestId bate com alguma das chaves recebidas\r\n        // OU se documentId bate com alguma das chaves recebidas\r\n        \r\n        let match = false;\r\n        if (castedData.requestId && keysToSearch.includes(castedData.requestId)) {\r\n          match = true;\r\n        } else if (castedData.documentId && keysToSearch.includes(castedData.documentId)) {\r\n          match = true;\r\n        }\r\n        \r\n        if (match) {\r\n          console.log(`[Clicksign Webhook ${requestId}] Termo encontrado! ID: ${term.id}, Status Atual: ${term.status}, RequestID: ${castedData.requestId}, DocumentID: ${castedData.documentId}`);\r\n        }\r\n        return match;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n\r\n    if (!targetTerm) {\r\n      console.warn(`[Clicksign Webhook ${requestId}] Termo N├âO encontrado para chaves: ${keysToSearch.join(', ')}`);\r\n      // Logar alguns requestIds dispon├¡veis para debug\r\n      terms.slice(0, 5).forEach(t => {\r\n        try {\r\n           const d = JSON.parse(t.signature_data || '{}');\r\n           console.log(`[Clicksign Webhook ${requestId}] Termo ${t.id} tem requestId: ${d.requestId}`);\r\n        } catch {}\r\n      });\r\n      \r\n      // Retornar 200 para evitar retries da ClickSign\r\n      return res.status(200).json({ success: false, message: 'Termo n├úo encontrado' });\r\n    }\r\n\r\n    // Validar webhook secret se configurado\r\n    const webhookSecret = await clicksignConfigService.getWebhookSecret(targetTerm.company_id);\r\n    if (webhookSecret) {\r\n      console.log(`[Clicksign Webhook ${requestId}] Validando assinatura com secret configurado...`);\r\n      if (!signature) {\r\n        console.warn(`[Clicksign Webhook ${requestId}] Signature header ausente`);\r\n        return res.status(401).json({ success: false, message: 'Signature ausente' });\r\n      }\r\n\r\n      // Usar rawBody se dispon├¡vel (garante hash correto), sen├úo fallback para JSON.stringify\r\n      const payloadToValidate = (req as any).rawBody || JSON.stringify(payload);\r\n      \r\n      const isValid = validateWebhookSecret(payloadToValidate, signature, webhookSecret);\r\n      \r\n      if (!isValid) {\r\n        console.warn(`[Clicksign Webhook ${requestId}] Signature inv├ílida (Hash recebido: ${signature})`);\r\n        return res.status(401).json({ success: false, message: 'Signature inv├ílida' });\r\n      }\r\n      console.log(`[Clicksign Webhook ${requestId}] Assinatura v├ílida!`);\r\n    } else {\r\n      console.log(`[Clicksign Webhook ${requestId}] Nenhum webhook secret configurado, pulando valida├º├úo de assinatura.`);\r\n    }\r\n\r\n    // Processar webhook\r\n    console.log(`[Clicksign Webhook ${requestId}] Enviando para digitalSignatureService via handleWebhookForTerm (ID: ${targetTerm.id})...`);\r\n    \r\n    // USAR O NOVO M├ëTODO DIRETO QUE N├âO PRECISA BUSCAR O TERMO NOVAMENTE\r\n    await digitalSignatureService.handleWebhookForTerm(targetTerm.id, 'clicksign', payload, targetTerm.company_id);\r\n\r\n    console.log(`[Clicksign Webhook ${requestId}] Webhook processado com sucesso para termo ${targetTerm.id}`);\r\n\r\n    res.status(200).json({ success: true });\r\n  } catch (error) {\r\n    console.error(`[Clicksign Webhook ${requestId}] Erro CR├ìTICO ao processar webhook:`, error);\r\n    // Retornar 200 para evitar retries em caso de erro interno\r\n    res.status(200).json({ success: false, message: 'Erro ao processar webhook' });\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\fpcga\\Documents\\GitHub\\GestaoTickets\\server\\api\\company-permissions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":62,"messageId":"unexpectedAny","endLine":107,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3453,3456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3453,3456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\r\nimport { db } from '../db';\r\nimport * as schema from '../../shared/schema';\r\nimport { eq } from 'drizzle-orm';\r\n\r\n// GET /api/company-permissions/:companyId - Buscar permiss├Áes de uma empresa\r\nexport async function getCompanyPermissions(req: Request, res: Response) {\r\n  try {\r\n    const companyId = parseInt(req.params.companyId);\r\n    if (isNaN(companyId)) {\r\n      return res.status(400).json({ message: \"ID de empresa inv├ílido\" });\r\n    }\r\n\r\n    // Buscar empresa com suas permiss├Áes\r\n    const [company] = await db\r\n      .select({\r\n        id: schema.companies.id,\r\n        name: schema.companies.name,\r\n        ai_permission: schema.companies.ai_permission,\r\n      })\r\n      .from(schema.companies)\r\n      .where(eq(schema.companies.id, companyId))\r\n      .limit(1);\r\n\r\n    if (!company) {\r\n      return res.status(404).json({ message: \"Empresa n├úo encontrada\" });\r\n    }\r\n\r\n    res.json({\r\n      company_id: company.id,\r\n      company_name: company.name,\r\n      permissions: {\r\n        ai_enabled: company.ai_permission,\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Erro ao buscar permiss├Áes da empresa:', error);\r\n    res.status(500).json({ message: \"Falha ao buscar permiss├Áes da empresa\", error: String(error) });\r\n  }\r\n}\r\n\r\n// PUT /api/company-permissions/:companyId - Atualizar permiss├Áes de uma empresa\r\nexport async function updateCompanyPermissions(req: Request, res: Response) {\r\n  try {\r\n    const companyId = parseInt(req.params.companyId);\r\n    if (isNaN(companyId)) {\r\n      return res.status(400).json({ message: \"ID de empresa inv├ílido\" });\r\n    }\r\n\r\n    const { ai_enabled } = req.body;\r\n\r\n    if (typeof ai_enabled !== 'boolean') {\r\n      return res.status(400).json({ message: \"ai_enabled deve ser um boolean\" });\r\n    }\r\n\r\n    // Verificar se empresa existe\r\n    const [existingCompany] = await db\r\n      .select()\r\n      .from(schema.companies)\r\n      .where(eq(schema.companies.id, companyId))\r\n      .limit(1);\r\n\r\n    if (!existingCompany) {\r\n      return res.status(404).json({ message: \"Empresa n├úo encontrada\" });\r\n    }\r\n\r\n    // Atualizar permiss├Áes\r\n    const [updatedCompany] = await db\r\n      .update(schema.companies)\r\n      .set({ \r\n        ai_permission: ai_enabled,\r\n        updated_at: new Date() \r\n      })\r\n      .where(eq(schema.companies.id, companyId))\r\n      .returning({\r\n        id: schema.companies.id,\r\n        name: schema.companies.name,\r\n        ai_permission: schema.companies.ai_permission,\r\n      });\r\n\r\n    res.json({\r\n      company_id: updatedCompany.id,\r\n      company_name: updatedCompany.name,\r\n      permissions: {\r\n        ai_enabled: updatedCompany.ai_permission,\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Erro ao atualizar permiss├Áes da empresa:', error);\r\n    res.status(500).json({ message: \"Falha ao atualizar permiss├Áes da empresa\", error: String(error) });\r\n  }\r\n}\r\n\r\n// GET /api/companies-permissions - Listar todas as empresas com suas permiss├Áes\r\nexport async function getAllCompaniesPermissions(req: Request, res: Response) {\r\n  try {\r\n    const companies = await db\r\n      .select({\r\n        id: schema.companies.id,\r\n        name: schema.companies.name,\r\n        active: schema.companies.active,\r\n        ai_permission: schema.companies.ai_permission,\r\n      })\r\n      .from(schema.companies)\r\n      .orderBy(schema.companies.name);\r\n\r\n    const companiesWithPermissions = companies.map((company: any) => ({\r\n      company_id: company.id,\r\n      company_name: company.name,\r\n      active: company.active,\r\n      permissions: {\r\n        ai_enabled: company.ai_permission,\r\n      }\r\n    }));\r\n\r\n    res.json(companiesWithPermissions);\r\n  } catch (error) {\r\n    console.error('Erro ao buscar empresas e permiss├Áes:', error);\r\n    res.status(500).json({ message: \"Falha ao buscar empresas e permiss├Áes\", error: String(error) });\r\n  }\r\n}\r\n\r\n// GET/PUT /api/settings/ai-usage - Para company_admin gerenciar o toggle de uso de IA\r\nexport async function getAiUsageSettings(req: Request, res: Response) {\r\n  try {\r\n    const companyId = req.session.companyId;\r\n    \r\n    if (!companyId) {\r\n      return res.status(400).json({ message: \"Empresa n├úo identificada\" });\r\n    }\r\n\r\n    // Verificar se a empresa tem permiss├úo para usar IA\r\n    const [company] = await db\r\n      .select({ ai_permission: schema.companies.ai_permission })\r\n      .from(schema.companies)\r\n      .where(eq(schema.companies.id, companyId))\r\n      .limit(1);\r\n\r\n    if (!company) {\r\n      return res.status(404).json({ message: \"Empresa n├úo encontrada\" });\r\n    }\r\n\r\n    if (!company.ai_permission) {\r\n      return res.status(403).json({ \r\n        message: \"Empresa n├úo tem permiss├úo para usar IA\",\r\n        ai_permission_granted: false \r\n      });\r\n    }\r\n\r\n    // Buscar configura├º├úo de uso da IA (system_settings)\r\n    const [setting] = await db\r\n      .select()\r\n      .from(schema.systemSettings)\r\n      .where(eq(schema.systemSettings.key, `ai_usage_company_${companyId}`))\r\n      .limit(1);\r\n\r\n    const aiUsageEnabled = setting ? setting.value === 'true' : true; // Default true\r\n\r\n    res.json({\r\n      ai_permission_granted: true,\r\n      ai_usage_enabled: aiUsageEnabled,\r\n    });\r\n  } catch (error) {\r\n    console.error('Erro ao buscar configura├º├Áes de uso de IA:', error);\r\n    res.status(500).json({ message: \"Falha ao buscar configura├º├Áes de uso de IA\", error: String(error) });\r\n  }\r\n}\r\n\r\nexport async function updateAiUsageSettings(req: Request, res: Response) {\r\n  try {\r\n    const companyId = req.session.companyId;\r\n    const { ai_usage_enabled } = req.body;\r\n\r\n    if (!companyId) {\r\n      return res.status(400).json({ message: \"Empresa n├úo identificada\" });\r\n    }\r\n\r\n    if (typeof ai_usage_enabled !== 'boolean') {\r\n      return res.status(400).json({ message: \"ai_usage_enabled deve ser um boolean\" });\r\n    }\r\n\r\n    // Verificar se a empresa tem permiss├úo para usar IA\r\n    const [company] = await db\r\n      .select({ ai_permission: schema.companies.ai_permission })\r\n      .from(schema.companies)\r\n      .where(eq(schema.companies.id, companyId))\r\n      .limit(1);\r\n\r\n    if (!company) {\r\n      return res.status(404).json({ message: \"Empresa n├úo encontrada\" });\r\n    }\r\n\r\n    if (!company.ai_permission) {\r\n      return res.status(403).json({ \r\n        message: \"Empresa n├úo tem permiss├úo para usar IA\",\r\n        ai_permission_granted: false \r\n      });\r\n    }\r\n\r\n    // Salvar configura├º├úo de uso da IA\r\n    const settingKey = `ai_usage_company_${companyId}`;\r\n    const settingValue = ai_usage_enabled.toString();\r\n\r\n    // Verificar se j├í existe a configura├º├úo\r\n    const [existingSetting] = await db\r\n      .select()\r\n      .from(schema.systemSettings)\r\n      .where(eq(schema.systemSettings.key, settingKey))\r\n      .limit(1);\r\n\r\n    if (existingSetting) {\r\n      // Atualizar\r\n      await db\r\n        .update(schema.systemSettings)\r\n        .set({ \r\n          value: settingValue,\r\n          updated_at: new Date() \r\n        })\r\n        .where(eq(schema.systemSettings.key, settingKey));\r\n    } else {\r\n      // Criar nova\r\n      await db\r\n        .insert(schema.systemSettings)\r\n        .values({\r\n          key: settingKey,\r\n          value: settingValue,\r\n          company_id: companyId,\r\n        });\r\n    }\r\n\r\n    res.json({\r\n      ai_permission_granted: true,\r\n      ai_usage_enabled: ai_usage_enabled,\r\n    });\r\n  } catch (error) {\r\n    console.error('Erro ao atualizar configura├º├Áes de uso de IA:', error);\r\n    res.status(500).json({ message: \"Falha ao atualizar configura├º├Áes de uso de IA\", error: String(error) });\r\n  }\r\n} ","usedDeprecatedRules":[]}]
